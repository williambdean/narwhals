{"config":{"lang":["en"],"separator":"\\.","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narwhals","text":"<p>-</p> <p> </p> <p>Extremely lightweight and extensible compatibility layer between dataframe libraries!</p> <ul> <li>Full API support: cuDF, Modin, pandas, Polars, PyArrow.</li> <li>Lazy-only support: Dask, DuckDB, Ibis, PySpark, SQLFrame. Work in progress: Daft.</li> </ul> <p>Seamlessly support all, without depending on any!</p> <ul> <li>\u2705 Just use a subset of the Polars API, no need to learn anything new</li> <li>\u2705 Zero dependencies, Narwhals only uses what   the user passes in so your library can stay lightweight</li> <li>\u2705 Separate lazy and eager APIs, use expressions</li> <li>\u2705 Support pandas' complicated type system and index, without   either getting in the way</li> <li>\u2705 100% branch coverage, tested against pandas and Polars nightly builds</li> <li>\u2705 Negligible overhead, see overhead</li> <li>\u2705 Let your IDE help you thanks to full static typing, see <code>narwhals.typing</code></li> <li>\u2705 Perfect backwards compatibility policy,   see stable api for how to opt-in</li> </ul>"},{"location":"#whos-this-for","title":"Who's this for?","text":"<p>Anyone wishing to write a library/application/service which consumes dataframes, and wishing to make it completely dataframe-agnostic.</p> <p>Let's get started!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>See roadmap discussion on GitHub for an up-to-date plan of future work.</p>"},{"location":"backcompat/","title":"Perfect backwards compatibility policy","text":"<p>Narwhals is primarily aimed at library maintainers rather than end users. As such, we need to take stability and backwards compatibility extra-seriously. Our policy is:</p> <ul> <li>If you write code using <code>import narwhals.stable.v1 as nw</code>, then we promise to   never change or remove any public function you're using.</li> <li>If we need to make a backwards-incompatible change, it will be pushed into   <code>narwhals.stable.v2</code>, leaving <code>narwhals.stable.v1</code> unaffected.</li> <li>We will maintain <code>narwhals.stable.v1</code> indefinitely, even as <code>narwhals.stable.v2</code> and other   stable APIs come out. For example, Narwhals version 1.0.0 will offer   <code>narwhals.stable.v1</code>, whereas Narwhals 2.0.0 will offer both <code>narwhals.stable.v1</code> and   <code>narwhals.stable.v2</code>.</li> </ul> <p>Like this, we enable different packages to be on different Narwhals stable APIs, and for end-users to use all of them in the same project without conflicts nor incompatibilities.</p>"},{"location":"backcompat/#background","title":"Background","text":"<p>Ever upgraded a package, only to find that it breaks all your tests because of an intentional API change? Did you end up having to litter your code with statements such as the following?</p> <pre><code>if parse_version(pdx.__version__) &lt; parse_version(\"1.3.0\"):\n    df = df.brewbeer()\nelif parse_version(\"1.3.0\") &lt;= parse_version(pdx.__version__) &lt; parse_version(\"1.5.0\"):\n    df = df.brew_beer()\nelse:\n    df = df.brew_drink(\"beer\")\n</code></pre> <p>Now imagine multiplying that complexity over all the dataframe libraries you want to support...</p> <p>Narwhals offers a simple solution, inspired by Rust editions.</p>"},{"location":"backcompat/#narwhals-stable-api","title":"Narwhals' Stable API","text":"<p>Narwhals implements a subset of the Polars API. What will Narwhals do if/when Polars makes a backwards-incompatible change? Would you need to update your Narwhals code?</p> <p>To understand the solution, let's go through an example. Suppose that, hypothetically, in Polars 2.0, <code>polars.Expr.cum_sum</code> was renamed to <code>polars.Expr.cumulative_sum</code>. In Narwhals, we have <code>narwhals.Expr.cum_sum</code>. Does this mean that Narwhals will also rename its method, and deprecate the old one? The answer is...no!</p> <p>Narwhals offers a <code>stable</code> namespace, which allows you to write your code once and forget about it. That is to say, if you write your code like this:</p> from/to_native@narwhalify <pre><code>import narwhals.stable.v1 as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns(nw.col(\"a\").cum_sum()).to_native()\n</code></pre> <pre><code>import narwhals.stable.v1 as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col(\"a\").cum_sum())\n</code></pre> <p>then we, in Narwhals, promise that your code will keep working, even in newer versions of Polars after they have renamed their method.</p> <p>Concretely, we would do the following:</p> <ul> <li><code>narwhals.stable.v1</code>: you can keep using <code>Expr.cum_sum</code></li> <li><code>narwhals.stable.v2</code>: you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> <li><code>narwhals</code>:  you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> </ul> <p>So, although Narwhals' main API (and <code>narwhals.stable.v2</code>) will have introduced a breaking change, users of <code>narwhals.stable.v1</code> will have their code unaffected.</p>"},{"location":"backcompat/#exceptions","title":"Exceptions","text":"<p>Are we really promising perfect backwards compatibility in all cases, without exceptions? Not quite. There are some exceptions, which we'll now list. But we'll never intentionally break your code. Anything currently in <code>narwhals.stable.v1</code> will not be changed or removed in future Narwhals versions.</p> <p>Here are exceptions to our backwards compatibility policy:</p> <ul> <li>Unambiguous bugs. If a function contains what is unambiguously a bug, then we'll fix it, without   considering that to be a breaking change.</li> <li>Radical changes in backends. Suppose that Polars was to remove   expressions, or pandas were to remove support for categorical data. At that point, we might   need to rethink Narwhals. However, we expect such radical changes to be exceedingly unlikely.</li> <li>We may consider making some type hints more precise.</li> <li>Anything labelled \"unstable\".</li> <li>We may sometimes need to bump the minimum versions of supported backends.</li> </ul> <p>In general, decision are driven by use-cases, and we conduct a search of public GitHub repositories before making any change.</p>"},{"location":"backcompat/#import-narwhals-as-nw-or-import-narwhalsstablev1-as-nw","title":"<code>import narwhals as nw</code> or <code>import narwhals.stable.v1 as nw</code>?","text":"<p>Which should you use? In general we recommend:</p> <ul> <li>When prototyping, use <code>import narwhals as nw</code>, so you can iterate quickly.</li> <li>Once you're happy with what you've got and want to release something production-ready and stable,   then switch out your <code>import narwhals as nw</code> usage for <code>import narwhals.stable.v1 as nw</code>.</li> </ul>"},{"location":"backcompat/#main-vs-stablev1","title":"<code>main</code> vs <code>stable.v1</code>","text":"<ul> <li> <p>Since Narwhals 1.35:</p> <ul> <li>pandas' ordered categoricals get mapped to <code>nw.Enum</code> instead of <code>nw.Categorical</code>.</li> <li><code>nw.Enum</code> must be provided <code>categories</code> at instantiation.</li> </ul> </li> <li> <p>Since Narwhals 1.29.0, <code>LazyFrame.gather_every</code> has been deprecated from the main namespace.</p> </li> <li> <p>Since Narwhals 1.24.1, an empty or all-null object-dtype pandas Series is inferred to   be of dtype <code>String</code>. Previously, it would have been inferred as <code>Object</code>.</p> </li> <li> <p>Since Narwhals 1.23:</p> <ul> <li>Passing an <code>ibis.Table</code> to <code>from_native</code> returns a <code>LazyFrame</code>. In   <code>narwhals.stable.v1</code>, it returns a <code>DataFrame</code> with <code>level='interchange'</code>.</li> <li><code>eager_or_interchange_only</code> has been removed from <code>from_native</code> and <code>narwhalify</code>.</li> <li>Order-dependent expressions can no longer be used with <code>narwhals.LazyFrame</code>.</li> <li>The following expressions have been deprecated from the main namespace: <code>Expr.head</code>,   <code>Expr.tail</code>, <code>Expr.gather_every</code>, <code>Expr.sample</code>, <code>Expr.arg_true</code>, <code>Expr.sort</code>.</li> </ul> </li> <li> <p>Since Narwhals 1.21, passing a <code>DuckDBPyRelation</code> to <code>from_native</code> returns a <code>LazyFrame</code>. In   <code>narwhals.stable.v1</code>, it returns a <code>DataFrame</code> with <code>level='interchange'</code>.</p> </li> <li> <p>Since Narwhals 1.15, <code>Series</code> is generic in the native Series, meaning that you can   write:   <pre><code>import narwhals as nw\nimport polars as pl\n\ns_pl = pl.Series([1, 2, 3])\ns = nw.from_native(s, series_only=True)\n# mypy infers `s.to_native()` to be `polars.Series`\nreveal_type(s.to_native())\n</code></pre>   Previously, <code>Series</code> was not generic, so in the above example   <code>s.to_native()</code> would have been inferred as <code>Any</code>.</p> </li> <li> <p>Since Narwhals 1.13.0, the <code>strict</code> parameter in <code>from_native</code>, <code>to_native</code>, and <code>narwhalify</code>     has been deprecated in favour of <code>pass_through</code>. This is because several users expressed     confusion/surprise over what <code>strict=False</code> did.     <pre><code># v1 syntax:\nnw.from_native(df, strict=False)\n\n# main namespace (and, when we get there, v2) syntax:\nnw.from_native(df, pass_through=True)\n</code></pre>     If you are using Narwhals&gt;=1.13.0, then we recommend using <code>pass_through</code>, as that     works consistently across namespaces.</p> <p>In the future:</p> <ul> <li>in the main Narwhals namespace, <code>strict</code> will be removed in favour of <code>pass_through</code></li> <li>in <code>stable.v1</code>, we will keep both <code>strict</code> and <code>pass_through</code></li> </ul> </li> <li> <p>Since Narwhals 1.9.0, <code>Datetime</code> and <code>Duration</code> dtypes hash using both <code>time_unit</code> and     <code>time_zone</code>.     The effect of this can be seen when placing these dtypes in sets:</p> <pre><code>import narwhals.stable.v1 as nw_v1\nimport narwhals as nw\n\n# v1 behaviour:\nassert nw_v1.Datetime(\"us\") in {nw_v1.Datetime}\n\n# main namespace (and, when we get there, v2) behaviour:\nassert nw.Datetime(\"us\") not in {nw.Datetime}\nassert nw.Datetime(\"us\") in {nw.Datetime(\"us\")}\n</code></pre> <p>To check if a dtype is a datetime (regardless of <code>time_unit</code> or <code>time_zone</code>) we recommend using <code>==</code> instead, as that works consistently across namespaces:</p> <pre><code># Recommended\nassert nw.Datetime(\"us\") == nw.Datetime\nassert nw_v1.Datetime(\"us\") == nw_v1.Datetime\n</code></pre> </li> </ul>"},{"location":"ecosystem/","title":"Ecosystem","text":""},{"location":"ecosystem/#used-by","title":"Used by","text":"<p>The following is a non-exhaustive list of libraries and tools that choose to use Narwhals for their dataframe interoperability needs:</p> <ul> <li>altair</li> <li>bokeh</li> <li>darts</li> <li>hierarchicalforecast</li> <li>marimo</li> <li>metalearners</li> <li>panel-graphic-walker</li> <li>plotly</li> <li>pointblank</li> <li>pymarginaleffects</li> <li>py-shiny</li> <li>rio</li> <li>scikit-lego</li> <li>scikit-playtime</li> <li>tabmat</li> <li>tea-tasting</li> <li>timebasedcv</li> <li>tubular</li> <li>Validoopsie</li> <li>vegafusion</li> <li>wimsey</li> </ul> <p>If your project is missing from the list, feel free to open a PR to add it.</p> <p>If you would like to chat with us, or if you need any support, please join our Discord server.</p>"},{"location":"ecosystem/#related-projects","title":"Related projects","text":""},{"location":"ecosystem/#array-api","title":"Array API","text":"<p>Array counterpart to the DataFrame API, see here.</p>"},{"location":"ecosystem/#pycapsule-interface","title":"PyCapsule Interface","text":"<p>Allows C extension modules to safely share pointers to C data structures with Python code and other C modules, encapsulating the pointer with a name and optional destructor to manage resources and ensure safe access, see here for details.</p> <p>Narwhals supports exporting a DataFrame via the Arrow PyCapsule Interface. See Universal dataframe support with the Arrow PyCapsule Interface + Narwhals for how you can use them together.</p>"},{"location":"ecosystem/#ibis","title":"Ibis","text":"<p>Pitched as \"The portable Dataframe library\", Ibis provides a Pythonic frontend to various SQL (as well as Polars LazyFrame) engines. Some differences with Narwhals are:</p> <ul> <li>Narwhals allows you to write \"Dataframe X in, Dataframe X out\" functions.   Ibis allows materialising to pandas, Polars (eager), and PyArrow, but has   no way to get back to the input type exactly (e.g. <code>Enum</code>s don't round-trip in Ibis)</li> <li>Narwhals respects input data types as much as possible, Ibis doesn't   support Categorical / Enum.</li> <li>Narwhals separates between lazy and eager APIs, with the eager API   providing very fine control over dataframe operations (slicing rows and   columns, iterating over rows, getting values out of the dataframe as   Python scalars). Ibis is more focused on lazy execution.</li> <li>Narwhals is extremely lightweight and comes with zero required dependencies,   Ibis requires pandas and PyArrow for all backends.</li> <li>Narwhals uses a subset of the Polars API, Ibis uses its own   pandas/dplyr-inspired API.</li> <li>Ibis currently supports more backends than Narwhals</li> <li>Narwhals supports pandas and Dask, which Ibis has deprecated support for.</li> </ul> <p>Although people often ask about the two tools, we consider them to be very different and not in competition. In particular, Narwhals supports ibis Tables, meaning that dataframe-agnostic code written using Narwhals' lazy API also supports Ibis.</p>"},{"location":"extending/","title":"Extending Narwhals","text":"<p>Warning</p> <p>The extension mechanism in Narwhals is experimental and under development.</p> <p>If you want your own library to be recognised too, you're welcome open a PR (with tests)!. Alternatively, if you can't do that (for example, if you library is closed-source), see the next section for what else you can do.</p> <p>We love open source, but we're not \"open source absolutists\". If you're unable to open source you library, then this is how you can make your library compatible with Narwhals.</p> <p>Make sure that you also define:</p> <ul> <li><code>DataFrame.__narwhals_dataframe__</code>: return an object which implements methods from the     <code>CompliantDataFrame</code> protocol in  <code>narwhals/typing.py</code>.</li> <li><code>DataFrame.__narwhals_namespace__</code>: return an object which implements methods from the     <code>CompliantNamespace</code> protocol in <code>narwhals/typing.py</code>.</li> <li><code>DataFrame.__native_namespace__</code>: return the object's native namespace.</li> <li><code>LazyFrame.__narwhals_lazyframe__</code>: return an object which implements methods from the     <code>CompliantLazyFrame</code> protocol in  <code>narwhals/typing.py</code>.</li> <li><code>LazyFrame.__narwhals_namespace__</code>: return an object which implements methods from the     <code>CompliantNamespace</code> protocol in <code>narwhals/typing.py</code>.</li> <li><code>LazyFrame.__native_namespace__</code>: return the object's native namespace.</li> <li><code>Series.__narwhals_series__</code>: return an object which implements methods from the     <code>CompliantSeries</code> protocol in <code>narwhals/typing.py</code>.</li> </ul> <p>If your library doesn't distinguish between lazy and eager, then it's OK for your dataframe   object to implement both <code>__narwhals_dataframe__</code> and <code>__narwhals_lazyframe__</code>. In fact,   that's currently what <code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> does. So, if you're stuck,   take a look at the source code to see how it's done!</p> <p>Note that this \"extension\" mechanism is still experimental. If anything is not clear, or doesn't work, please do raise an issue or contact us on Discord (see the link on the README).</p>"},{"location":"generating_sql/","title":"Generating SQL","text":"<p>Suppose you want to write Polars syntax and translate it to SQL. For example, what's the SQL equivalent to:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef avg_monthly_price(df_native: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df_native)\n        .group_by(nw.col(\"date\").dt.truncate(\"1mo\"))\n        .agg(nw.col(\"price\").mean())\n        .sort(\"date\")\n        .to_native()\n    )\n</code></pre> <p>?</p> <p>There are several ways to find out.</p>"},{"location":"generating_sql/#via-sqlframe-most-lightweight-solution","title":"Via SQLFrame (most lightweight solution)","text":"<p>The most lightweight solution which does not require any heavy dependencies, nor any actual table or dataframe, is with SQLFrame.</p> <pre><code>from sqlframe.standalone import StandaloneSession\n\nsession = StandaloneSession.builder.getOrCreate()\nsession.catalog.add_table(\"prices\", column_mapping={\"date\": \"date\", \"price\": \"float\"})\ndf = nw.from_native(session.read.table(\"prices\"))\n\nprint(avg_monthly_price(df).sql(dialect=\"duckdb\"))\n</code></pre> <pre><code>WITH \"t20239543\" AS (\n  SELECT\n    CAST(DATE_TRUNC('MONTH', CAST(\"prices\".\"date\" AS TIMESTAMPTZ)) AS TIMESTAMPTZ) AS \"_date_tmp\",\n    AVG(\"prices\".\"price\") AS \"price\"\n  FROM \"prices\" AS \"prices\"\n  GROUP BY\n    CAST(DATE_TRUNC('MONTH', CAST(\"prices\".\"date\" AS TIMESTAMPTZ)) AS TIMESTAMPTZ)\n)\nSELECT\n  \"t20239543\".\"_date_tmp\" AS \"date\",\n  \"t20239543\".\"price\" AS \"price\"\nFROM \"t20239543\" AS \"t20239543\"\nORDER BY\n  \"date\" NULLS FIRST\n</code></pre> <p>Or, to print the SQL code in a different dialect (say, databricks):</p> <pre><code>print(avg_monthly_price(df).sql(dialect=\"databricks\"))\n</code></pre> <pre><code>WITH `t20239543` AS (\n  SELECT\n    CAST(DATE_TRUNC('MONTH', CAST(`prices`.`date` AS TIMESTAMP)) AS TIMESTAMP) AS `_date_tmp`,\n    AVG(`prices`.`price`) AS `price`\n  FROM `prices` AS `prices`\n  GROUP BY\n    CAST(DATE_TRUNC('MONTH', CAST(`prices`.`date` AS TIMESTAMP)) AS TIMESTAMP)\n)\nSELECT\n  `t20239543`.`_date_tmp` AS `date`,\n  `t20239543`.`price` AS `price`\nFROM `t20239543` AS `t20239543`\nORDER BY\n  `date`\n</code></pre>"},{"location":"generating_sql/#via-duckdb","title":"Via DuckDB","text":"<p>You can also generate SQL directly from DuckDB.</p> <pre><code>import duckdb\n\nconn = duckdb.connect()\nconn.sql(\"\"\"CREATE TABLE prices (date DATE, price DOUBLE);\"\"\")\n\ndf = nw.from_native(conn.table(\"prices\"))\nprint(avg_monthly_price(df).sql_query())\n</code></pre> <pre><code>SELECT * FROM (SELECT _date_tmp AS date, price FROM (SELECT _date_tmp, mean(price) AS price FROM (SELECT date, price, date_trunc('month', date) AS _date_tmp FROM main.prices) AS prices GROUP BY ALL) AS prices) AS prices ORDER BY date NULLS FIRST\n</code></pre> <p>To make it look a bit prettier, we can pass it to SQLGlot:</p> <pre><code>import sqlglot\n\nprint(sqlglot.transpile(avg_monthly_price(df).sql_query(), pretty=True)[0])\n</code></pre> <pre><code>SELECT\n  *\nFROM (\n  SELECT\n    _date_tmp AS date,\n    price\n  FROM (\n    SELECT\n      _date_tmp,\n      MEAN(price) AS price\n    FROM (\n      SELECT\n        date,\n        price,\n        DATE_TRUNC('MONTH', date) AS _date_tmp\n      FROM main.prices\n    ) AS prices\n    GROUP BY ALL\n  ) AS prices\n) AS prices\nORDER BY\n  date\n</code></pre>"},{"location":"generating_sql/#via-ibis","title":"Via Ibis","text":"<p>We can also use Ibis to generate SQL:</p> <pre><code>import ibis\n\nt = ibis.table({\"date\": \"date\", \"price\": \"double\"}, name=\"prices\")\nprint(ibis.to_sql(avg_monthly_price(t)))\n</code></pre> <pre><code>SELECT\n  \"t2\".\"_date_tmp\" AS \"date\",\n  \"t2\".\"price\"\nFROM (\n  SELECT\n    \"t1\".\"_date_tmp\",\n    AVG(\"t1\".\"price\") AS \"price\"\n  FROM (\n    SELECT\n      \"t0\".\"date\",\n      \"t0\".\"price\",\n      DATE_TRUNC('MONTH', \"t0\".\"date\") AS \"_date_tmp\"\n    FROM \"prices\" AS \"t0\"\n  ) AS \"t1\"\n  GROUP BY\n    1\n) AS \"t2\"\nORDER BY\n  \"t2\".\"_date_tmp\" ASC NULLS FIRST\n</code></pre>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#theory","title":"Theory","text":"<p>You might think that Narwhals runs on underwater unicorn magic. However, this section exists to reassure you that there's no such thing. There's only one rule you need to understand in order to make sense of Narwhals:</p> <p>An expression is a function from a DataFrame to a sequence of Series.</p> <p>For example, <code>nw.col('a')</code> means \"given a dataframe <code>df</code>, give me the Series <code>'a'</code> from <code>df</code>\". Translating this to pandas syntax, we get:</p> <pre><code>def col_a(df):\n    return [df.loc[:, \"a\"]]\n</code></pre> <p>Let's step up the complexity. How about <code>nw.col('a')+1</code>? We already know what the <code>nw.col('a')</code> part looks like, so we just need to add <code>1</code> to each of its outputs:</p> <pre><code>def col_a(df):\n    return [df.loc[:, \"a\"]]\n\n\ndef col_a_plus_1(df):\n    return [x + 1 for x in col_a(df)]\n</code></pre> <p>Expressions can return multiple Series - for example, <code>nw.col('a', 'b')</code> translates to:</p> <pre><code>def col_a_b(df):\n    return [df.loc[:, \"a\"], df.loc[:, \"b\"]]\n</code></pre> <p>Expressions can also take multiple columns as input - for example, <code>nw.sum_horizontal('a', 'b')</code> translates to:</p> <pre><code>def sum_horizontal_a_b(df):\n    return [df.loc[:, \"a\"] + df.loc[:, \"b\"]]\n</code></pre> <p>Note that although an expression may have multiple columns as input, those columns must all have been derived from the same dataframe. This last sentence was quite important, you might want to re-read it to make sure it sunk in.</p> <p>By itself, an expression doesn't produce a value. It only produces a value once you give it to a DataFrame context. What happens to the value(s) it produces depends on which context you hand it to:</p> <ul> <li><code>DataFrame.select</code>: produce a DataFrame with only the result of the given expression</li> <li><code>DataFrame.with_columns</code>: produce a DataFrame like the current one, but also with the result of   the given expression</li> <li><code>DataFrame.filter</code>: evaluate the given expression, and if it only returns a single Series, then   only keep rows where the result is <code>True</code>.</li> </ul> <p>Now let's turn our attention to the implementation.</p>"},{"location":"how_it_works/#pandas-implementation","title":"pandas implementation","text":"<p>The pandas namespace (<code>pd</code>) isn't Narwhals-compliant, as the pandas API is very different from Polars'. So...Narwhals implements a <code>PandasLikeNamespace</code>, which includes the top-level Polars functions included in the Narwhals API:</p> <p><pre><code>import pandas as pd\nimport narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals.utils import parse_version, Version\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n    version=Version.MAIN,\n)\nprint(nw.col(\"a\")._to_compliant_expr(pn))\n</code></pre> <pre><code>PandasLikeExpr(depth=0, function_name=col)\n</code></pre> The result from the last line above is the same as we'd get from <code>pn.col('a')</code>, and it's a <code>narwhals._pandas_like.expr.PandasLikeExpr</code> object, which we'll call <code>PandasLikeExpr</code> for short.</p> <p><code>PandasLikeExpr</code> has a <code>_call</code> method which expects a <code>PandasLikeDataFrame</code> as input. Recall from above that an expression is a function from a dataframe to a sequence of series. The <code>_call</code> method gives us that function! Let's see it in action.</p> <p>Note: the following examples use <code>PandasLikeDataFrame</code> and <code>PandasLikeSeries</code>. These are backed by actual <code>pandas.DataFrame</code>s and <code>pandas.Series</code> respectively and are Narwhals-compliant. We can access the  underlying pandas objects via <code>PandasLikeDataFrame._native_frame</code> and <code>PandasLikeSeries._native_series</code>.</p> <pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._pandas_like.dataframe import PandasLikeDataFrame\nfrom narwhals.utils import parse_version, Version\nimport pandas as pd\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n    version=Version.MAIN,\n)\n\ndf_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\ndf = PandasLikeDataFrame(\n    df_pd,\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n    version=Version.MAIN,\n    validate_column_names=True,\n)\nexpression = pn.col(\"a\") + 1\nresult = expression._call(df)\nprint(f\"length of result: {len(result)}\\n\")\nprint(\"native series of first value of result: \")\nprint([x._native_series for x in result][0])\n</code></pre> <pre><code>length of result: 1\n\nnative series of first value of result: \n0    2\n1    3\n2    4\nName: a, dtype: int64\n</code></pre> <p>So indeed, our expression did what it said on the tin - it took some dataframe, took column 'a', and added 1 to it.</p> <p>If you search for <code>def reuse_series_implementation</code>, you'll see that that's all expressions do in Narwhals - they just keep rigorously applying the definition of expression.</p> <p>It may look like there should be significant overhead to doing it this way - but really, it's just a few Python calls which get unwinded. From timing tests I've done, there's no detectable difference - in fact, because the Narwhals API guards against misusing the pandas API, it's likely that running pandas via Narwhals will in general be more efficient than running pandas directly.</p> <p>Further attempts at demistifying Narwhals, refactoring code so it's clearer, and explaining this section better are 110% welcome.</p>"},{"location":"how_it_works/#polars-and-other-implementations","title":"Polars and other implementations","text":"<p>Other implementations are similar to the above: they define their own Narwhals-compliant objects. So, all-in-all, there are a couple of layers here:</p> <ul> <li><code>nw.DataFrame</code> is backed by a Narwhals-compliant Dataframe, such as:<ul> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code></li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code></li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code></li> </ul> </li> <li>each Narwhals-compliant DataFrame is backed by a native Dataframe, for example:<ul> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> is backed by a pandas DataFrame</li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code> is backed by a PyArrow Table</li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code> is backed by a Polars DataFrame</li> </ul> </li> </ul> <p>Each implementation defines its own objects in subfolders such as <code>narwhals._pandas_like</code>, <code>narwhals._arrow</code>, <code>narwhals._polars</code>, whereas the top-level modules such as <code>narwhals.dataframe</code> and <code>narwhals.series</code> coordinate how to dispatch the Narwhals API to each backend.</p>"},{"location":"how_it_works/#mapping-from-api-to-implementations","title":"Mapping from API to implementations","text":"<p>If an end user executes some Narwhals code, such as</p> <p><pre><code>df.select(nw.col(\"a\") + 1)\n</code></pre> then how does that get mapped to the underlying dataframe's native API? Let's walk through this example to see.</p> <p>Things generally go through a couple of layers:</p> <ul> <li>The user calls some top-level Narwhals API.</li> <li>The Narwhals API forwards the call to a Narwhals-compliant dataframe wrapper, such as<ul> <li><code>PandasLikeDataFrame</code> / <code>ArrowDataFrame</code> / <code>PolarsDataFrame</code> / ...</li> <li><code>PandasLikeSeries</code> / <code>ArrowSeries</code> / <code>PolarsSeries</code> / ...</li> <li><code>PandasLikeExpr</code> / <code>ArrowExpr</code> / <code>PolarsExpr</code> / ...</li> </ul> </li> <li>The dataframe wrapper forwards the call to the underlying library, e.g.:<ul> <li><code>PandasLikeDataFrame</code> forwards the call to the underlying pandas/Modin/cuDF dataframe.</li> <li><code>ArrowDataFrame</code> forwards the call to the underlying PyArrow table.</li> <li><code>PolarsDataFrame</code> forwards the call to the underlying Polars DataFrame.</li> </ul> </li> </ul> <p>The way you access the Narwhals-compliant wrapper depends on the object:</p> <ul> <li><code>narwhals.DataFrame</code> and <code>narwhals.LazyFrame</code>: use the <code>._compliant_frame</code> attribute.</li> <li><code>narwhals.Series</code>: use the <code>._compliant_series</code> attribute.</li> <li><code>narwhals.Expr</code>: call the <code>._to_compliant_expr</code> method, and pass to it the Narwhals-compliant namespace associated with   the given backend.</li> </ul> <p>\ud83d\uded1 BUT WAIT! What's a Narwhals-compliant namespace?</p> <p>Each backend is expected to implement a Narwhals-compliant namespace (<code>PandasLikeNamespace</code>, <code>ArrowNamespace</code>, <code>PolarsNamespace</code>). These can be used to interact with the Narwhals-compliant Dataframe and Series objects described above - let's work through the motivating example to see how.</p> <pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._pandas_like.dataframe import PandasLikeDataFrame\nfrom narwhals.utils import parse_version, Version\nimport pandas as pd\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n    version=Version.MAIN,\n)\n\ndf_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\ndf = nw.from_native(df_pd)\ndf.select(nw.col(\"a\") + 1)\n</code></pre> <p>The first thing <code>narwhals.DataFrame.select</code> does is to parse each input expression to end up with a compliant expression for the given backend, and it does so by passing a Narwhals-compliant namespace to <code>nw.Expr._to_compliant_expr</code>:</p> <p><pre><code>pn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n    version=Version.MAIN,\n)\nexpr = (nw.col(\"a\") + 1)._to_compliant_expr(pn)\nprint(expr)\n</code></pre> <pre><code>PandasLikeExpr(depth=1, function_name=col-&gt;__add__)\n</code></pre> If we then extract a Narwhals-compliant dataframe from <code>df</code> by calling <code>._compliant_frame</code>, we get a <code>PandasLikeDataFrame</code> - and that's an object which we can pass <code>expr</code> to!</p> <pre><code>df_compliant = df._compliant_frame\nresult = df_compliant.select(expr)\n</code></pre> <p>We can then view the underlying pandas Dataframe which was produced by calling <code>._native_frame</code>:</p> <p><pre><code>print(result._native_frame)\n</code></pre> <pre><code>   a\n0  2\n1  3\n2  4\n</code></pre> which is the same as we'd have obtained by just using the Narwhals API directly:</p> <pre><code>print(nw.to_native(df.select(nw.col(\"a\") + 1)))\n</code></pre> <pre><code>   a\n0  2\n1  3\n2  4\n</code></pre>"},{"location":"how_it_works/#group-by","title":"Group-by","text":"<p>Group-by is probably one of Polars' most significant innovations (on the syntax side) with respect to pandas. We can write something like <pre><code>df: pl.DataFrame\ndf.group_by(\"a\").agg((pl.col(\"c\") &gt; pl.col(\"b\").mean()).max())\n</code></pre> To do this in pandas, we need to either use <code>GroupBy.apply</code> (sloooow), or do some crazy manual optimisations to get it to work.</p> <p>In Narwhals, here's what we do:</p> <ul> <li>if somebody uses a simple group-by aggregation (e.g. <code>df.group_by('a').agg(nw.col('b').mean())</code>),   then on the pandas side we translate it to   <pre><code>df: pd.DataFrame\ndf.groupby(\"a\").agg({\"b\": [\"mean\"]})\n</code></pre></li> <li>if somebody passes a complex group-by aggregation, then we use <code>apply</code> and raise a <code>UserWarning</code>, warning   users of the performance penalty and advising them to refactor their code so that the aggregation they perform   ends up being a simple one.</li> </ul> <p>In order to tell whether an aggregation is simple, Narwhals uses the private <code>_depth</code> attribute of <code>PandasLikeExpr</code>:</p> <pre><code>print(pn.col(\"a\").mean())\nprint((pn.col(\"a\") + 1).mean())\n</code></pre> <pre><code>PandasLikeExpr(depth=1, function_name=col-&gt;mean)\nPandasLikeExpr(depth=2, function_name=col-&gt;__add__-&gt;mean)\n</code></pre> <p>For simple aggregations, Narwhals can just look at <code>_depth</code> and <code>function_name</code> and figure out which (efficient) elementary operation this corresponds to in pandas.</p>"},{"location":"how_it_works/#expression-metadata","title":"Expression Metadata","text":"<p>Let's try printing out a few expressions to the console to see what they show us:</p> <pre><code>import narwhals as nw\n\nprint(nw.col(\"a\"))\nprint(nw.col(\"a\").mean())\nprint(nw.col(\"a\").mean().over(\"b\"))\n</code></pre> <pre><code>Narwhals Expr\nmetadata: ExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  last_node: ExprKind.ELEMENTWISE,\n  has_windows: False,\n  n_orderable_ops: 0,\n  is_elementwise: True,\n  preserves_length: True,\n  is_scalar_like: False,\n  is_literal: False,\n)\n\nNarwhals Expr\nmetadata: ExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  last_node: ExprKind.AGGREGATION,\n  has_windows: False,\n  n_orderable_ops: 0,\n  is_elementwise: False,\n  preserves_length: False,\n  is_scalar_like: True,\n  is_literal: False,\n)\n\nNarwhals Expr\nmetadata: ExprMetadata(\n  expansion_kind: ExpansionKind.SINGLE,\n  last_node: ExprKind.OVER,\n  has_windows: True,\n  n_orderable_ops: 0,\n  is_elementwise: False,\n  preserves_length: True,\n  is_scalar_like: False,\n  is_literal: False,\n)\n</code></pre> <p>Note how they tell us something about their metadata. This section is all about making sense of what that all means, what the rules are, and what it enables.</p> <p>Here's a brief description of each piece of metadata:</p> <ul> <li> <p><code>expansion_kind</code>: How and whether the expression expands to multiple outputs.   This can be one of:</p> <ul> <li><code>ExpansionKind.SINGLE</code>: Only produces a single output. For example, <code>nw.col('a')</code>.</li> <li><code>ExpansionKind.MULTI_NAMED</code>: Produces multiple outputs whose names can be   determined statically, for example <code>nw.col('a', 'b')</code>.</li> <li><code>ExpansionKind.MULTI_UNNAMED</code>: Produces multiple outputs whose names depend   on the input dataframe. For example, <code>nw.nth(0, 1)</code> or <code>nw.selectors.numeric()</code>.</li> </ul> </li> <li> <p><code>last_node</code>: Kind of the last operation in the expression. See   <code>narwhals._expression_parsing.ExprKind</code> for the various options.</p> </li> <li><code>has_windows</code>: Whether the expression already contains an <code>over(...)</code> statement.</li> <li> <p><code>n_orderable_ops</code>: How many order-dependent operations the expression contains.</p> <p>Examples:</p> <ul> <li><code>nw.col('a')</code> contains 0 orderable operations.</li> <li><code>nw.col('a').diff()</code> contains 1 orderable operation.</li> <li><code>nw.col('a').diff().shift()</code> contains 2 orderable operation.</li> </ul> </li> <li> <p><code>is_elementwise</code>: Whether it preserves length and operates on each row independently   of the rows around it (e.g. <code>abs</code>, <code>is_null</code>, <code>round</code>, ...).</p> </li> <li><code>preserves_length</code>: Whether the output of the expression is the same length as   the dataframe it gets evaluated on.</li> <li><code>is_scalar_like</code>: Whether the output of the expression is always length-1.</li> <li><code>is_literal</code>: Whether the expression doesn't depend on any column but instead   only on literal values, like <code>nw.lit(1)</code>.</li> </ul>"},{"location":"how_it_works/#chaining","title":"Chaining","text":"<p>Say we have <code>expr.expr_method()</code>. How does <code>expr</code>'s <code>ExprMetadata</code> change? This depends on <code>expr_method</code>. Details can be found in <code>narwhals/_expression_parsing</code>, in the <code>ExprMetadata.with_*</code> methods.</p>"},{"location":"how_it_works/#binary-operations-eg-nwcola-nwcolb","title":"Binary operations (e.g. <code>nw.col('a') + nw.col('b')</code>)","text":"<p>How do expression kinds change under binary operations? For example, if we do <code>expr1 + expr2</code>, then what can we say about the output kind? The rules are:</p> <ul> <li> <p>If one changes the input length (e.g. <code>Expr.drop_nulls</code>), then:</p> <ul> <li>if the other is scalar-like, then the output also changes length.</li> <li>else, we raise an error.</li> </ul> </li> <li> <p>If one preserves length and the other is scalar-like, then the output   preserves length (because of broadcasting).</p> </li> <li>If one is scalar-like but not literal and the other is scalar-like,   the output is scalar-like but not literal.</li> </ul> <p>For n-ary operations such as <code>nw.sum_horizontal</code>, the above logic is extended across inputs. For example, <code>nw.sum_horizontal(expr1, expr2, expr3)</code> is <code>LITERAL</code> if all of <code>expr1</code>, <code>expr2</code>, and <code>expr3</code> are.</p>"},{"location":"how_it_works/#you-open-a-window-to-another-window-to-another-window-to-another-window","title":"\"You open a window to another window to another window to another window\"","text":"<p>When working with <code>DataFrame</code>s, row order is well-defined, as the dataframes are assumed to be eager and in-memory. Therefore, <code>n_orderable_ops</code> is disregarded.</p> <p>When working with <code>LazyFrame</code>s, on the other hand, row order is undefined. Therefore, when evaluating an expression, <code>n_orderable_ops</code> must be exactly zero - if it's not, it means that the expression depends on physical row order, which is not allowed for <code>LazyFrame</code>s. The way that <code>n_orderable_ops</code> can change is:</p> <ul> <li>Orderable window functions like <code>diff</code> and <code>rolling_mean</code> increase <code>n_orderable_ops</code>   by 1.</li> <li>If an orderable window function is immediately followed by <code>over(order_by=...)</code>,   then <code>n_orderable_ops</code> is decreased by 1. This is the only way that   <code>n_orderable_ops</code> can decrease.</li> </ul>"},{"location":"how_it_works/#broadcasting","title":"Broadcasting","text":"<p>When performing comparisons between columns and aggregations or scalars, we operate as if the aggregation or scalar was broadcasted to the length of the whole column. For example, if we have a dataframe with values <code>{'a': [1, 2, 3]}</code> and do <code>nw.col('a') - nw.col('a').mean()</code>, then each value from column <code>'a'</code> will have its mean subtracted from it, and we will end up with values <code>[-1, 0, 1]</code>.</p> <p>Different libraries do broadcasting differently. SQL-like libraries require an empty window function for expressions (e.g. <code>a - sum(a) over ()</code>), Polars does its own broadcasting of length-1 Series, and pandas does its own broadcasting of scalars.</p> <p>Narwhals triggers a broadcast in these situations:</p> <ul> <li>In <code>select</code> when some values preserve length and others don't, e.g.   <code>df.select('a', nw.col('b').mean())</code>.</li> <li>In <code>with_columns</code>, all new columns get broadcasted to the length of the dataframe.</li> <li>In n-ary operations between expressions, such as <code>nw.col('a') + nw.col('a').mean()</code>.</li> </ul> <p>Each backend is then responsible for doing its own broadcasting, as defined in each <code>CompliantExpr.broadcast</code> method.</p>"},{"location":"installation/","title":"Installation and quick start","text":""},{"location":"installation/#installation","title":"Installation","text":"UVPython's venv <p>First, ensure you have installed UV, and make sure you have created and activated a Python 3.8+ virtual environment.</p> <p>If you haven't, you can follow our setting up your environment guide. Then, run:</p> <pre><code>uv pip install narwhals\n</code></pre> <p>First, ensure you have created and activated a Python 3.8+ virtual environment.</p> <p>Then, run:</p> <pre><code>python -m pip install narwhals\n</code></pre>"},{"location":"installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To verify the installation, start the Python REPL and execute:</p> <pre><code>import narwhals\n\nprint(narwhals.__version__)\n</code></pre> <pre><code>1.40.0\n</code></pre> <p>If you see the version number, then the installation was successful!</p>"},{"location":"installation/#quick-start","title":"Quick start","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Please start by following the installation instructions.</p> <p>To follow along with the examples which follow, please install the following (though note that they are not required dependencies - Narwhals only ever uses what the user passes in):</p> <ul> <li>pandas</li> <li>Polars</li> <li>PyArrow</li> </ul>"},{"location":"installation/#simple-example","title":"Simple example","text":"<p>Create a Python file <code>t.py</code> with the following content:</p> <pre><code>from __future__ import annotations\n\nimport pandas as pd\nimport polars as pl\nimport pyarrow as pa\nimport narwhals as nw\nfrom narwhals.typing import IntoFrame\n\n\ndef agnostic_get_columns(df_native: IntoFrame) -&gt; list[str]:\n    df = nw.from_native(df_native)\n    column_names = df.columns\n    return column_names\n\n\ndata = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\ndf_pandas = pd.DataFrame(data)\ndf_polars = pl.DataFrame(data)\ntable_pa = pa.table(data)\n\nprint(\"pandas output\")\nprint(agnostic_get_columns(df_pandas))\n\nprint(\"Polars output\")\nprint(agnostic_get_columns(df_polars))\n\nprint(\"PyArrow output\")\nprint(agnostic_get_columns(table_pa))\n</code></pre> <pre><code>pandas output\n['a', 'b']\nPolars output\n['a', 'b']\nPyArrow output\n['a', 'b']\n</code></pre> <p>If you run <code>python t.py</code> then your output should look like the above. This is the simplest possible example of a dataframe-agnostic function - as we'll soon see, we can do much more advanced things.</p> <p>Let's learn about what you just did, and what Narwhals can do for you!</p> <p>Info</p> <p>These examples are using pandas, Polars, and PyArrow, however Narwhals supports other dataframe libraries (See the home page for supported libraries).</p>"},{"location":"overhead/","title":"Overhead","text":"<p>Narwhals converts Polars syntax to non-Polars dataframes.</p> <p>So, what's the overhead of running \"pandas\" vs \"pandas via Narwhals\"?</p> <p>Based on experiments we've done, the answer is: it's negligible. Sometimes it's even negative, because of how careful we are in Narwhals to avoid unnecessary copies and index resets. Here are timings from the TPC-H queries, comparing running pandas directly vs running pandas via Narwhals:</p> <p></p> <p>Complete code to reproduce.</p>"},{"location":"overhead/#plotlys-story","title":"Plotly's story","text":"<p>One big difference between Plotly v5 and Plotly v6 is the handling of non-pandas inputs:</p> <ul> <li>In v5, Plotly would convert non-pandas inputs to pandas.</li> <li>In v6, Plotly operates on non-pandas inputs natively (via Narwhals).</li> </ul> <p>We expected that this would bring a noticeable performance benefit for non-pandas inputs, but that there may be some slight overhead for pandas.</p> <p>Instead, we observed that things got noticeably faster for both non-pandas inputs and for pandas ones!</p> <ul> <li>Polars plots got 3x, and sometimes even more than 10x, faster.</li> <li>pandas plots were typically no slower, but sometimes ~20% faster.</li> </ul> <p>Full details on Plotly's write-up.</p>"},{"location":"overhead/#overhead-for-duckdb-pyspark-and-other-lazy-backends","title":"Overhead for DuckDB, PySpark, and other lazy backends","text":"<p>For lazy backends, Narwhals respects the backends' laziness and always keeps everything lazy. Narwhals never evaluates a full query unless you ask it to (with <code>.collect()</code>).</p> <p>In order to mimic Polars' behaviour, there are some places where Narwhals does need to inspect dataframes' schemas, such as:</p> <ul> <li>joins</li> <li>selectors</li> <li><code>nth</code></li> <li><code>concat</code> with <code>how='vertical'</code></li> <li><code>unique</code></li> </ul> <p>This is typically cheap (as it does not require reading a full dataset into memory and can often just be done from metadata alone) but it's not free, especially if your data lives on the cloud. To minimise the overhead, when Narwhals needs to evaluate schemas or column names, it makes sure to cache them.</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#sponsors-and-institutional-partners","title":"Sponsors and institutional partners","text":"<p>Narwhals is 100% independent, community-driven, and community-owned. We are extremely grateful to the following organisations for having provided some funding / development time:</p> <ul> <li>Quansight Labs</li> <li>Quansight Futures</li> <li>OpenTeams</li> <li>POSSEE initiative</li> <li>BYU-Idaho</li> </ul> <p>If you contribute to Narwhals on your organization's time, please let us know. We'd be happy to add your employer to this list!</p>"},{"location":"resources/#appears-on","title":"Appears on","text":"<p>Narwhals has been featured in several talks, podcasts, and blog posts:</p> <ul> <li> <p>Talk Python to me Podcast   Ahoy, Narwhals are bridging the data science APIs</p> </li> <li> <p>Python Bytes Podcast   Episode 402, topic #2</p> </li> <li> <p>Super Data Science: ML &amp; AI Podcast   Narwhals: For Pandas-to-Polars DataFrame Compatibility</p> </li> <li> <p>Sample Space Podcast | probabl   How Narwhals has many end users ... that never use it directly. - Marco Gorelli</p> </li> <li> <p>The Real Python Podcast   Narwhals: Expanding DataFrame Compatibility Between Libraries</p> </li> <li> <p>Pycon Lithuania   Marco Gorelli - DataFrame interoperatiblity - what's been achieved, and what comes next?</p> </li> <li> <p>Pycon Italy   How you can write a dataframe-agnostic library - Marco Gorelli</p> </li> <li> <p>Polars Blog Post   Polars has a new lightweight plotting backend</p> </li> <li> <p>Quansight Labs blog post (w/ Scikit-Lego)   How Narwhals and scikit-lego came together to achieve dataframe-agnosticism</p> </li> </ul>"},{"location":"security/","title":"Security","text":"<p>Given that Narwhals can only work if people trust it, we recognise the importance of following good security practices. Here are some practices we follow:</p> <ul> <li>We publish to PyPI via trusted publishing and are PEP740-compliant.</li> <li>We don't use <code>pull_request_target</code> in any CI job.</li> <li>The release CI job can only be triggered for tag pushes, and only   Narwhals members with release permissions (see below) can push tags.</li> <li>All members of <code>narwhals-dev</code> are required to have two-factor authentication   enabled.</li> <li>There are no binary or opaque files in the Narwhals repository.</li> <li> <p>Release permissions are only given to people who satisfy all of the following:</p> <ul> <li>Have met the original author in real life on multiple days.</li> <li>Have made significant contributions to Narwhals.</li> <li>Give off good vibes. This is hard to rigorously define, but it's there so we     can refuse anyone who, despite satisfying the above two criteria, we don't     feel like we can trust.</li> <li>There are fewer than 5 active people with release permissions. That is     to say, even if someone satisfies all of the above, if there are already 5     people with release permissions, then we will not be adding any more (though     you may still be added to <code>narwhals-dev</code> and get permission to merge pull     requests which you believe are ready). Note that we already meet that limit.</li> </ul> </li> </ul>"},{"location":"this/","title":"The Zen of Narwhals","text":"<p>The well famous Python easter egg <code>import this</code> will reveal The Zen of Python (PEP 20).</p> <p>Narwhals took inspiration from this and created its own Zen.</p> <pre><code>import narwhals.this\n</code></pre> <pre><code>\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff THE ZEN OF NARWHALS\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2820\u28b9\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Keep it simple\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u2844\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Move slowly and keep things working\n\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u287c\u2858\u281b\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff A good API is an honest one\n\u28ff\u28ff\u28ff\u287f\u28eb\u2844\u283e\u28e3\u2839\u28ff\u28ff\u28ff\u28f6\u28ee\u28d9\u283b\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Yes, that needs documenting\n\u28ff\u28ff\u288b\u28f4\u28ff\u28f7\u28ec\u28ed\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff People learn better from examples\n\u28ff\u2883\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u284c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff   than from explanations\u2800\n\u284f\u2800\u28b0\u2804\u28bb\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2889\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u285c\u28ff\u28ff\u287f\u2881\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff If in doubt, better to say 'no'\n\u2847\u28cc\u28c0\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28c7\u2836\u2809\u2881\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2879\u28ff\u2847\u28ff\u28e7\u283b\u283f\u283f\u283f\u283f   than to risk causing a commotion\u2800\n\u2867\u28b9\u28ff\u28ff\u28ff\u28dc\u28df\u28f8\u28ff\u28ff\u28f7\u28f6\u28ff\u287f\u28ff\u28ff\u28dd\u28bf\u28ff\u28ff\u28f7\u28ec\u28e5\u28ff\u28ff\u28ff\u28ff\u28ff\u285f\u28f0 Yes, we need a test for that\n\u28a1\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2859\u28ff\u28ff\u2847\u28ff\u28ff\u28ff\u28ff\u281f\u28cb\u28ed\u28db\u283b\u28cb\u28f4\u28ff If you want users  \n\u28f6\u28e4\u28e4\u28d9\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28e6\u28cd\u28e1\u28ff\u287f\u288b\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff   you need good docs\u2800\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f6\u28ec\u28d9\u28db\u283b\u283f\u283f\u283f\u283f\u283f\u281f\u28db\u28e9\u28e5\u28f6\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff Our code is not irreplaceable\n</code></pre>"},{"location":"why/","title":"Why?","text":"<p>You may think that pandas, Polars, and all dataframe libraries are quite similar. But are they really?</p> <p>For example, do the following produce the same output?</p> <pre><code>import pandas as pd\nimport polars as pl\n\nprint(3 in pd.Series([1, 2, 3]))\nprint(3 in pl.Series([1, 2, 3]))\n</code></pre> <p>Try it out and see \ud83d\ude09</p> <p>Spoiler alert: they don't. pandas checks if <code>3</code> is in the index, Polars checks if it's in the values.</p> <p>For another example, try running the code below - note how the outputs have different column names after the join!</p> <pre><code>pd_df_left = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\npd_df_right = pd.DataFrame({\"a\": [1, 2, 3], \"c\": [4, 5, 6]})\npd_left_merge = pd_df_left.merge(pd_df_right, left_on=\"b\", right_on=\"c\", how=\"left\")\n\npl_df_left = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\npl_df_right = pl.DataFrame({\"a\": [1, 2, 3], \"c\": [4, 5, 6]})\npl_left_merge = pl_df_left.join(pl_df_right, left_on=\"b\", right_on=\"c\", how=\"left\")\n\nprint(pd_left_merge.columns)\nprint(pl_left_merge.columns)\n</code></pre> <p>There are several such subtle difference between the libraries. Writing dataframe-agnostic code is hard!</p> <p>But by having a unified, simple, and predictable API, you can focus on behaviour rather than on subtle implementation differences.</p> <p>Furthermore, both pandas and Polars frequently deprecate behaviour. Narwhals handles this for you by testing against nightly builds of both libraries and handling backwards compatibility internally (so you don't have to!).</p>"},{"location":"api-reference/","title":"API Reference","text":"<ul> <li>Top-level functions</li> <li>narwhals.DataFrame</li> <li>narwhals.Expr</li> <li>narwhals.Expr.cat</li> <li>narwhals.Expr.dt</li> <li>narwhals.Expr.list</li> <li>narwhals.Expr.name</li> <li>narwhals.Expr.str</li> <li>narwhals.Expr.struct</li> <li>narwhals.GroupBy</li> <li>narwhals.LazyGroupBy</li> <li>narwhals.LazyFrame</li> <li>narwhals.Schema</li> <li>narwhals.Series</li> <li>narwhals.Series.cat</li> <li>narwhals.Series.dt</li> <li>narwhals.Series.list</li> <li>narwhals.Series.str</li> <li>narwhals.Series.struct</li> <li>narwhals.dependencies</li> <li>narwhals.Implementation</li> <li>narwhals.dtypes</li> <li>narwhals.exceptions</li> <li>narwhals.selectors</li> <li>narwhals.typing</li> </ul>"},{"location":"api-reference/dataframe/","title":"<code>narwhals.DataFrame</code>","text":"<p>Narwhals DataFrame, backed by a native eager dataframe.</p> Warning <p>This class is not meant to be instantiated directly - instead:</p> <ul> <li> <p>If the native object is a eager dataframe from one of the supported     backend (e.g. pandas.DataFrame, polars.DataFrame, pyarrow.Table),     you can use <code>narwhals.from_native</code>:     <pre><code>narwhals.from_native(native_dataframe)\nnarwhals.from_native(native_dataframe, eager_only=True)\n</code></pre></p> </li> <li> <p>If the object is a dictionary of column names and generic sequences mapping     (e.g. <code>dict[str, list]</code>), you can create a DataFrame via     <code>narwhals.from_dict</code>:     <pre><code>narwhals.from_dict(\n    data={\"a\": [1, 2, 3]},\n    backend=narwhals.get_native_namespace(another_object),\n)\n</code></pre></p> </li> </ul>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Get column names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The column names stored in a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.implementation","title":"implementation  <code>property</code>","text":"<pre><code>implementation: Implementation\n</code></pre> <p>Return implementation of native frame.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation\n&lt;Implementation.PANDAS: 'pandas'&gt;\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n&gt;&gt;&gt; df.implementation.is_polars()\nFalse\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A Narwhals Schema object that displays the mapping of column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).schema\nSchema({'foo': Int64, 'bar': Float64})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre> <p>Get the shape of the DataFrame.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The shape of the dataframe as a tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.shape\n(2, 1)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(\n    requested_schema: object | None = None,\n) -&gt; object\n</code></pre> <p>Export a DataFrame via the Arrow PyCapsule Interface.</p> <ul> <li>if the underlying dataframe implements the interface, it'll return that</li> <li>else, it'll call <code>to_arrow</code> and then defer to PyArrow's implementation</li> </ul> <p>See PyCapsule Interface for more.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    item: tuple[SingleIndexSelector, SingleColSelector],\n) -&gt; Any\n</code></pre><pre><code>__getitem__(\n    item: (\n        str | tuple[MultiIndexSelector, SingleColSelector]\n    ),\n) -&gt; Series[Any]\n</code></pre><pre><code>__getitem__(\n    item: (\n        SingleIndexSelector\n        | MultiIndexSelector\n        | MultiColSelector\n        | tuple[SingleIndexSelector, MultiColSelector]\n        | tuple[MultiIndexSelector, MultiColSelector]\n    ),\n) -&gt; Self\n</code></pre> <pre><code>__getitem__(\n    item: (\n        SingleIndexSelector\n        | SingleColSelector\n        | MultiColSelector\n        | MultiIndexSelector\n        | tuple[SingleIndexSelector, SingleColSelector]\n        | tuple[SingleIndexSelector, MultiColSelector]\n        | tuple[MultiIndexSelector, SingleColSelector]\n        | tuple[MultiIndexSelector, MultiColSelector]\n    ),\n) -&gt; Series[Any] | Self | Any\n</code></pre> <p>Extract column or slice of DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>SingleIndexSelector | SingleColSelector | MultiColSelector | MultiIndexSelector | tuple[SingleIndexSelector, SingleColSelector] | tuple[SingleIndexSelector, MultiColSelector] | tuple[MultiIndexSelector, SingleColSelector] | tuple[MultiIndexSelector, MultiColSelector]</code> <p>How to slice dataframe. What happens depends on what is passed. It's easiest to explain by example. Suppose we have a Dataframe <code>df</code></p> <ul> <li><code>df['a']</code> extracts column <code>'a'</code> and returns a <code>Series</code>.</li> <li><code>df[0:2]</code> extracts the first two rows and returns a <code>DataFrame</code>.</li> <li><code>df[0:2, 'a']</code> extracts the first two rows from column <code>'a'</code> and returns     a <code>Series</code>.</li> <li><code>df[0:2, 0]</code> extracts the first two rows from the first column and returns     a <code>Series</code>.</li> <li><code>df[[0, 1], [0, 1, 2]]</code> extracts the first two rows and the first three columns     and returns a <code>DataFrame</code></li> <li><code>df[:, [0, 1, 2]]</code> extracts all rows from the first three columns and returns a   <code>DataFrame</code>.</li> <li><code>df[:, ['a', 'c']]</code> extracts all rows and columns <code>'a'</code> and <code>'c'</code> and returns a   <code>DataFrame</code>.</li> <li><code>df[['a', 'c']]</code> extracts all rows and columns <code>'a'</code> and <code>'c'</code> and returns a   <code>DataFrame</code>.</li> <li><code>df[0: 2, ['a', 'c']]</code> extracts the first two rows and columns <code>'a'</code> and <code>'c'</code> and     returns a <code>DataFrame</code></li> <li><code>df[:, 0: 2]</code> extracts all rows from the first two columns and returns a <code>DataFrame</code></li> <li><code>df[:, 'a': 'c']</code> extracts all rows and all columns positioned between <code>'a'</code> and <code>'c'</code> inclusive and returns a <code>DataFrame</code>. For example, if the columns are     <code>'a', 'd', 'c', 'b'</code>, then that would extract columns <code>'a'</code>, <code>'d'</code>, and <code>'c'</code>.</li> </ul> required <p>Returns:</p> Type Description <code>Series[Any] | Self | Any</code> <p>A Narwhals Series, backed by a native series.</p> Notes <ul> <li>Integers are always interpreted as positions</li> <li>Strings are always interpreted as column names.</li> </ul> <p>In contrast with Polars, pandas allows non-string column names. If you don't know whether the column name you're trying to extract is definitely a string (e.g. <code>df[df.columns[0]]</code>) then you should use <code>DataFrame.get_column</code> instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df[\"a\"].to_native()\n0    1\n1    2\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.clone","title":"clone","text":"<pre><code>clone() -&gt; Self\n</code></pre> <p>Create a copy of this DataFrame.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An identical copy of the original dataframe.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.collect_schema","title":"collect_schema","text":"<pre><code>collect_schema() -&gt; Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A Narwhals Schema object that displays the mapping of column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).collect_schema()\nSchema({'foo': Int64, 'bar': Float64})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop","title":"drop","text":"<pre><code>drop(\n    *columns: str | Iterable[str], strict: bool = True\n) -&gt; Self\n</code></pre> <p>Remove columns from the dataframe.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The dataframe with the specified columns removed.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>Validate that all column names exist in the schema and throw an exception if a column name does not exist in the schema.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2], \"bar\": [6.0, 7.0], \"ham\": [\"a\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).drop(\"ham\").to_native()\n   foo  bar\n0    1  6.0\n1    2  7.0\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls(subset: str | list[str] | None = None) -&gt; Self\n</code></pre> <p>Drop rows that contain null values.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) for which null values are considered. If set to None (default), use all columns.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The original object with the rows removed that contained the null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1.0, None], \"ba\": [1.0, 2.0]})\n&gt;&gt;&gt; nw.from_native(df_native).drop_nulls().to_native()\npyarrow.Table\na: double\nba: double\n----\na: [[1]]\nba: [[1]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.estimated_size","title":"estimated_size","text":"<pre><code>estimated_size(unit: SizeUnit = 'b') -&gt; int | float\n</code></pre> <p>Return an estimation of the total (heap) allocated size of the <code>DataFrame</code>.</p> <p>Estimated size is given in the specified unit (bytes by default).</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>SizeUnit</code> <p>'b', 'kb', 'mb', 'gb', 'tb', 'bytes', 'kilobytes', 'megabytes', 'gigabytes', or 'terabytes'.</p> <code>'b'</code> <p>Returns:</p> Type Description <code>int | float</code> <p>Integer or Float.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.estimated_size()\n32\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.explode","title":"explode","text":"<pre><code>explode(\n    columns: str | Sequence[str], *more_columns: str\n) -&gt; Self\n</code></pre> <p>Explode the dataframe to long format by exploding the given columns.</p> Notes <p>It is possible to explode multiple columns only if these columns must have matching element counts.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str | Sequence[str]</code> <p>Column names. The underlying columns being exploded must be of the <code>List</code> data type.</p> required <code>*more_columns</code> <code>str</code> <p>Additional names of columns to explode, specified as positional arguments.</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>New DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\"], \"b\": [[1, 2], [3]]}\n&gt;&gt;&gt; df_native = pl.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).explode(\"b\").to_native()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2506 1   \u2502\n\u2502 x   \u2506 2   \u2502\n\u2502 y   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.filter","title":"filter","text":"<pre><code>filter(\n    *predicates: IntoExpr | Iterable[IntoExpr] | list[bool],\n    **constraints: Any\n) -&gt; Self\n</code></pre> <p>Filter the rows in the DataFrame based on one or more predicate expressions.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr] | list[bool]</code> <p>Expression(s) that evaluates to a boolean Series. Can also be a (single!) boolean list.</p> <code>()</code> <code>**constraints</code> <code>Any</code> <p>Column filters; use <code>name = value</code> to filter columns by the supplied value. Each constraint will behave the same as <code>nw.col(name).eq(value)</code>, and will be implicitly joined with the other filter conditions using &amp;.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The filtered dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6, 7, 8], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n</code></pre> <p>Filter on one condition</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(nw.col(\"foo\") &gt; 1).to_native()\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n</code></pre> <p>Filter on multiple conditions with implicit <code>&amp;</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     nw.col(\"foo\") &lt; 3, nw.col(\"ham\") == \"a\"\n... ).to_native()\n   foo  bar ham\n0    1    6   a\n</code></pre> <p>Filter on multiple conditions with <code>|</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     (nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\")\n... ).to_native()\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n</code></pre> <p>Filter using <code>**kwargs</code> syntax</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(foo=2, ham=\"b\").to_native()\n   foo  bar ham\n1    2    7   b\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth row in the DataFrame and return as a new DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>The dataframe containing only the selected rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None, 2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).gather_every(2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  foo: int64      |\n|  ----            |\n|  foo: [[1,2]]    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.get_column","title":"get_column","text":"<pre><code>get_column(name: str) -&gt; Series[Any]\n</code></pre> <p>Get a single column by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The column name as a string.</p> required <p>Returns:</p> Type Description <code>Series[Any]</code> <p>A Narwhals Series, backed by a native series.</p> Notes <p>Although <code>name</code> is typed as <code>str</code>, pandas does allow non-string column names, and they will work when passed to this function if the <code>narwhals.DataFrame</code> is backed by a pandas dataframe with non-string columns. This function can only be used to extract a column by name, so there is no risk of ambiguity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.get_column(\"a\").to_native()\n0    1\n1    2\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: Literal[False] = ...\n) -&gt; GroupBy[Self]\n</code></pre><pre><code>group_by(\n    *keys: str | Iterable[str],\n    drop_null_keys: Literal[True]\n) -&gt; GroupBy[Self]\n</code></pre> <pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: bool = False\n) -&gt; GroupBy[Self]\n</code></pre> <p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>drop_null_keys</code> <code>bool</code> <p>if True, then groups where any key is null won't be included in the result.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>GroupBy</code> <code>GroupBy[Self]</code> <p>Object which can be used to perform aggregations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n</code></pre> <p>Group by one column and compute the sum of another column</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native, eager_only=True).group_by(\"a\").agg(\n...     nw.col(\"b\").sum()\n... ).sort(\"a\").to_native()\n   a  b\n0  a  2\n1  b  5\n2  c  3\n</code></pre> <p>Group by multiple columns and compute the max of another column</p> <pre><code>&gt;&gt;&gt; (\n...     nw.from_native(df_native, eager_only=True)\n...     .group_by([\"a\", \"b\"])\n...     .agg(nw.max(\"c\"))\n...     .sort(\"a\", \"b\")\n...     .to_native()\n... )\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n</code></pre> <p>Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native, eager_only=True).group_by(\n...     \"a\", nw.col(\"b\") // 2\n... ).agg(nw.col(\"c\").mean()).to_native()\n   a  b    c\n0  a  0  4.0\n1  b  1  3.0\n2  c  1  1.0\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; Self\n</code></pre> <p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the last <code>abs(n)</code>.</p> <code>5</code> <p>Returns:</p> Type Description <code>Self</code> <p>A subset of the dataframe of shape (n, n_columns).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; nw.from_native(df_native).head(1).to_native()\n   a    b\n0  1  0.5\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Series[Any]\n</code></pre> <p>Get a mask of all duplicated rows in this DataFrame.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>A new Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_duplicated()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n|  0     True   |\n|  1     True   |\n|  2    False   |\n|  dtype: bool  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the dataframe is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the dataframe is empty (True) or not (False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_empty()\nFalse\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Series[Any]\n</code></pre> <p>Get a mask of all unique rows in this DataFrame.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>A new Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [2, 2, 2], \"bar\": [6.0, 6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).is_unique()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals Series|\n|---------------|\n|  0    False   |\n|  1    False   |\n|  2     True   |\n|  dtype: bool  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.item","title":"item","text":"<pre><code>item(\n    row: int | None = None, column: int | str | None = None\n) -&gt; Any\n</code></pre> <p>Return the DataFrame as a scalar, or return the element at the given row/column.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>int | None</code> <p>The n-th row.</p> <code>None</code> <code>column</code> <code>int | str | None</code> <p>The column selected via an integer or a string (column name).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A scalar or the specified element in the dataframe.</p> Notes <p>If row/col not provided, this is equivalent to df[0,0], with a check that the shape is (1,1). With row/col, this is equivalent to df[row,col].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).item(0, 1)\n2\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_columns","title":"iter_columns","text":"<pre><code>iter_columns() -&gt; Iterator[Series[Any]]\n</code></pre> <p>Returns an iterator over the columns of this DataFrame.</p> <p>Yields:</p> Type Description <code>Series[Any]</code> <p>A Narwhals Series, backed by a native series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; iter_columns = nw.from_native(df_native).iter_columns()\n&gt;&gt;&gt; next(iter_columns)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    1                 |\n|1    2                 |\n|Name: foo, dtype: int64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; next(iter_columns)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals Series     |\n|-------------------------|\n|0    6.0                 |\n|1    7.0                 |\n|Name: bar, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_rows","title":"iter_rows","text":"<pre><code>iter_rows(\n    *, named: Literal[False], buffer_size: int = ...\n) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>iter_rows(\n    *, named: Literal[True], buffer_size: int = ...\n) -&gt; Iterator[dict[str, Any]]\n</code></pre><pre><code>iter_rows(\n    *, named: bool, buffer_size: int = ...\n) -&gt; Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]\n</code></pre> <pre><code>iter_rows(\n    *, named: bool = False, buffer_size: int = 512\n) -&gt; Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]\n</code></pre> <p>Returns an iterator over the DataFrame of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <code>buffer_size</code> <code>int</code> <p>Determines the number of rows that are buffered internally while iterating over the data. See https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.iter_rows.html</p> <code>512</code> <p>Returns:</p> Type Description <code>Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]</code> <p>An iterator over the DataFrame of rows.</p> Notes <p>cuDF doesn't support this method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; iter_rows = nw.from_native(df_native).iter_rows()\n&gt;&gt;&gt; next(iter_rows)\n(1, 6.0)\n&gt;&gt;&gt; next(iter_rows)\n(2, 7.0)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join","title":"join","text":"<pre><code>join(\n    other: Self,\n    on: str | list[str] | None = None,\n    how: JoinStrategy = \"inner\",\n    *,\n    left_on: str | list[str] | None = None,\n    right_on: str | list[str] | None = None,\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Join in SQL-like fashion.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>on</code> <code>str | list[str] | None</code> <p>Name(s) of the join columns in both DataFrames. If set, <code>left_on</code> and <code>right_on</code> should be None.</p> <code>None</code> <code>how</code> <code>JoinStrategy</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>left: Returns all rows from the left table, and the matched rows from the right table.</li> <li>full: Returns all rows in both dataframes, with the suffix appended to the right join keys.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Join column of the left DataFrame.</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Join column of the right DataFrame.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_1_native = pd.DataFrame({\"id\": [\"a\", \"b\"], \"price\": [6.0, 7.0]})\n&gt;&gt;&gt; df_2_native = pd.DataFrame({\"id\": [\"a\", \"b\", \"c\"], \"qty\": [1, 2, 3]})\n&gt;&gt;&gt; nw.from_native(df_1_native).join(nw.from_native(df_2_native), on=\"id\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   id  price  qty |\n| 0  a    6.0    1 |\n| 1  b    7.0    2 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join_asof","title":"join_asof","text":"<pre><code>join_asof(\n    other: Self,\n    *,\n    left_on: str | None = None,\n    right_on: str | None = None,\n    on: str | None = None,\n    by_left: str | list[str] | None = None,\n    by_right: str | list[str] | None = None,\n    by: str | list[str] | None = None,\n    strategy: AsofJoinStrategy = \"backward\",\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Perform an asof join.</p> <p>This is similar to a left-join except that we match on nearest key rather than equal keys.</p> <p>For Polars, both DataFrames must be sorted by the <code>on</code> key (within each <code>by</code> group if specified).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>left_on</code> <code>str | None</code> <p>Name(s) of the left join column(s).</p> <code>None</code> <code>right_on</code> <code>str | None</code> <p>Name(s) of the right join column(s).</p> <code>None</code> <code>on</code> <code>str | None</code> <p>Join column of both DataFrames. If set, left_on and right_on should be None.</p> <code>None</code> <code>by_left</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>by_right</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>by</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join.</p> <code>None</code> <code>strategy</code> <code>AsofJoinStrategy</code> <p>Join strategy. The default is \"backward\".</p> <code>'backward'</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <ul> <li>backward: selects the last row in the right DataFrame whose \"on\" key is less than or equal to the left's key.</li> <li>forward: selects the first row in the right DataFrame whose \"on\" key is greater than or equal to the left's key.</li> <li>nearest: search selects the last row in the right DataFrame whose value is nearest to the left's key.</li> </ul> <code>'_right'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_gdp = {\n...     \"datetime\": [\n...         datetime(2016, 1, 1),\n...         datetime(2017, 1, 1),\n...         datetime(2018, 1, 1),\n...         datetime(2019, 1, 1),\n...         datetime(2020, 1, 1),\n...     ],\n...     \"gdp\": [4164, 4411, 4566, 4696, 4827],\n... }\n&gt;&gt;&gt; data_population = {\n...     \"datetime\": [\n...         datetime(2016, 3, 1),\n...         datetime(2018, 8, 1),\n...         datetime(2019, 1, 1),\n...     ],\n...     \"population\": [82.19, 82.66, 83.12],\n... }\n&gt;&gt;&gt; gdp_native = pd.DataFrame(data_gdp)\n&gt;&gt;&gt; population_native = pd.DataFrame(data_population)\n&gt;&gt;&gt; gdp = nw.from_native(gdp_native)\n&gt;&gt;&gt; population = nw.from_native(population_native)\n&gt;&gt;&gt; population.join_asof(gdp, on=\"datetime\", strategy=\"backward\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|      Narwhals DataFrame      |\n|------------------------------|\n|    datetime  population   gdp|\n|0 2016-03-01       82.19  4164|\n|1 2018-08-01       82.66  4566|\n|2 2019-01-01       83.12  4696|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.lazy","title":"lazy","text":"<pre><code>lazy(\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Restrict available API methods to lazy-only ones.</p> <p>If <code>backend</code> is specified, then a conversion between different backends might be triggered.</p> <p>If a library does not support lazy execution and <code>backend</code> is not specified, then this is will only restrict the API to lazy-only operations. This is useful if you want to ensure that you write dataframe-agnostic code which all has the possibility of running entirely lazily.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>Which lazy backend collect to. This will be the underlying backend for the resulting Narwhals LazyFrame. If not specified, and the given library does not support lazy execution, then this will restrict the API to lazy-only operations.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>DASK</code>, <code>DUCKDB</code>     or <code>POLARS</code>.</li> <li>As a string: <code>\"dask\"</code>, <code>\"duckdb\"</code> or <code>\"polars\"</code></li> <li>Directly as a module <code>dask.dataframe</code>, <code>duckdb</code> or <code>polars</code>.</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>LazyFrame[Any]</code> <p>A new LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>If we call <code>df.lazy</code>, we get a <code>narwhals.LazyFrame</code> backed by a Polars LazyFrame.</p> <pre><code>&gt;&gt;&gt; df.lazy()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals LazyFrame      |\n|-----------------------------|\n|&lt;LazyFrame at 0x7F52B9937230&gt;|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>We can also pass DuckDB as the backend, and then we'll get a <code>narwhals.LazyFrame</code> backed by a <code>duckdb.DuckDBPyRelation</code>.</p> <pre><code>&gt;&gt;&gt; df.lazy(backend=nw.Implementation.DUCKDB)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int64 \u2502 int64 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     1 \u2502     4 \u2502 |\n|\u2502     2 \u2502     6 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; Self\n</code></pre> <p>Create a new DataFrame that shows the null counts per column.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A dataframe of shape (1, n_columns).</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).null_count()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  foo: int64      |\n|  bar: int64      |\n|  ----            |\n|  foo: [[1]]      |\n|  bar: [[0]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>R</code> <p>The original object with the function applied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"ba\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).pipe(\n...     lambda _df: _df.select(\n...         [x for x in _df.columns if len(x) == 1]\n...     ).to_native()\n... )\n   a\n0  1\n1  2\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pivot","title":"pivot","text":"<pre><code>pivot(\n    on: str | list[str],\n    *,\n    index: str | list[str] | None = None,\n    values: str | list[str] | None = None,\n    aggregate_function: PivotAgg | None = None,\n    maintain_order: bool | None = None,\n    sort_columns: bool = False,\n    separator: str = \"_\"\n) -&gt; Self\n</code></pre> <p>Create a spreadsheet-style pivot table as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str]</code> <p>Name of the column(s) whose values will be used as the header of the output DataFrame.</p> required <code>index</code> <code>str | list[str] | None</code> <p>One or multiple keys to group by. If None, all remaining columns not specified on <code>on</code> and <code>values</code> will be used. At least one of <code>index</code> and <code>values</code> must be specified.</p> <code>None</code> <code>values</code> <code>str | list[str] | None</code> <p>One or multiple keys to group by. If None, all remaining columns not specified on <code>on</code> and <code>index</code> will be used. At least one of <code>index</code> and <code>values</code> must be specified.</p> <code>None</code> <code>aggregate_function</code> <code>PivotAgg | None</code> <p>Choose from</p> <ul> <li>None: no aggregation takes place, will raise error if multiple values     are in group.</li> <li>A predefined aggregate function string, one of     {'min', 'max', 'first', 'last', 'sum', 'mean', 'median', 'len'}</li> </ul> <code>None</code> <code>maintain_order</code> <code>bool | None</code> <p>Has no effect and is kept around only for backwards-compatibility.</p> <code>None</code> <code>sort_columns</code> <code>bool</code> <p>Sort the transposed columns by name. Default is by order of discovery.</p> <code>False</code> <code>separator</code> <code>str</code> <p>Used as separator/delimiter in generated column names in case of multiple <code>values</code> columns.</p> <code>'_'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"ix\": [1, 1, 2, 2, 1, 2],\n...     \"col\": [\"a\", \"a\", \"a\", \"a\", \"b\", \"b\"],\n...     \"foo\": [0, 1, 2, 2, 7, 1],\n...     \"bar\": [0, 2, 0, 0, 9, 4],\n... }\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).pivot(\n...     \"col\", index=\"ix\", aggregate_function=\"sum\"\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals DataFrame        |\n|---------------------------------|\n|   ix  foo_a  foo_b  bar_a  bar_b|\n|0   1      1      7      2      9|\n|1   2      4      1      0      4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rename","title":"rename","text":"<pre><code>rename(mapping: dict[str, str]) -&gt; Self\n</code></pre> <p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The dataframe with the specified columns renamed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6, 7]})\n&gt;&gt;&gt; nw.from_native(df_native).rename({\"foo\": \"apple\"}).to_native()\npyarrow.Table\napple: int64\nbar: int64\n----\napple: [[1,2]]\nbar: [[6,7]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.row","title":"row","text":"<pre><code>row(index: int) -&gt; tuple[Any, ...]\n</code></pre> <p>Get values at given row.</p> Warning <p>You should NEVER use this method to iterate over a DataFrame; if you require row-iteration you should strongly prefer use of iter_rows() instead.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Row number.</p> required <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>A tuple of the values in the selected row.</p> Notes <p>cuDF doesn't support this method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).row(1)\n(&lt;pyarrow.Int64Scalar: 2&gt;, &lt;pyarrow.Int64Scalar: 5&gt;)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rows","title":"rows","text":"<pre><code>rows(\n    *, named: Literal[False] = False\n) -&gt; list[tuple[Any, ...]]\n</code></pre><pre><code>rows(*, named: Literal[True]) -&gt; list[dict[str, Any]]\n</code></pre><pre><code>rows(\n    *, named: bool\n) -&gt; list[tuple[Any, ...]] | list[dict[str, Any]]\n</code></pre> <pre><code>rows(\n    *, named: bool = False\n) -&gt; list[tuple[Any, ...]] | list[dict[str, Any]]\n</code></pre> <p>Returns all data in the DataFrame as a list of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[Any, ...]] | list[dict[str, Any]]</code> <p>The data as a list of rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; nw.from_native(df_native).rows()\n[(1, 6.0), (2, 7.0)]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sample","title":"sample","text":"<pre><code>sample(\n    n: int | None = None,\n    *,\n    fraction: float | None = None,\n    with_replacement: bool = False,\n    seed: int | None = None\n) -&gt; Self\n</code></pre> <p>Sample from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If set to None (default), a random seed is generated for each sample operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new dataframe.</p> Notes <p>The results may not be consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [19, 32, 4]})\n&gt;&gt;&gt; nw.from_native(df_native).sample(n=2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      foo  bar    |\n|   2    3    4    |\n|   1    2   32    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.select","title":"select","text":"<pre><code>select(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Select columns from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The dataframe containing only the selected columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [3, 4]})\n&gt;&gt;&gt; nw.from_native(df_native).select(\"a\", a_plus_1=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|a_plus_1: int64   |\n|----              |\n|a: [[1,2]]        |\n|a_plus_1: [[2,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sort","title":"sort","text":"<pre><code>sort(\n    by: str | Iterable[str],\n    *more_by: str,\n    descending: bool | Sequence[bool] = False,\n    nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort the dataframe by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple columns, can be specified per column by passing a sequence of booleans.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The sorted dataframe.</p> Note <p>Unlike Polars, it is not possible to specify a sequence of booleans for <code>nulls_last</code> in order to control per-column behaviour. Instead a single boolean is applied for all <code>by</code> columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [2, 1], \"bar\": [6.0, 7.0], \"ham\": [\"a\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).sort(\"foo\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    foo  bar ham  |\n| 1    1  7.0   b  |\n| 0    2  6.0   a  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the first <code>abs(n)</code>.</p> <code>5</code> <p>Returns:</p> Type Description <code>Self</code> <p>A subset of the dataframe of shape (n, n_columns).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; nw.from_native(df_native).tail(1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a    b     |\n|    1  2  4.0     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Table\n</code></pre> <p>Convert to arrow table.</p> <p>Returns:</p> Type Description <code>Table</code> <p>A new PyArrow table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, None], \"bar\": [2, 3]})\n&gt;&gt;&gt; nw.from_native(df_native).to_arrow()\npyarrow.Table\nfoo: double\nbar: int64\n----\nfoo: [[1,null]]\nbar: [[2,3]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_dict","title":"to_dict","text":"<pre><code>to_dict(\n    *, as_series: Literal[True] = ...\n) -&gt; dict[str, Series[Any]]\n</code></pre><pre><code>to_dict(\n    *, as_series: Literal[False]\n) -&gt; dict[str, list[Any]]\n</code></pre><pre><code>to_dict(\n    *, as_series: bool\n) -&gt; dict[str, Series[Any]] | dict[str, list[Any]]\n</code></pre> <pre><code>to_dict(\n    *, as_series: bool = True\n) -&gt; dict[str, Series[Any]] | dict[str, list[Any]]\n</code></pre> <p>Convert DataFrame to a dictionary mapping column name to values.</p> <p>Parameters:</p> Name Type Description Default <code>as_series</code> <code>bool</code> <p>If set to true <code>True</code>, then the values are Narwhals Series,     otherwise the values are Any.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Series[Any]] | dict[str, list[Any]]</code> <p>A mapping from column name to values / Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"A\": [1, 2], \"fruits\": [\"banana\", \"apple\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_dict(as_series=False)\n{'A': [1, 2], 'fruits': ['banana', 'apple']}\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; DataFrameT\n</code></pre> <p>Convert Narwhals DataFrame to native one.</p> <p>Returns:</p> Type Description <code>DataFrameT</code> <p>Object of class that user started with.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n</code></pre> <p>Calling <code>to_native</code> on a Narwhals DataFrame returns the native object:</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).to_native()\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; _2DArray\n</code></pre> <p>Convert this DataFrame to a NumPy ndarray.</p> <p>Returns:</p> Type Description <code>_2DArray</code> <p>A NumPy ndarray array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"bar\": [6.5, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_numpy()\narray([[1. , 6.5],\n       [2. , 7. ]])\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.DataFrame\n</code></pre> <p>Convert this DataFrame to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_pandas()\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.DataFrame\n</code></pre> <p>Convert this DataFrame to a polars DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A polars DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.to_polars()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unique","title":"unique","text":"<pre><code>unique(\n    subset: str | list[str] | None = None,\n    *,\n    keep: UniqueKeepStrategy = \"any\",\n    maintain_order: bool = False\n) -&gt; Self\n</code></pre> <p>Drop duplicate rows from this dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.</p> <code>None</code> <code>keep</code> <code>UniqueKeepStrategy</code> <p>{'first', 'last', 'any', 'none'} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.         This allows more optimizations.</li> <li>'none': Don't keep duplicate rows.</li> <li>'first': Keep first unique row.</li> <li>'last': Keep last unique row.</li> </ul> <code>'any'</code> <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original DataFrame. This may be more expensive to compute.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The dataframe with the duplicate rows removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2], \"bar\": [\"a\", \"a\"], \"ham\": [\"b\", \"b\"]}\n... )\n&gt;&gt;&gt; nw.from_native(df_native).unique([\"bar\", \"ham\"]).to_native()\n   foo bar ham\n0    1   a   b\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unpivot","title":"unpivot","text":"<pre><code>unpivot(\n    on: str | list[str] | None = None,\n    *,\n    index: str | list[str] | None = None,\n    variable_name: str = \"variable\",\n    value_name: str = \"value\"\n) -&gt; Self\n</code></pre> <p>Unpivot a DataFrame from wide to long format.</p> <p>Optionally leaves identifiers set.</p> <p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (index) while all other columns, considered measured variables (on), are \"unpivoted\" to the row axis leaving just two non-identifier columns, 'variable' and 'value'.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str] | None</code> <p>Column(s) to use as values variables; if <code>on</code> is empty all columns that are not in <code>index</code> will be used.</p> <code>None</code> <code>index</code> <code>str | list[str] | None</code> <p>Column(s) to use as identifier variables.</p> <code>None</code> <code>variable_name</code> <code>str</code> <p>Name to give to the <code>variable</code> column. Defaults to \"variable\".</p> <code>'variable'</code> <code>value_name</code> <code>str</code> <p>Name to give to the <code>value</code> column. Defaults to \"value\".</p> <code>'value'</code> <p>Returns:</p> Type Description <code>Self</code> <p>The unpivoted dataframe.</p> Notes <p>If you're coming from pandas, this is similar to <code>pandas.DataFrame.melt</code>, but with <code>index</code> replacing <code>id_vars</code> and <code>on</code> replacing <code>value_vars</code>. In other frameworks, you might know this operation as <code>pivot_longer</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 3, 5], \"c\": [2, 4, 6]}\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).unpivot([\"b\", \"c\"], index=\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|   a variable  value|\n|0  x        b      1|\n|1  y        b      3|\n|2  z        b      5|\n|3  x        c      2|\n|4  y        c      4|\n|5  z        c      6|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_columns","title":"with_columns","text":"<pre><code>with_columns(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Add columns to this DataFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>Self</code> <p>A new DataFrame with the columns added.</p> Note <p>Creating a new DataFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [0.5, 4.0]})\n&gt;&gt;&gt; (\n...     nw.from_native(df_native)\n...     .with_columns((nw.col(\"a\") * 2).alias(\"a*2\"))\n...     .to_native()\n... )\n   a    b  a*2\n0  1  0.5    2\n1  2  4.0    4\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_row_index","title":"with_row_index","text":"<pre><code>with_row_index(name: str = 'index') -&gt; Self\n</code></pre> <p>Insert column which enumerates rows.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the column as a string. The default is \"index\".</p> <code>'index'</code> <p>Returns:</p> Type Description <code>Self</code> <p>The original object with the column added.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; nw.from_native(df_native).with_row_index().to_native()\npyarrow.Table\nindex: int64\na: int64\nb: int64\n----\nindex: [[0,1]]\na: [[1,2]]\nb: [[4,5]]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_csv","title":"write_csv","text":"<pre><code>write_csv(file: None = None) -&gt; str\n</code></pre><pre><code>write_csv(file: str | Path | BytesIO) -&gt; None\n</code></pre> <pre><code>write_csv(\n    file: str | Path | BytesIO | None = None,\n) -&gt; str | None\n</code></pre> <p>Write dataframe to comma-separated values (CSV) file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | BytesIO | None</code> <p>String, path object or file-like object to which the dataframe will be written. If None, the resulting csv format is returned as a string.</p> <code>None</code> <p>Returns:</p> Type Description <code>str | None</code> <p>String or None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.write_csv()\n'foo,bar,ham\\n1,6.0,a\\n2,7.0,b\\n3,8.0,c\\n'\n</code></pre> <p>If we had passed a file name to <code>write_csv</code>, it would have been written to that file.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_parquet","title":"write_parquet","text":"<pre><code>write_parquet(file: str | Path | BytesIO) -&gt; None\n</code></pre> <p>Write dataframe to parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | BytesIO</code> <p>String, path object or file-like object to which the dataframe will be written.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"bar\": [6.0, 7.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.write_parquet(\"out.parquet\")\n</code></pre>"},{"location":"api-reference/dependencies/","title":"<code>narwhals.dependencies</code>","text":""},{"location":"api-reference/dependencies/#narwhals.dependencies.get_cudf","title":"get_cudf","text":"<pre><code>get_cudf() -&gt; Any\n</code></pre> <p>Get cudf module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_ibis","title":"get_ibis","text":"<pre><code>get_ibis() -&gt; Any\n</code></pre> <p>Get ibis module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_modin","title":"get_modin","text":"<pre><code>get_modin() -&gt; Any\n</code></pre> <p>Get modin.pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pandas","title":"get_pandas","text":"<pre><code>get_pandas() -&gt; Any\n</code></pre> <p>Get pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_polars","title":"get_polars","text":"<pre><code>get_polars() -&gt; Any\n</code></pre> <p>Get Polars module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pyarrow","title":"get_pyarrow","text":"<pre><code>get_pyarrow() -&gt; Any\n</code></pre> <p>Get pyarrow module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_dataframe","title":"is_cudf_dataframe","text":"<pre><code>is_cudf_dataframe(df: Any) -&gt; TypeIs[cudf.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a cudf DataFrame without importing cudf.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_index","title":"is_cudf_index","text":"<pre><code>is_cudf_index(index: Any) -&gt; TypeIs[cudf.Index]\n</code></pre> <p>Check whether <code>index</code> is a cudf Index without importing cudf.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_cudf_series","title":"is_cudf_series","text":"<pre><code>is_cudf_series(ser: Any) -&gt; TypeIs[cudf.Series[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a cudf Series without importing cudf.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_dask_dataframe","title":"is_dask_dataframe","text":"<pre><code>is_dask_dataframe(df: Any) -&gt; TypeIs[dd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a Dask DataFrame without importing Dask.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_ibis_table","title":"is_ibis_table","text":"<pre><code>is_ibis_table(df: Any) -&gt; TypeIs[ibis.Table]\n</code></pre> <p>Check whether <code>df</code> is a Ibis Table without importing Ibis.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_into_dataframe","title":"is_into_dataframe","text":"<pre><code>is_into_dataframe(\n    native_dataframe: Any | IntoDataFrameT,\n) -&gt; TypeIs[IntoDataFrameT]\n</code></pre> <p>Check whether <code>native_dataframe</code> can be converted to a Narwhals DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>native_dataframe</code> <code>Any | IntoDataFrameT</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>TypeIs[IntoDataFrameT]</code> <p><code>True</code> if <code>native_dataframe</code> can be converted to a Narwhals DataFrame, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from narwhals.dependencies import is_into_dataframe\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; np_arr = np.array([[1, 4], [2, 5], [3, 6]])\n</code></pre> <pre><code>&gt;&gt;&gt; is_into_dataframe(df_pd)\nTrue\n&gt;&gt;&gt; is_into_dataframe(df_pl)\nTrue\n&gt;&gt;&gt; is_into_dataframe(np_arr)\nFalse\n</code></pre>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_into_series","title":"is_into_series","text":"<pre><code>is_into_series(\n    native_series: Any | IntoSeriesT,\n) -&gt; TypeIs[IntoSeriesT]\n</code></pre> <p>Check whether <code>native_series</code> can be converted to a Narwhals Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_series</code> <code>Any | IntoSeriesT</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>TypeIs[IntoSeriesT]</code> <p><code>True</code> if <code>native_series</code> can be converted to a Narwhals Series, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import narwhals as nw\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n&gt;&gt;&gt; np_arr = np.array([1, 2, 3])\n</code></pre> <pre><code>&gt;&gt;&gt; nw.dependencies.is_into_series(s_pd)\nTrue\n&gt;&gt;&gt; nw.dependencies.is_into_series(s_pl)\nTrue\n&gt;&gt;&gt; nw.dependencies.is_into_series(np_arr)\nFalse\n</code></pre>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_dataframe","title":"is_modin_dataframe","text":"<pre><code>is_modin_dataframe(df: Any) -&gt; TypeIs[mpd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a modin DataFrame without importing modin.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_index","title":"is_modin_index","text":"<pre><code>is_modin_index(index: Any) -&gt; TypeIs[mpd.Index]\n</code></pre> <p>Check whether <code>index</code> is a modin Index without importing modin.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_modin_series","title":"is_modin_series","text":"<pre><code>is_modin_series(ser: Any) -&gt; TypeIs[mpd.Series]\n</code></pre> <p>Check whether <code>ser</code> is a modin Series without importing modin.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_numpy_array","title":"is_numpy_array","text":"<pre><code>is_numpy_array(\n    arr: Any | _NDArray[_ShapeT],\n) -&gt; TypeIs[_NDArray[_ShapeT]]\n</code></pre> <p>Check whether <code>arr</code> is a NumPy Array without importing NumPy.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_dataframe","title":"is_pandas_dataframe","text":"<pre><code>is_pandas_dataframe(df: Any) -&gt; TypeIs[pd.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a pandas DataFrame without importing pandas.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_index","title":"is_pandas_index","text":"<pre><code>is_pandas_index(index: Any) -&gt; TypeIs[pd.Index[Any]]\n</code></pre> <p>Check whether <code>index</code> is a pandas Index without importing pandas.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_dataframe","title":"is_pandas_like_dataframe","text":"<pre><code>is_pandas_like_dataframe(df: Any) -&gt; bool\n</code></pre> <p>Check whether <code>df</code> is a pandas-like DataFrame without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_index","title":"is_pandas_like_index","text":"<pre><code>is_pandas_like_index(index: Any) -&gt; bool\n</code></pre> <p>Check whether <code>index</code> is a pandas-like Index without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_like_series","title":"is_pandas_like_series","text":"<pre><code>is_pandas_like_series(ser: Any) -&gt; bool\n</code></pre> <p>Check whether <code>ser</code> is a pandas-like Series without doing any imports.</p> <p>By \"pandas-like\", we mean: pandas, Modin, cuDF.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_series","title":"is_pandas_series","text":"<pre><code>is_pandas_series(ser: Any) -&gt; TypeIs[pd.Series[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a pandas Series without importing pandas.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_dataframe","title":"is_polars_dataframe","text":"<pre><code>is_polars_dataframe(df: Any) -&gt; TypeIs[pl.DataFrame]\n</code></pre> <p>Check whether <code>df</code> is a Polars DataFrame without importing Polars.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_lazyframe","title":"is_polars_lazyframe","text":"<pre><code>is_polars_lazyframe(df: Any) -&gt; TypeIs[pl.LazyFrame]\n</code></pre> <p>Check whether <code>df</code> is a Polars LazyFrame without importing Polars.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_polars_series","title":"is_polars_series","text":"<pre><code>is_polars_series(ser: Any) -&gt; TypeIs[pl.Series]\n</code></pre> <p>Check whether <code>ser</code> is a Polars Series without importing Polars.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pyarrow_chunked_array","title":"is_pyarrow_chunked_array","text":"<pre><code>is_pyarrow_chunked_array(\n    ser: Any,\n) -&gt; TypeIs[pa.ChunkedArray[Any]]\n</code></pre> <p>Check whether <code>ser</code> is a PyArrow ChunkedArray without importing PyArrow.</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pyarrow_table","title":"is_pyarrow_table","text":"<pre><code>is_pyarrow_table(df: Any) -&gt; TypeIs[pa.Table]\n</code></pre> <p>Check whether <code>df</code> is a PyArrow Table without importing PyArrow.</p>"},{"location":"api-reference/dtypes/","title":"<code>narwhals.dtypes</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Array","title":"Array","text":"<p>Fixed length list type.</p> <p>Parameters:</p> Name Type Description Default <code>inner</code> <code>DType | type[DType]</code> <p>The datatype of the values within each array.</p> required <code>shape</code> <code>int | tuple[int, ...]</code> <p>The shape of the arrays.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([[1, 2], [3, 4], [5, 6]], dtype=pl.Array(pl.Int32, 2))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nArray(Int32, shape=(2,))\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Decimal","title":"Decimal","text":"<p>Decimal type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = pl.Series([\"1.5\"], dtype=pl.Decimal)\n&gt;&gt;&gt; nw.from_native(s, series_only=True).dtype\nDecimal\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.List","title":"List","text":"<p>Variable length list type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [[\"narwhal\", \"orca\"], [\"beluga\", \"vaquita\"]],\n...     dtype=pd.ArrowDtype(pa.large_list(pa.large_string())),\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nList(String)\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int128","title":"Int128","text":"<p>128-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; df_native = pa.table({\"a\": [2, 1, 3, 7]})\n&gt;&gt;&gt; rel = duckdb.sql(\" SELECT CAST (a AS INT128) AS a FROM df_native \")\n</code></pre> <pre><code>&gt;&gt;&gt; s.cast(nw.Int128).dtype\nInt128\n&gt;&gt;&gt; nw.from_native(rel).schema[\"a\"]\nInt128\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int64","title":"Int64","text":"<p>64-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int64).dtype\nInt64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int32","title":"Int32","text":"<p>32-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, 1, 3, 7]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int32).dtype\nInt32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int16","title":"Int16","text":"<p>16-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int16).dtype\nInt16\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Int8","title":"Int8","text":"<p>8-bit signed integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Int8).dtype\nInt8\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.IntegerType","title":"IntegerType","text":"<p>Base class for integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt128","title":"UInt128","text":"<p>128-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [2, 1, 3, 7]})\n&gt;&gt;&gt; rel = duckdb.sql(\" SELECT CAST (a AS UINT128) AS a FROM df_native \")\n&gt;&gt;&gt; nw.from_native(rel).schema[\"a\"]\nUInt128\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt64","title":"UInt64","text":"<p>64-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt64).dtype\nUInt64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt32","title":"UInt32","text":"<p>32-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt32).dtype\nUInt32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt16","title":"UInt16","text":"<p>16-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt16).dtype\nUInt16\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt8","title":"UInt8","text":"<p>8-bit unsigned integer type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([2, 1, 3, 7])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.UInt8).dtype\nUInt8\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Field","title":"Field","text":"<p>Definition of a single field within a <code>Struct</code> DataType.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field within its parent <code>Struct</code>.</p> required <code>dtype</code> <code>type[DType] | DType</code> <p>The <code>DataType</code> of the field's values.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [{\"a\": 1, \"b\": [\"narwhal\", \"beluga\"]}, {\"a\": 2, \"b\": [\"orca\"]}]\n&gt;&gt;&gt; ser_pa = pa.chunked_array([data])\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype.fields\n[Field('a', Int64), Field('b', List(String))]\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Float64","title":"Float64","text":"<p>64-bit floating point type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[0.001, 0.1, 0.01, 0.1]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Float64).dtype\nFloat64\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Float32","title":"Float32","text":"<p>32-bit floating point type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([0.001, 0.1, 0.01, 0.1])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cast(nw.Float32).dtype\nFloat32\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.FloatType","title":"FloatType","text":"<p>Base class for float data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Boolean","title":"Boolean","text":"<p>Boolean type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[True, False, False, True]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nBoolean\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Categorical","title":"Categorical","text":"<p>A categorical encoding of a set of strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"beluga\", \"narwhal\", \"orca\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cast(nw.Categorical).dtype\nCategorical\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Enum","title":"Enum","text":"<p>A fixed categorical encoding of a unique set of strings.</p> <p>Polars has an Enum data type. In pandas, ordered categories get mapped to Enum. PyArrow has no Enum equivalent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.Enum([\"beluga\", \"narwhal\", \"orca\"])\nEnum(categories=['beluga', 'narwhal', 'orca'])\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.NestedType","title":"NestedType","text":"<p>Base class for nested data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.SignedIntegerType","title":"SignedIntegerType","text":"<p>Base class for signed integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.String","title":"String","text":"<p>UTF-8 encoded string type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"beluga\", \"narwhal\", \"orca\", \"vaquita\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nString\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct","title":"Struct","text":"<p>Struct composite type.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Sequence[Field] | Mapping[str, DType | type[DType]]</code> <p>The fields that make up the struct. Can be either a sequence of Field objects or a mapping of column names to data types.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[{\"a\": 1, \"b\": [\"narwhal\", \"beluga\"]}, {\"a\": 2, \"b\": [\"orca\"]}]]\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nStruct({'a': Int64, 'b': List(String)})\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Struct.to_schema","title":"to_schema","text":"<pre><code>to_schema() -&gt; OrderedDict[str, DType | type[DType]]\n</code></pre> <p>Return Struct dtype as a schema dict.</p> <p>Returns:</p> Type Description <code>OrderedDict[str, DType | type[DType]]</code> <p>Mapping from column name to dtype.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Date","title":"Date","text":"<p>Data type representing a calendar date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[date(2024, 12, 1) + timedelta(days=d) for d in range(4)]]\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDate\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime","title":"Datetime","text":"<p>Data type representing a calendar date and time of day.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>Unit of time. Defaults to <code>'us'</code> (microseconds).</p> <code>'us'</code> <code>time_zone</code> <code>str | timezone | None</code> <p>Time zone string, as defined in zoneinfo (to see valid strings run <code>import zoneinfo; zoneinfo.available_timezones()</code> for a full list).</p> <code>None</code> Notes <p>Adapted from Polars implementation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = (\n...     pl.Series([datetime(2024, 12, 9) + timedelta(days=n) for n in range(5)])\n...     .cast(pl.Datetime(\"ms\"))\n...     .dt.replace_time_zone(\"Africa/Accra\")\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDatetime(time_unit='ms', time_zone='Africa/Accra')\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Duration","title":"Duration","text":"<p>Data type representing a time duration.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>Unit of time. Defaults to <code>'us'</code> (microseconds).</p> <code>'us'</code> Notes <p>Adapted from Polars implementation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[timedelta(seconds=d) for d in range(1, 4)]], type=pa.duration(\"ms\")\n... )\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nDuration(time_unit='ms')\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Object","title":"Object","text":"<p>Data type for wrapping arbitrary Python objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; class Foo: ...\n&gt;&gt;&gt; s_native = pd.Series([Foo(), Foo()])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nObject\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Unknown","title":"Unknown","text":"<p>Type representing DataType values that could not be determined statically.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(pd.period_range(\"2000-01\", periods=4, freq=\"M\"))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nUnknown\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.UnsignedIntegerType","title":"UnsignedIntegerType","text":"<p>Base class for unsigned integer data types.</p>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Time","title":"Time","text":"<p>Data type representing the time of day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; from datetime import time\n&gt;&gt;&gt; data = [time(9, 0), time(9, 1, 10), time(9, 2)]\n&gt;&gt;&gt; ser_pl = pl.Series(data)\n&gt;&gt;&gt; ser_pa = pa.chunked_array([pa.array(data, type=pa.time64(\"ns\"))])\n&gt;&gt;&gt; rel = duckdb.sql(\n...     \" SELECT * FROM (VALUES (TIME '12:00:00'), (TIME '14:30:15')) df(t)\"\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(ser_pl, series_only=True).dtype\nTime\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype\nTime\n&gt;&gt;&gt; nw.from_native(rel).schema[\"t\"]\nTime\n</code></pre>"},{"location":"api-reference/dtypes/#narwhals.dtypes.Binary","title":"Binary","text":"<p>Binary type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; data = [b\"test1\", b\"test2\"]\n&gt;&gt;&gt; ser_pl = pl.Series(data, dtype=pl.Binary)\n&gt;&gt;&gt; ser_pa = pa.chunked_array([pa.array(data, type=pa.binary())])\n&gt;&gt;&gt; rel = duckdb.sql(\n...     \"SELECT * FROM (VALUES (BLOB 'test1'), (BLOB 'test2')) AS df(t)\"\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(ser_pl, series_only=True).dtype\nBinary\n&gt;&gt;&gt; nw.from_native(ser_pa, series_only=True).dtype\nBinary\n&gt;&gt;&gt; nw.from_native(rel).schema[\"t\"]\nBinary\n</code></pre>"},{"location":"api-reference/exceptions/","title":"<code>narwhals.exceptions</code>","text":""},{"location":"api-reference/exceptions/#narwhals.exceptions.ColumnNotFoundError","title":"ColumnNotFoundError","text":"<p>Exception raised when column name isn't present.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.InvalidIntoExprError","title":"InvalidIntoExprError","text":"<p>Exception raised when object can't be converted to expression.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.InvalidOperationError","title":"InvalidOperationError","text":"<p>Exception raised during invalid operations.</p>"},{"location":"api-reference/exceptions/#narwhals.exceptions.NarwhalsUnstableWarning","title":"NarwhalsUnstableWarning","text":"<p>Warning issued when a method or function is considered unstable in the stable api.</p>"},{"location":"api-reference/expr/","title":"<code>narwhals.Expr</code>","text":""},{"location":"api-reference/expr/#narwhals.Expr.abs","title":"abs","text":"<pre><code>abs() -&gt; Self\n</code></pre> <p>Return absolute value of each element.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, -2], \"b\": [-3, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\", \"b\").abs().name.suffix(\"_abs\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|   a  b  a_abs  b_abs|\n|0  1 -3      1      3|\n|1 -2  4      2      4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.alias","title":"alias","text":"<pre><code>alias(name: str) -&gt; Self\n</code></pre> <p>Rename the expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select((nw.col(\"b\") + 10).alias(\"c\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|          c       |\n|      0  14       |\n|      1  15       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.all","title":"all","text":"<pre><code>all() -&gt; Self\n</code></pre> <p>Return whether all values in the column are <code>True</code>.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").all())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|         a     b  |\n|  0  False  True  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.any","title":"any","text":"<pre><code>any() -&gt; Self\n</code></pre> <p>Return whether any of the values in the column are <code>True</code>.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").any())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a     b   |\n|  0  True  True   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.arg_max","title":"arg_max","text":"<pre><code>arg_max() -&gt; Self\n</code></pre> <p>Returns the index of the maximum value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [10, 20], \"b\": [150, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").arg_max().name.suffix(\"_arg_max\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|   a_arg_max  b_arg_max|\n|0          1          0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.arg_min","title":"arg_min","text":"<pre><code>arg_min() -&gt; Self\n</code></pre> <p>Returns the index of the minimum value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [10, 20], \"b\": [150, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").arg_min().name.suffix(\"_arg_min\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|   a_arg_min  b_arg_min|\n|0          0          1|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.arg_true","title":"arg_true","text":"<pre><code>arg_true() -&gt; Self\n</code></pre> <p>Find elements where boolean expression is True.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.cast","title":"cast","text":"<pre><code>cast(dtype: DType | type[DType]) -&gt; Self\n</code></pre> <p>Redefine an object's data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DType | type[DType]</code> <p>Data type that the object will be cast into.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\").cast(nw.Float32), nw.col(\"bar\").cast(nw.UInt8))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      foo  bar    |\n|   0  1.0    6    |\n|   1  2.0    7    |\n|   2  3.0    8    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.count","title":"count","text":"<pre><code>count() -&gt; Self\n</code></pre> <p>Returns the number of non-null elements in the column.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [None, 4, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().count())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  3  2      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_count","title":"cum_count","text":"<pre><code>cum_count(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative count of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [\"x\", \"k\", None, \"d\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_count().alias(\"a_cum_count\"),\n...     nw.col(\"a\").cum_count(reverse=True).alias(\"a_cum_count_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|      a  a_cum_count  a_cum_count_reverse|\n|0     x            1                    3|\n|1     k            2                    2|\n|2  None            2                    1|\n|3     d            3                    1|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_max","title":"cum_max","text":"<pre><code>cum_max(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative max of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 3, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_max().alias(\"a_cum_max\"),\n...     nw.col(\"a\").cum_max(reverse=True).alias(\"a_cum_max_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|         Narwhals DataFrame         |\n|------------------------------------|\n|     a  a_cum_max  a_cum_max_reverse|\n|0  1.0        1.0                3.0|\n|1  3.0        3.0                3.0|\n|2  NaN        NaN                NaN|\n|3  2.0        3.0                2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_min","title":"cum_min","text":"<pre><code>cum_min(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative min of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 1, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_min().alias(\"a_cum_min\"),\n...     nw.col(\"a\").cum_min(reverse=True).alias(\"a_cum_min_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|         Narwhals DataFrame         |\n|------------------------------------|\n|     a  a_cum_min  a_cum_min_reverse|\n|0  3.0        3.0                1.0|\n|1  1.0        1.0                1.0|\n|2  NaN        NaN                NaN|\n|3  2.0        1.0                2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_prod","title":"cum_prod","text":"<pre><code>cum_prod(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative product of the non-null values in the column.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 3, None, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").cum_prod().alias(\"a_cum_prod\"),\n...     nw.col(\"a\").cum_prod(reverse=True).alias(\"a_cum_prod_reverse\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|          Narwhals DataFrame          |\n|--------------------------------------|\n|     a  a_cum_prod  a_cum_prod_reverse|\n|0  1.0         1.0                 6.0|\n|1  3.0         3.0                 6.0|\n|2  NaN         NaN                 NaN|\n|3  2.0         6.0                 2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_sum","title":"cum_sum","text":"<pre><code>cum_sum(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return cumulative sum.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_cum_sum=nw.col(\"a\").cum_sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   a  b  a_cum_sum|\n|0  1  2          1|\n|1  1  4          2|\n|2  3  4          5|\n|3  5  6         10|\n|4  5  6         15|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.diff","title":"diff","text":"<pre><code>diff() -&gt; Self\n</code></pre> <p>Returns the difference between each element and the previous one.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_diff=nw.col(\"a\").diff())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| shape: (5, 2)    |\n| \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n| \u2502 a   \u2506 a_diff \u2502 |\n| \u2502 --- \u2506 ---    \u2502 |\n| \u2502 i64 \u2506 i64    \u2502 |\n| \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 |\n| \u2502 1   \u2506 null   \u2502 |\n| \u2502 1   \u2506 0      \u2502 |\n| \u2502 3   \u2506 2      \u2502 |\n| \u2502 5   \u2506 2      \u2502 |\n| \u2502 5   \u2506 0      \u2502 |\n| \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls() -&gt; Self\n</code></pre> <p>Drop null values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").drop_nulls())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (5, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 a   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 f64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 2.0 \u2502         |\n|  \u2502 4.0 \u2502         |\n|  \u2502 NaN \u2502         |\n|  \u2502 3.0 \u2502         |\n|  \u2502 5.0 \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.ewm_mean","title":"ewm_mean","text":"<pre><code>ewm_mean(\n    *,\n    com: float | None = None,\n    span: float | None = None,\n    half_life: float | None = None,\n    alpha: float | None = None,\n    adjust: bool = True,\n    min_samples: int = 1,\n    ignore_nulls: bool = False\n) -&gt; Self\n</code></pre> <p>Compute exponentially-weighted moving average.</p> <p>Parameters:</p> Name Type Description Default <code>com</code> <code>float | None</code> <p>Specify decay in terms of center of mass, \\(\\gamma\\), with  \\(\\alpha = \\frac{1}{1+\\gamma}\\forall\\gamma\\geq0\\)</p> <code>None</code> <code>span</code> <code>float | None</code> <p>Specify decay in terms of span, \\(\\theta\\), with  \\(\\alpha = \\frac{2}{\\theta + 1} \\forall \\theta \\geq 1\\)</p> <code>None</code> <code>half_life</code> <code>float | None</code> <p>Specify decay in terms of half-life, \\(\\tau\\), with  \\(\\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\tau } \\right\\} \\forall \\tau &gt; 0\\)</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>Specify smoothing factor alpha directly, \\(0 &lt; \\alpha \\leq 1\\).</p> <code>None</code> <code>adjust</code> <code>bool</code> <p>Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings</p> <ul> <li>When <code>adjust=True</code> (the default) the EW function is calculated   using weights \\(w_i = (1 - \\alpha)^i\\)</li> <li>When <code>adjust=False</code> the EW function is calculated recursively by   $$   y_0=x_0   $$   $$   y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t   $$</li> </ul> <code>True</code> <code>min_samples</code> <code>int</code> <p>Minimum number of observations in window required to have a value, (otherwise result is null).</p> <code>1</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore missing values when calculating weights.</p> <ul> <li>When <code>ignore_nulls=False</code> (default), weights are based on absolute   positions.   For example, the weights of \\(x_0\\) and \\(x_2\\) used in   calculating the final weighted average of \\([x_0, None, x_2]\\) are   \\((1-\\alpha)^2\\) and \\(1\\) if <code>adjust=True</code>, and   \\((1-\\alpha)^2\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> <li>When <code>ignore_nulls=True</code>, weights are based   on relative positions. For example, the weights of   \\(x_0\\) and \\(x_2\\) used in calculating the final weighted   average of \\([x_0, None, x_2]\\) are   \\(1-\\alpha\\) and \\(1\\) if <code>adjust=True</code>,   and \\(1-\\alpha\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>Expr</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def agnostic_ewm_mean(df_native: IntoFrameT) -&gt; IntoFrameT:\n...     df = nw.from_native(df_native)\n...     return df.select(\n...         nw.col(\"a\").ewm_mean(com=1, ignore_nulls=False)\n...     ).to_native()\n</code></pre> <p>We can then pass either pandas or Polars to <code>agnostic_ewm_mean</code>:</p> <pre><code>&gt;&gt;&gt; agnostic_ewm_mean(df_pd)\n          a\n0  1.000000\n1  1.666667\n2  2.428571\n</code></pre> <pre><code>&gt;&gt;&gt; agnostic_ewm_mean(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a        \u2502\n\u2502 ---      \u2502\n\u2502 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0      \u2502\n\u2502 1.666667 \u2502\n\u2502 2.428571 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.fill_null","title":"fill_null","text":"<pre><code>fill_null(\n    value: Expr | NonNestedLiteral = None,\n    strategy: FillNullStrategy | None = None,\n    limit: int | None = None,\n) -&gt; Self\n</code></pre> <p>Fill null values with given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Expr | NonNestedLiteral</code> <p>Value or expression used to fill null values.</p> <code>None</code> <code>strategy</code> <code>FillNullStrategy | None</code> <p>Strategy used to fill null values.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\n...         \"a\": [2, None, None, 3],\n...         \"b\": [2.0, float(\"nan\"), float(\"nan\"), 3.0],\n...         \"c\": [1, 2, 3, 4],\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\", \"b\").fill_null(0).name.suffix(\"_filled\"),\n...     nw.col(\"a\").fill_null(nw.col(\"c\")).name.suffix(\"_filled_with_c\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                     Narwhals DataFrame                     |\n|------------------------------------------------------------|\n|shape: (4, 6)                                               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 b   \u2506 c   \u2506 a_filled \u2506 b_filled \u2506 a_filled_with_c \u2502|\n|\u2502 ---  \u2506 --- \u2506 --- \u2506 ---      \u2506 ---      \u2506 ---             \u2502|\n|\u2502 i64  \u2506 f64 \u2506 i64 \u2506 i64      \u2506 f64      \u2506 i64             \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2    \u2506 2.0 \u2506 1   \u2506 2        \u2506 2.0      \u2506 2               \u2502|\n|\u2502 null \u2506 NaN \u2506 2   \u2506 0        \u2506 NaN      \u2506 2               \u2502|\n|\u2502 null \u2506 NaN \u2506 3   \u2506 0        \u2506 NaN      \u2506 3               \u2502|\n|\u2502 3    \u2506 3.0 \u2506 4   \u2506 3        \u2506 3.0      \u2506 3               \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Using a strategy:</p> <pre><code>&gt;&gt;&gt; df.select(\n...     nw.col(\"a\", \"b\"),\n...     nw.col(\"a\", \"b\")\n...     .fill_null(strategy=\"forward\", limit=1)\n...     .name.suffix(\"_nulls_forward_filled\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|                       Narwhals DataFrame                       |\n|----------------------------------------------------------------|\n|shape: (4, 4)                                                   |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 b   \u2506 a_nulls_forward_filled \u2506 b_nulls_forward_filled \u2502|\n|\u2502 ---  \u2506 --- \u2506 ---                    \u2506 ---                    \u2502|\n|\u2502 i64  \u2506 f64 \u2506 i64                    \u2506 f64                    \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2    \u2506 2.0 \u2506 2                      \u2506 2.0                    \u2502|\n|\u2502 null \u2506 NaN \u2506 2                      \u2506 NaN                    \u2502|\n|\u2502 null \u2506 NaN \u2506 null                   \u2506 NaN                    \u2502|\n|\u2502 3    \u2506 3.0 \u2506 3                      \u2506 3.0                    \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.filter","title":"filter","text":"<pre><code>filter(*predicates: Any) -&gt; Self\n</code></pre> <p>Filters elements based on a condition, returning a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>Any</code> <p>Conditions to filter by (which get ANDed together).</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(\n...     nw.col(\"a\").filter(nw.col(\"a\") &gt; 4),\n...     nw.col(\"b\").filter(nw.col(\"b\") &lt; 13),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     3  5  10     |\n|     4  6  11     |\n|     5  7  12     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth value in the Series and return as new Series.</p> Warning <p><code>Expr.gather_every</code> is deprecated and will be removed in a future version. Hint: instead of <code>df.select(nw.col('a').gather_every())</code>, use <code>df.select(nw.col('a')).gather_every()</code> instead. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; Self\n</code></pre> <p>Get the first <code>n</code> rows.</p> Warning <p><code>Expr.head</code> is deprecated and will be removed in a future version. Hint: instead of <code>df.select(nw.col('a').head())</code>, use <code>df.select(nw.col('a')).head()</code> instead. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.clip","title":"clip","text":"<pre><code>clip(\n    lower_bound: (\n        IntoExpr | NumericLiteral | TemporalLiteral | None\n    ) = None,\n    upper_bound: (\n        IntoExpr | NumericLiteral | TemporalLiteral | None\n    ) = None,\n) -&gt; Self\n</code></pre> <p>Clip values in the Series.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>IntoExpr | NumericLiteral | TemporalLiteral | None</code> <p>Lower bound value. String literals are treated as column names.</p> <code>None</code> <code>upper_bound</code> <code>IntoExpr | NumericLiteral | TemporalLiteral | None</code> <p>Upper bound value. String literals are treated as column names.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_clipped=nw.col(\"a\").clip(-1, 3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    a  a_clipped  |\n| 0  1          1  |\n| 1  2          2  |\n| 2  3          3  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_between","title":"is_between","text":"<pre><code>is_between(\n    lower_bound: Any | IntoExpr,\n    upper_bound: Any | IntoExpr,\n    closed: ClosedInterval = \"both\",\n) -&gt; Self\n</code></pre> <p>Check if this expression is between the given lower and upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any | IntoExpr</code> <p>Lower bound value. String literals are interpreted as column names.</p> required <code>upper_bound</code> <code>Any | IntoExpr</code> <p>Upper bound value. String literals are interpreted as column names.</p> required <code>closed</code> <code>ClosedInterval</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(b=nw.col(\"a\").is_between(2, 4, \"right\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  1  False    |\n|   1  2  False    |\n|   2  3   True    |\n|   3  4   True    |\n|   4  5  False    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating duplicated values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.all().is_duplicated().name.suffix(\"_is_duplicated\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|   a  b  a_is_duplicated  b_is_duplicated|\n|0  1  a             True             True|\n|1  2  a            False             True|\n|2  3  b            False            False|\n|3  1  c             True            False|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_finite","title":"is_finite","text":"<pre><code>is_finite() -&gt; Self\n</code></pre> <p>Returns boolean values indicating which original values are finite.</p> Warning <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference. <code>is_finite</code> will return False for NaN and Null's in the Dask and pandas non-nullable backend, while for Polars, PyArrow and pandas nullable backends null values are kept as such.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Expression of <code>Boolean</code> data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [float(\"nan\"), float(\"inf\"), 2.0, None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_is_finite=nw.col(\"a\").is_finite())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|shape: (4, 2)         |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a    \u2506 a_is_finite \u2502|\n|\u2502 ---  \u2506 ---         \u2502|\n|\u2502 f64  \u2506 bool        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 NaN  \u2506 false       \u2502|\n|\u2502 inf  \u2506 false       \u2502|\n|\u2502 2.0  \u2506 true        \u2502|\n|\u2502 null \u2506 null        \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_first_distinct","title":"is_first_distinct","text":"<pre><code>is_first_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the first occurrence of each distinct value.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.all().is_first_distinct().name.suffix(\"_is_first_distinct\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|               Narwhals DataFrame                |\n|-------------------------------------------------|\n|   a  b  a_is_first_distinct  b_is_first_distinct|\n|0  1  a                 True                 True|\n|1  2  a                 True                False|\n|2  3  b                 True                 True|\n|3  1  c                False                 True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_in","title":"is_in","text":"<pre><code>is_in(other: Any) -&gt; Self\n</code></pre> <p>Check if elements of this expression are present in the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>iterable</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 9, 10]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(b=nw.col(\"a\").is_in([1, 2]))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a      b   |\n|   0   1   True   |\n|   1   2   True   |\n|   2   9  False   |\n|   3  10  False   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_last_distinct","title":"is_last_distinct","text":"<pre><code>is_last_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the last occurrence of each distinct value.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.all().is_last_distinct().name.suffix(\"_is_last_distinct\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|              Narwhals DataFrame               |\n|-----------------------------------------------|\n|   a  b  a_is_last_distinct  b_is_last_distinct|\n|0  1  a               False               False|\n|1  2  a                True                True|\n|2  3  b                True                True|\n|3  1  c                True                True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_nan","title":"is_nan","text":"<pre><code>is_nan() -&gt; Self\n</code></pre> <p>Indicate which values are NaN.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (null, CAST('NaN' AS DOUBLE)), (2, 2.) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_is_nan=nw.col(\"a\").is_nan(), b_is_nan=nw.col(\"b\").is_nan()\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals LazyFrame           |\n|----------------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502   b    \u2502 a_is_nan \u2502 b_is_nan \u2502|\n|\u2502 int32 \u2502 double \u2502 boolean  \u2502 boolean  \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502    nan \u2502 NULL     \u2502 true     \u2502|\n|\u2502     2 \u2502    2.0 \u2502 false    \u2502 false    \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are null.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (null, CAST('NaN' AS DOUBLE)), (2, 2.) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_is_null=nw.col(\"a\").is_null(), b_is_null=nw.col(\"b\").is_null()\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|            Narwhals LazyFrame            |\n|------------------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502   b    \u2502 a_is_null \u2502 b_is_null \u2502|\n|\u2502 int32 \u2502 double \u2502  boolean  \u2502  boolean  \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502    nan \u2502 true      \u2502 false     \u2502|\n|\u2502     2 \u2502    2.0 \u2502 false     \u2502 false     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating unique values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.all().is_unique().name.suffix(\"_is_unique\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals DataFrame        |\n|---------------------------------|\n|   a  b  a_is_unique  b_is_unique|\n|0  1  a        False        False|\n|1  2  a         True        False|\n|2  3  b         True         True|\n|3  1  c        False         True|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.len","title":"len","text":"<pre><code>len() -&gt; Self\n</code></pre> <p>Return the number of elements in the column.</p> <p>Null values count towards the total.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 2, 1]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(\n...     nw.col(\"a\").filter(nw.col(\"b\") == 1).len().alias(\"a1\"),\n...     nw.col(\"a\").filter(nw.col(\"b\") == 2).len().alias(\"a2\"),\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a1  a2     |\n|    0   2   1     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.log","title":"log","text":"<pre><code>log(base: float = math.e) -&gt; Self\n</code></pre> <p>Compute the logarithm to a given base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>float</code> <p>Given base, defaults to <code>e</code></p> <code>e</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression log values data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"values\": [1, 2, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(\n...     log=nw.col(\"values\").log(), log_2=nw.col(\"values\").log(base=2)\n... )\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|               Narwhals DataFrame               |\n|------------------------------------------------|\n|pyarrow.Table                                   |\n|values: int64                                   |\n|log: double                                     |\n|log_2: double                                   |\n|----                                            |\n|values: [[1,2,4]]                               |\n|log: [[0,0.6931471805599453,1.3862943611198906]]|\n|log_2: [[0,1,2]]                                |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.map_batches","title":"map_batches","text":"<pre><code>map_batches(\n    function: Callable[[Any], CompliantExpr[Any, Any]],\n    return_dtype: DType | None = None,\n) -&gt; Self\n</code></pre> <p>Apply a custom python function to a whole Series or sequence of Series.</p> <p>The output of this custom function is presumed to be either a Series, or a NumPy array (in which case it will be automatically converted into a Series).</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[Any], CompliantExpr[Any, Any]]</code> <p>Function to apply to Series.</p> required <code>return_dtype</code> <code>DType | None</code> <p>Dtype of the output Series. If not set, the dtype will be inferred based on the first non-null value that is returned by the function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\", \"b\")\n...     .map_batches(lambda s: s.to_numpy() + 1, return_dtype=nw.Float64)\n...     .name.suffix(\"_mapped\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|   a  b  a_mapped  b_mapped|\n|0  1  4       2.0       5.0|\n|1  2  5       3.0       6.0|\n|2  3  6       4.0       7.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.max","title":"max","text":"<pre><code>max() -&gt; Self\n</code></pre> <p>Returns the maximum value(s) from a column(s).</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.max(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|    0  20  100    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.mean","title":"mean","text":"<pre><code>mean() -&gt; Self\n</code></pre> <p>Get mean value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").mean())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|   0  0.0  4.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.median","title":"median","text":"<pre><code>median() -&gt; Self\n</code></pre> <p>Get median value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>Results might slightly differ across backends due to differences in the underlying algorithms used to compute the median.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 8, 3], \"b\": [4, 5, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").median())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a    b    |\n|   0  3.0  4.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.min","title":"min","text":"<pre><code>min() -&gt; Self\n</code></pre> <p>Returns the minimum value(s) from a column(s).</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.min(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.mode","title":"mode","text":"<pre><code>mode() -&gt; Self\n</code></pre> <p>Compute the most occurring value(s).</p> <p>Can return multiple values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 2, 3], \"b\": [1, 1, 2, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").mode()).sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|          a       |\n|       0  1       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; Self\n</code></pre> <p>Count null values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [1, 2, None, 1], \"b\": [\"a\", None, \"b\", None]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.all().null_count())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  2      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.n_unique","title":"n_unique","text":"<pre><code>n_unique() -&gt; Self\n</code></pre> <p>Returns count of unique values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").n_unique())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  5  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.over","title":"over","text":"<pre><code>over(\n    *partition_by: str | Sequence[str],\n    order_by: str | Sequence[str] | None = None\n) -&gt; Self\n</code></pre> <p>Compute expressions over the given groups (optionally with given order).</p> <p>Parameters:</p> Name Type Description Default <code>partition_by</code> <code>str | Sequence[str]</code> <p>Names of columns to compute window expression over. Must be names of columns, as opposed to expressions - so, this is a bit less flexible than Polars' <code>Expr.over</code>.</p> <code>()</code> <code>order_by</code> <code>str | Sequence[str] | None</code> <p>Column(s) to order window functions by. For lazy backends, this argument is required when <code>over</code> is applied to order-dependent functions, see order-dependence.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 4], \"b\": [\"x\", \"x\", \"y\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_min_per_group=nw.col(\"a\").min().over(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|   a  b  a_min_per_group|\n|0  1  x                1|\n|1  2  x                1|\n|2  4  y                4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Cumulative operations are also supported, but (currently) only for pandas and Polars:</p> <pre><code>&gt;&gt;&gt; df.with_columns(a_cum_sum_per_group=nw.col(\"a\").cum_sum().over(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|   a  b  a_cum_sum_per_group|\n|0  1  x                    1|\n|1  2  x                    3|\n|2  4  y                    4|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>R</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_piped=nw.col(\"a\").pipe(lambda x: x + 1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|     a  a_piped   |\n|  0  1        2   |\n|  1  2        3   |\n|  2  3        4   |\n|  3  4        5   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.quantile","title":"quantile","text":"<pre><code>quantile(\n    quantile: float,\n    interpolation: RollingInterpolationMethod,\n) -&gt; Self\n</code></pre> <p>Get quantile value.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>float</code> <p>Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <code>RollingInterpolationMethod</code> <p>Interpolation method.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Note <ul> <li>pandas and Polars may have implementation differences for a given interpolation method.</li> <li>dask has     its own method to approximate quantile and it doesn't implement 'nearest', 'higher',     'lower', 'midpoint' as interpolation method - use 'linear' which is closest to the     native 'dask' - method.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": list(range(50)), \"b\": list(range(50, 100))}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").quantile(0.5, interpolation=\"linear\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a     b   |\n|  0  24.5  74.5   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rank","title":"rank","text":"<pre><code>rank(\n    method: RankMethod = \"average\",\n    *,\n    descending: bool = False\n) -&gt; Self\n</code></pre> <p>Assign ranks to data, dealing with ties appropriately.</p> Notes <p>The resulting dtype may differ between backends.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RankMethod</code> <p>The method used to assign ranks to tied elements. The following methods are available (default is 'average')</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul> <code>'average'</code> <code>descending</code> <code>bool</code> <p>Rank in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression with rank data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 6, 1, 1, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; result = df.with_columns(rank=nw.col(\"a\").rank(method=\"dense\"))\n&gt;&gt;&gt; result\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a  rank    |\n|    0  3   2.0    |\n|    1  6   3.0    |\n|    2  1   1.0    |\n|    3  1   1.0    |\n|    4  6   3.0    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.replace_strict","title":"replace_strict","text":"<pre><code>replace_strict(\n    old: Sequence[Any] | Mapping[Any, Any],\n    new: Sequence[Any] | None = None,\n    *,\n    return_dtype: DType | type[DType] | None = None\n) -&gt; Self\n</code></pre> <p>Replace all values by different values.</p> <p>This function must replace all non-null input values (else it raises an error).</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>Sequence[Any] | Mapping[Any, Any]</code> <p>Sequence of values to replace. It also accepts a mapping of values to their replacement as syntactic sugar for <code>replace_all(old=list(mapping.keys()), new=list(mapping.values()))</code>.</p> required <code>new</code> <code>Sequence[Any] | None</code> <p>Sequence of values to replace by. Length must match the length of <code>old</code>.</p> <code>None</code> <code>return_dtype</code> <code>DType | type[DType] | None</code> <p>The data type of the resulting expression. If set to <code>None</code> (default), the data type is determined automatically based on the other inputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [3, 0, 1, 2]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     b=nw.col(\"a\").replace_strict(\n...         [0, 1, 2, 3],\n...         [\"zero\", \"one\", \"two\", \"three\"],\n...         return_dtype=nw.String,\n...     )\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  3  three    |\n|   1  0   zero    |\n|   2  1    one    |\n|   3  2    two    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_mean","title":"rolling_mean","text":"<pre><code>rolling_mean(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling mean (moving mean) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their mean.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_mean=nw.col(\"a\").rolling_mean(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|     a  a_rolling_mean|\n|0  1.0             1.0|\n|1  2.0             1.5|\n|2  NaN             1.5|\n|3  4.0             3.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_std","title":"rolling_std","text":"<pre><code>rolling_std(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling standard deviation (moving standard deviation) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their standard deviation.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_std=nw.col(\"a\").rolling_std(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_std|\n|0  1.0            NaN|\n|1  2.0       0.707107|\n|2  NaN       0.707107|\n|3  4.0       1.414214|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_sum","title":"rolling_sum","text":"<pre><code>rolling_sum(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling sum (moving sum) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their sum.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_sum=nw.col(\"a\").rolling_sum(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_sum|\n|0  1.0            1.0|\n|1  2.0            3.0|\n|2  NaN            3.0|\n|3  4.0            6.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.rolling_var","title":"rolling_var","text":"<pre><code>rolling_var(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling variance (moving variance) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their variance.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.0, 2.0, None, 4.0]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_rolling_var=nw.col(\"a\").rolling_var(window_size=3, min_samples=1)\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|     a  a_rolling_var|\n|0  1.0            NaN|\n|1  2.0            0.5|\n|2  NaN            0.5|\n|3  4.0            2.0|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.round","title":"round","text":"<pre><code>round(decimals: int = 0) -&gt; Self\n</code></pre> <p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>For values exactly halfway between rounded decimal values pandas behaves differently than Polars and Arrow.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars and Arrow round away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1.12345, 2.56789, 3.901234]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_rounded=nw.col(\"a\").round(1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          a  a_rounded|\n|0  1.123450        1.1|\n|1  2.567890        2.6|\n|2  3.901234        3.9|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sample","title":"sample","text":"<pre><code>sample(\n    n: int | None = None,\n    *,\n    fraction: float | None = None,\n    with_replacement: bool = False,\n    seed: int | None = None\n) -&gt; Self\n</code></pre> <p>Sample randomly from this expression.</p> Warning <p><code>Expr.sample</code> is deprecated and will be removed in a future version. Hint: instead of <code>df.select(nw.col('a').sample())</code>, use <code>df.select(nw.col('a')).sample()</code> instead. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If set to None (default), a random seed is generated for each sample operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.shift","title":"shift","text":"<pre><code>shift(n: int) -&gt; Self\n</code></pre> <p>Shift values by <code>n</code> positions.</p> Info <p>For lazy backends, this operation must be followed by <code>Expr.over</code> with <code>order_by</code> specified, see order-dependence.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of positions to shift values by.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_shift=nw.col(\"a\").shift(n=1))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|shape: (5, 2)     |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502 a   \u2506 a_shift \u2502 |\n|\u2502 --- \u2506 ---     \u2502 |\n|\u2502 i64 \u2506 i64     \u2502 |\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 |\n|\u2502 1   \u2506 null    \u2502 |\n|\u2502 1   \u2506 1       \u2502 |\n|\u2502 3   \u2506 1       \u2502 |\n|\u2502 5   \u2506 3       \u2502 |\n|\u2502 5   \u2506 5       \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sort","title":"sort","text":"<pre><code>sort(\n    *, descending: bool = False, nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort this column. Place null values first.</p> Warning <p><code>Expr.sort</code> is deprecated and will be removed in a future version. Hint: instead of <code>df.select(nw.col('a').sort())</code>, use <code>df.select(nw.col('a')).sort()</code> instead. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last instead of first.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.skew","title":"skew","text":"<pre><code>skew() -&gt; Self\n</code></pre> <p>Calculate the sample skewness of a column.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An expression representing the sample skewness of the column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 2, 10, 100]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").skew())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a         b |\n| 0  0.0  1.472427 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.std","title":"std","text":"<pre><code>std(*, ddof: int = 1) -&gt; Self\n</code></pre> <p>Get standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").std(ddof=0))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|          a         b|\n|0  17.79513  1.265789|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sum","title":"sum","text":"<pre><code>sum() -&gt; Expr\n</code></pre> <p>Return the sum value.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\"SELECT * FROM VALUES (5, 50), (10, 100) df(a, b)\")\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame |\n|-------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a    \u2502   b    \u2502|\n|\u2502 int128 \u2502 int128 \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     15 \u2502    150 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> Warning <p><code>Expr.tail</code> is deprecated and will be removed in a future version. Hint: instead of <code>df.select(nw.col('a').tail())</code>, use <code>df.select(nw.col('a')).tail()</code> instead. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p>"},{"location":"api-reference/expr/#narwhals.Expr.unique","title":"unique","text":"<pre><code>unique() -&gt; Self\n</code></pre> <p>Return unique values of this expression.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").unique().sum())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  9  12     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.var","title":"var","text":"<pre><code>var(*, ddof: int = 1) -&gt; Self\n</code></pre> <p>Get variance.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,      where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\", \"b\").var(ddof=0))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|            a         b|\n|0  316.666667  1.602222|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_cat/","title":"<code>narwhals.Expr.cat</code>","text":""},{"location":"api-reference/expr_cat/#narwhals.expr.ExprCatNamespace.get_categories","title":"get_categories","text":"<pre><code>get_categories() -&gt; ExprT\n</code></pre> <p>Get unique categories from column.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"fruits\": [\"apple\", \"mango\", \"mango\"]},\n...     schema={\"fruits\": pl.Categorical},\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"fruits\").cat.get_categories()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2502\n\u2502 ---    \u2502\n\u2502 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2502\n\u2502 mango  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/","title":"<code>narwhals.Expr.dt</code>","text":""},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.convert_time_zone","title":"convert_time_zone","text":"<pre><code>convert_time_zone(time_zone: str) -&gt; ExprT\n</code></pre> <p>Convert to a new time zone.</p> <p>If converting from a time-zone-naive column, then conversion happens as if converting from UTC.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str</code> <p>Target time zone.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\n...             datetime(2024, 1, 1, tzinfo=timezone.utc),\n...             datetime(2024, 1, 2, tzinfo=timezone.utc),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.convert_time_zone(\"Asia/Kathmandu\")).to_native()\n                          a\n0 2024-01-01 05:45:00+05:45\n1 2024-01-02 05:45:00+05:45\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.date","title":"date","text":"<pre><code>date() -&gt; ExprT\n</code></pre> <p>Extract the date from underlying DateTime representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If pandas default backend is being used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(2012, 1, 7, 10), datetime(2027, 12, 13)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.date()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a          \u2502\n\u2502 ---        \u2502\n\u2502 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2012-01-07 \u2502\n\u2502 2027-12-13 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.day","title":"day","text":"<pre><code>day() -&gt; ExprT\n</code></pre> <p>Extract day from underlying DateTime representation.</p> <p>Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.day().alias(\"day\")).to_native()\npyarrow.Table\na: timestamp[us]\nday: int64\n----\na: [[1978-06-01 00:00:00.000000,2065-01-01 00:00:00.000000]]\nday: [[1,1]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.hour","title":"hour","text":"<pre><code>hour() -&gt; ExprT\n</code></pre> <p>Extract hour from underlying DateTime representation.</p> <p>Returns the hour number from 0 to 23.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(1978, 1, 1, 1), datetime(2065, 1, 1, 10)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.hour().alias(\"hour\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|      Narwhals DataFrame      |\n|------------------------------|\n|shape: (2, 2)                 |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2506 hour \u2502|\n|\u2502 ---                 \u2506 ---  \u2502|\n|\u2502 datetime[\u03bcs]        \u2506 i8   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1978-01-01 01:00:00 \u2506 1    \u2502|\n|\u2502 2065-01-01 10:00:00 \u2506 10   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.microsecond","title":"microsecond","text":"<pre><code>microsecond() -&gt; ExprT\n</code></pre> <p>Extract microseconds from underlying DateTime representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.microsecond().alias(\"microsecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nmicrosecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nmicrosecond: [[0,67000]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.millisecond","title":"millisecond","text":"<pre><code>millisecond() -&gt; ExprT\n</code></pre> <p>Extract milliseconds from underlying DateTime representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.millisecond().alias(\"millisecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nmillisecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nmillisecond: [[0,67]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.minute","title":"minute","text":"<pre><code>minute() -&gt; ExprT\n</code></pre> <p>Extract minutes from underlying DateTime representation.</p> <p>Returns the minute number from 0 to 59.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(1978, 1, 1, 1, 1), datetime(2065, 1, 1, 10, 20)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.minute().alias(\"minute\")).to_native()\n                    a  minute\n0 1978-01-01 01:01:00       1\n1 2065-01-01 10:20:00      20\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.month","title":"month","text":"<pre><code>month() -&gt; ExprT\n</code></pre> <p>Extract month from underlying DateTime representation.</p> <p>Returns the month number starting from 1. The return value ranges from 1 to 12.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.month().alias(\"month\")).to_native()\npyarrow.Table\na: timestamp[us]\nmonth: int64\n----\na: [[1978-06-01 00:00:00.000000,2065-01-01 00:00:00.000000]]\nmonth: [[6,1]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.nanosecond","title":"nanosecond","text":"<pre><code>nanosecond() -&gt; ExprT\n</code></pre> <p>Extract Nanoseconds from underlying DateTime representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1, 0),\n...             datetime(2065, 1, 1, 10, 20, 30, 67000),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"a\").dt.nanosecond().alias(\"nanosecond\")\n... ).to_native()\npyarrow.Table\na: timestamp[us]\nnanosecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.067000]]\nnanosecond: [[0,67000000]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.ordinal_day","title":"ordinal_day","text":"<pre><code>ordinal_day() -&gt; ExprT\n</code></pre> <p>Get ordinal day.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_ordinal_day=nw.col(\"a\").dt.ordinal_day())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|           a  a_ordinal_day|\n|0 2020-01-01              1|\n|1 2020-08-03            216|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.replace_time_zone","title":"replace_time_zone","text":"<pre><code>replace_time_zone(time_zone: str | None) -&gt; ExprT\n</code></pre> <p>Replace time zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str | None</code> <p>Target time zone.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\n...             datetime(2024, 1, 1, tzinfo=timezone.utc),\n...             datetime(2024, 1, 2, tzinfo=timezone.utc),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.replace_time_zone(\"Asia/Kathmandu\")).to_native()\n                          a\n0 2024-01-01 00:00:00+05:45\n1 2024-01-02 00:00:00+05:45\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.second","title":"second","text":"<pre><code>second() -&gt; ExprT\n</code></pre> <p>Extract seconds from underlying DateTime representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             datetime(1978, 1, 1, 1, 1, 1),\n...             datetime(2065, 1, 1, 10, 20, 30),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.second().alias(\"second\")).to_native()\npyarrow.Table\na: timestamp[us]\nsecond: int64\n----\na: [[1978-01-01 01:01:01.000000,2065-01-01 10:20:30.000000]]\nsecond: [[1,30]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.timestamp","title":"timestamp","text":"<pre><code>timestamp(time_unit: TimeUnit = 'us') -&gt; ExprT\n</code></pre> <p>Return a timestamp in the given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>One of - 'ns': nanosecond. - 'us': microsecond. - 'ms': millisecond.</p> <code>'us'</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"date\": [date(2001, 1, 1), None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"date\").dt.timestamp(\"ms\").alias(\"timestamp_ms\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame      |\n|-----------------------------|\n|shape: (2, 2)                |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 date       \u2506 timestamp_ms \u2502|\n|\u2502 ---        \u2506 ---          \u2502|\n|\u2502 date       \u2506 i64          \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2001-01-01 \u2506 978307200000 \u2502|\n|\u2502 null       \u2506 null         \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_microseconds","title":"total_microseconds","text":"<pre><code>total_microseconds() -&gt; ExprT\n</code></pre> <p>Get total microseconds.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table(\n...     {\n...         \"a\": [\n...             timedelta(microseconds=10),\n...             timedelta(milliseconds=1, microseconds=200),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_microseconds=nw.col(\"a\").dt.total_microseconds()\n... ).to_native()\npyarrow.Table\na: duration[us]\na_total_microseconds: int64\n----\na: [[10,1200]]\na_total_microseconds: [[10,1200]]\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_milliseconds","title":"total_milliseconds","text":"<pre><code>total_milliseconds() -&gt; ExprT\n</code></pre> <p>Get total milliseconds.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\n...         \"a\": [\n...             timedelta(milliseconds=10),\n...             timedelta(milliseconds=20, microseconds=40),\n...         ]\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_milliseconds=nw.col(\"a\").dt.total_milliseconds()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_milliseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10ms         \u2506 10                   \u2502\n\u2502 20040\u00b5s      \u2506 20                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_minutes","title":"total_minutes","text":"<pre><code>total_minutes() -&gt; ExprT\n</code></pre> <p>Get total minutes.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_minutes=nw.col(\"a\").dt.total_minutes()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_minutes \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10m          \u2506 10              \u2502\n\u2502 20m 40s      \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_nanoseconds","title":"total_nanoseconds","text":"<pre><code>total_nanoseconds() -&gt; ExprT\n</code></pre> <p>Get total nanoseconds.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": pd.to_datetime(\n...             [\n...                 \"2024-01-01 00:00:00.000000001\",\n...                 \"2024-01-01 00:00:00.000000002\",\n...             ]\n...         )\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_diff_total_nanoseconds=nw.col(\"a\").diff().dt.total_nanoseconds()\n... ).to_native()\n                              a  a_diff_total_nanoseconds\n0 2024-01-01 00:00:00.000000001                       NaN\n1 2024-01-01 00:00:00.000000002                       1.0\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_seconds","title":"total_seconds","text":"<pre><code>total_seconds() -&gt; ExprT\n</code></pre> <p>Get total seconds.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     a_total_seconds=nw.col(\"a\").dt.total_seconds()\n... ).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_seconds \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10s          \u2506 10              \u2502\n\u2502 20s 40ms     \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.to_string","title":"to_string","text":"<pre><code>to_string(format: str) -&gt; ExprT\n</code></pre> <p>Convert a Date/Time/Datetime column into a String column with the given format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format to format temporal column with.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments.</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>Though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"a\": [datetime(2020, 3, 1), datetime(2020, 5, 1)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").dt.to_string(\"%Y/%m/%d %H:%M:%S\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 1)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2502|\n|\u2502 ---                 \u2502|\n|\u2502 str                 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2020/03/01 00:00:00 \u2502|\n|\u2502 2020/05/01 00:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.truncate","title":"truncate","text":"<pre><code>truncate(every: str) -&gt; ExprT\n</code></pre> <p>Divide the date/datetime range into buckets.</p> <p>Parameters:</p> Name Type Description Default <code>every</code> <code>str</code> <p>Length of bucket. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Returns:</p> Type Description <code>ExprT</code> <p>Expression of data type <code>Date</code> or <code>Datetime</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"datetime\": [datetime(2021, 3, 1, 12, 34)]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     nw.col(\"datetime\").dt.truncate(\"1h\").alias(\"datetime_trunc\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|             Narwhals DataFrame              |\n|---------------------------------------------|\n|shape: (1, 2)                                |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 datetime            \u2506 datetime_trunc      \u2502|\n|\u2502 ---                 \u2506 ---                 \u2502|\n|\u2502 datetime[\u03bcs]        \u2506 datetime[\u03bcs]        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2021-03-01 12:34:00 \u2506 2021-03-01 12:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.weekday","title":"weekday","text":"<pre><code>weekday() -&gt; ExprT\n</code></pre> <p>Extract the week day from the underlying Date representation.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>Returns the ISO weekday number where monday = 1 and sunday = 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_week_day=nw.col(\"a\").dt.weekday())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|           a  a_week_day|\n|0 2020-01-01           3|\n|1 2020-08-03           1|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.year","title":"year","text":"<pre><code>year() -&gt; ExprT\n</code></pre> <p>Extract year from underlying DateTime representation.</p> <p>Returns the year number in the calendar date.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"a\": [datetime(1978, 6, 1), datetime(2065, 1, 1)]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"a\").dt.year().alias(\"year\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|           a  year|\n|0 1978-06-01  1978|\n|1 2065-01-01  2065|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_list/","title":"<code>narwhals.Expr.list</code>","text":""},{"location":"api-reference/expr_list/#narwhals.expr.ExprListNamespace.len","title":"len","text":"<pre><code>len() -&gt; ExprT\n</code></pre> <p>Return the number of elements in each list.</p> <p>Null values count towards the total.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [[1, 2], [3, 4, None], None, []]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(a_len=nw.col(\"a\").list.len())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame   |\n|------------------------|\n|shape: (4, 2)           |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a            \u2506 a_len \u2502|\n|\u2502 ---          \u2506 ---   \u2502|\n|\u2502 list[i64]    \u2506 u32   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 [1, 2]       \u2506 2     \u2502|\n|\u2502 [3, 4, null] \u2506 3     \u2502|\n|\u2502 null         \u2506 null  \u2502|\n|\u2502 []           \u2506 0     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_name/","title":"<code>narwhals.Expr.name</code>","text":""},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.keep","title":"keep","text":"<pre><code>keep() -&gt; ExprT\n</code></pre> <p>Keep the original root name of the expression.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\").alias(\"alias_for_foo\").name.keep()).columns\n['foo']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.map","title":"map","text":"<pre><code>map(function: Callable[[str], str]) -&gt; ExprT\n</code></pre> <p>Rename the output of an expression by mapping a function over the root name.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[str], str]</code> <p>Function that maps a root name to a new name.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; renaming_func = lambda s: s[::-1]  # reverse column name\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.map(renaming_func)).columns\n['oof', 'RAB']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.prefix","title":"prefix","text":"<pre><code>prefix(prefix: str) -&gt; ExprT\n</code></pre> <p>Add a prefix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add to the root column name.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.prefix(\"with_prefix\")).columns\n['with_prefixfoo', 'with_prefixBAR']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.suffix","title":"suffix","text":"<pre><code>suffix(suffix: str) -&gt; ExprT\n</code></pre> <p>Add a suffix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>Suffix to add to the root column name.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.suffix(\"_with_suffix\")).columns\n['foo_with_suffix', 'BAR_with_suffix']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; ExprT\n</code></pre> <p>Make the root column name lowercase.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.to_lowercase()).columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; ExprT\n</code></pre> <p>Make the root column name uppercase.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"foo\": [1, 2], \"BAR\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"foo\", \"BAR\").name.to_uppercase()).columns\n['FOO', 'BAR']\n</code></pre>"},{"location":"api-reference/expr_str/","title":"<code>narwhals.Expr.str</code>","text":""},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.contains","title":"contains","text":"<pre><code>contains(pattern: str, *, literal: bool = False) -&gt; ExprT\n</code></pre> <p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"pets\": [\"cat\", \"dog\", \"rabbit and parrot\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(\n...     default_match=nw.col(\"pets\").str.contains(\"cat|parrot\"),\n...     case_insensitive_match=nw.col(\"pets\").str.contains(\"cat|(?i)parrot\"),\n... ).to_native()\npyarrow.Table\npets: string\ndefault_match: bool\ncase_insensitive_match: bool\n----\npets: [[\"cat\",\"dog\",\"rabbit and parrot\"]]\ndefault_match: [[true,false,true]]\ncase_insensitive_match: [[true,false,true]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.ends_with","title":"ends_with","text":"<pre><code>ends_with(suffix: str) -&gt; ExprT\n</code></pre> <p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", \"mango\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(has_suffix=nw.col(\"fruits\").str.ends_with(\"ngo\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|  fruits has_suffix|\n|0  apple      False|\n|1  mango       True|\n|2   None       None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; ExprT\n</code></pre> <p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"lyrics\": [\"taata\", \"taatatata\", \"zukkyun\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lyrics_head=nw.col(\"lyrics\").str.head()).to_native()\npyarrow.Table\nlyrics: string\nlyrics_head: string\n----\nlyrics: [[\"taata\",\"taatatata\",\"zukkyun\"]]\nlyrics_head: [[\"taata\",\"taata\",\"zukky\"]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.len_chars","title":"len_chars","text":"<pre><code>len_chars() -&gt; ExprT\n</code></pre> <p>Return the length of each string as the number of characters.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"words\": [\"foo\", \"345\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(words_len=nw.col(\"words\").str.len_chars())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame  |\n|---------------------|\n|shape: (3, 2)        |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 words \u2506 words_len \u2502|\n|\u2502 ---   \u2506 ---       \u2502|\n|\u2502 str   \u2506 u32       \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 foo   \u2506 3         \u2502|\n|\u2502 345   \u2506 3         \u2502|\n|\u2502 null  \u2506 null      \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.replace","title":"replace","text":"<pre><code>replace(\n    pattern: str,\n    value: str,\n    *,\n    literal: bool = False,\n    n: int = 1\n) -&gt; ExprT\n</code></pre> <p>Replace first matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <code>n</code> <code>int</code> <p>Number of matches to replace.</p> <code>1</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [\"123abc\", \"abc abc123\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(replaced=nw.col(\"foo\").str.replace(\"abc\", \"\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          foo replaced|\n|0      123abc      123|\n|1  abc abc123   abc123|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.replace_all","title":"replace_all","text":"<pre><code>replace_all(\n    pattern: str, value: str, *, literal: bool = False\n) -&gt; ExprT\n</code></pre> <p>Replace all matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"foo\": [\"123abc\", \"abc abc123\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(replaced=nw.col(\"foo\").str.replace_all(\"abc\", \"\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|          foo replaced|\n|0      123abc      123|\n|1  abc abc123      123|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.slice","title":"slice","text":"<pre><code>slice(offset: int, length: int | None = None) -&gt; ExprT\n</code></pre> <p>Create subslices of the string values of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"s\": [\"pear\", None, \"papaya\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(s_sliced=nw.col(\"s\").str.slice(4, length=3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        s s_sliced|\n|0    pear         |\n|1    None     None|\n|2  papaya       ya|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.split","title":"split","text":"<pre><code>split(by: str) -&gt; ExprT\n</code></pre> <p>Split the string values of an expression by a substring.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Substring to split by.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"s\": [\"foo bar\", \"foo_bar\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(nw.col(\"s\").str.split(\"_\").alias(\"s_split\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals DataFrame     |\n|----------------------------|\n|shape: (2, 2)               |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 s       \u2506 s_split        \u2502|\n|\u2502 ---     \u2506 ---            \u2502|\n|\u2502 str     \u2506 list[str]      \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 foo bar \u2506 [\"foo bar\"]    \u2502|\n|\u2502 foo_bar \u2506 [\"foo\", \"bar\"] \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.starts_with","title":"starts_with","text":"<pre><code>starts_with(prefix: str) -&gt; ExprT\n</code></pre> <p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", \"mango\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(has_prefix=nw.col(\"fruits\").str.starts_with(\"app\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|  fruits has_prefix|\n|0  apple       True|\n|1  mango      False|\n|2   None       None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.strip_chars","title":"strip_chars","text":"<pre><code>strip_chars(characters: str | None = None) -&gt; ExprT\n</code></pre> <p>Remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>characters</code> <code>str | None</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped from the start and end of the string. If set to None (default), all leading and trailing whitespace is removed instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"fruits\": [\"apple\", \"\\nmango\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(stripped=nw.col(\"fruits\").str.strip_chars()).to_dict(\n...     as_series=False\n... )\n{'fruits': ['apple', '\\nmango'], 'stripped': ['apple', 'mango']}\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; ExprT\n</code></pre> <p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pa.table({\"lyrics\": [\"taata\", \"taatatata\", \"zukkyun\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lyrics_tail=nw.col(\"lyrics\").str.tail()).to_native()\npyarrow.Table\nlyrics: string\nlyrics_tail: string\n----\nlyrics: [[\"taata\",\"taatatata\",\"zukkyun\"]]\nlyrics_tail: [[\"taata\",\"atata\",\"kkyun\"]]\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(format: str | None = None) -&gt; ExprT\n</code></pre> <p>Convert to Datetime dtype.</p> Notes <ul> <li>pandas defaults to nanosecond time unit, Polars to microsecond.   Prior to pandas 2.0, nanoseconds were the only time unit supported   in pandas, with no ability to set any other one. The ability to   set the time unit in pandas, if the version permits, will arrive.</li> <li>timezone-aware strings are all converted to and parsed as UTC.</li> </ul> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.select(nw.col(\"a\").str.to_datetime(format=\"%Y-%m-%d\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 1)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a                   \u2502|\n|\u2502 ---                 \u2502|\n|\u2502 datetime[\u03bcs]        \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 2020-01-01 00:00:00 \u2502|\n|\u2502 2020-01-02 00:00:00 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; ExprT\n</code></pre> <p>Transform string to lowercase variant.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"APPLE\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(lower_col=nw.col(\"fruits\").str.to_lowercase())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  fruits lower_col|\n|0  APPLE     apple|\n|1   None      None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; ExprT\n</code></pre> <p>Transform string to uppercase variant.</p> <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> Notes <p>The PyArrow backend will convert '\u00df' to '\u1e9e' instead of 'SS'. For more info see the related issue. There may be other unicode-edge-case-related variations across implementations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"fruits\": [\"apple\", None]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(upper_col=nw.col(\"fruits\").str.to_uppercase())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  fruits upper_col|\n|0  apple     APPLE|\n|1   None      None|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_struct/","title":"<code>narwhals.Expr.struct</code>","text":""},{"location":"api-reference/expr_struct/#narwhals.expr.ExprStructNamespace.field","title":"field","text":"<pre><code>field(name: str) -&gt; ExprT\n</code></pre> <p>Retrieve a Struct field as a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the struct field to retrieve.</p> required <p>Returns:</p> Type Description <code>ExprT</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame(\n...     {\"user\": [{\"id\": \"0\", \"name\": \"john\"}, {\"id\": \"1\", \"name\": \"jane\"}]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.with_columns(name=nw.col(\"user\").struct.field(\"name\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame   |\n|-----------------------|\n|shape: (2, 2)          |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 user         \u2506 name \u2502|\n|\u2502 ---          \u2506 ---  \u2502|\n|\u2502 struct[2]    \u2506 str  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 {\"0\",\"john\"} \u2506 john \u2502|\n|\u2502 {\"1\",\"jane\"} \u2506 jane \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/group_by/","title":"<code>narwhals.GroupBy</code>","text":""},{"location":"api-reference/group_by/#narwhals.group_by.GroupBy.agg","title":"agg","text":"<pre><code>agg(\n    *aggs: Expr | Iterable[Expr], **named_aggs: Expr\n) -&gt; DataFrameT\n</code></pre> <p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>Expr | Iterable[Expr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>Expr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrameT</code> <p>A new Dataframe.</p> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt;\n&gt;&gt;&gt; df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  a  2      |\n|     1  b  5      |\n|     2  c  3      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt;\n&gt;&gt;&gt; df.group_by(\"a\", \"b\").agg(nw.col(\"c\").sum()).sort(\"a\", \"b\").to_native()\n   a  b  c\n0  a  1  8\n1  b  2  4\n2  b  3  2\n3  c  3  1\n</code></pre>"},{"location":"api-reference/implementation/","title":"<code>narwhals.Implementation</code>","text":"<p>               Bases: <code>NoAutoEnum</code></p> <p>Implementation of native object (pandas, Polars, PyArrow, ...).</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.CUDF","title":"CUDF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUDF = 'cudf'\n</code></pre> <p>cuDF implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.DASK","title":"DASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DASK = 'dask'\n</code></pre> <p>Dask implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.DUCKDB","title":"DUCKDB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DUCKDB = 'duckdb'\n</code></pre> <p>DuckDB implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.IBIS","title":"IBIS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IBIS = 'ibis'\n</code></pre> <p>Ibis implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.MODIN","title":"MODIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIN = 'modin'\n</code></pre> <p>Modin implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PANDAS","title":"PANDAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PANDAS = 'pandas'\n</code></pre> <p>pandas implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.POLARS","title":"POLARS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLARS = 'polars'\n</code></pre> <p>Polars implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYARROW","title":"PYARROW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYARROW = 'pyarrow'\n</code></pre> <p>PyArrow implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYSPARK","title":"PYSPARK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK = 'pyspark'\n</code></pre> <p>PySpark implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.PYSPARK_CONNECT","title":"PYSPARK_CONNECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PYSPARK_CONNECT = 'pyspark[connect]'\n</code></pre> <p>PySpark Connect implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.SQLFRAME","title":"SQLFRAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQLFRAME = 'sqlframe'\n</code></pre> <p>SQLFrame implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.UNKNOWN","title":"UNKNOWN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN = 'unknown'\n</code></pre> <p>Unknown implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.from_backend","title":"from_backend  <code>classmethod</code>","text":"<pre><code>from_backend(\n    backend: str | Implementation | ModuleType,\n) -&gt; Implementation\n</code></pre> <p>Instantiate from native namespace module, string, or Implementation.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str | Implementation | ModuleType</code> <p>Backend to instantiate Implementation from.</p> required <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.from_native_namespace","title":"from_native_namespace  <code>classmethod</code>","text":"<pre><code>from_native_namespace(\n    native_namespace: ModuleType,\n) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>native_namespace</code> <code>ModuleType</code> <p>Native namespace.</p> required <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(backend_name: str) -&gt; Implementation\n</code></pre> <p>Instantiate Implementation object from a native namespace module.</p> <p>Parameters:</p> Name Type Description Default <code>backend_name</code> <code>str</code> <p>Name of backend, expressed as string.</p> required <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_cudf","title":"is_cudf","text":"<pre><code>is_cudf() -&gt; bool\n</code></pre> <p>Return whether implementation is cuDF.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_cudf()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_dask","title":"is_dask","text":"<pre><code>is_dask() -&gt; bool\n</code></pre> <p>Return whether implementation is Dask.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_dask()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_duckdb","title":"is_duckdb","text":"<pre><code>is_duckdb() -&gt; bool\n</code></pre> <p>Return whether implementation is DuckDB.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_duckdb()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_ibis","title":"is_ibis","text":"<pre><code>is_ibis() -&gt; bool\n</code></pre> <p>Return whether implementation is Ibis.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_ibis()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_modin","title":"is_modin","text":"<pre><code>is_modin() -&gt; bool\n</code></pre> <p>Return whether implementation is Modin.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_modin()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pandas","title":"is_pandas","text":"<pre><code>is_pandas() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pandas_like","title":"is_pandas_like","text":"<pre><code>is_pandas_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pandas, Modin, or cuDF.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pandas_like()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_polars","title":"is_polars","text":"<pre><code>is_polars() -&gt; bool\n</code></pre> <p>Return whether implementation is Polars.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_polars()\nTrue\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyarrow","title":"is_pyarrow","text":"<pre><code>is_pyarrow() -&gt; bool\n</code></pre> <p>Return whether implementation is PyArrow.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyarrow()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyspark","title":"is_pyspark","text":"<pre><code>is_pyspark() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_pyspark_connect","title":"is_pyspark_connect","text":"<pre><code>is_pyspark_connect() -&gt; bool\n</code></pre> <p>Return whether implementation is PySpark.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_pyspark_connect()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_spark_like","title":"is_spark_like","text":"<pre><code>is_spark_like() -&gt; bool\n</code></pre> <p>Return whether implementation is pyspark or sqlframe.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_spark_like()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.is_sqlframe","title":"is_sqlframe","text":"<pre><code>is_sqlframe() -&gt; bool\n</code></pre> <p>Return whether implementation is SQLFrame.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.implementation.is_sqlframe()\nFalse\n</code></pre>"},{"location":"api-reference/implementation/#narwhals.Implementation.to_native_namespace","title":"to_native_namespace","text":"<pre><code>to_native_namespace() -&gt; ModuleType\n</code></pre> <p>Return the native namespace module corresponding to Implementation.</p> <p>Returns:</p> Type Description <code>ModuleType</code> <p>Native module.</p>"},{"location":"api-reference/lazy_group_by/","title":"<code>narwhals.LazyGroupBy</code>","text":""},{"location":"api-reference/lazy_group_by/#narwhals.group_by.LazyGroupBy.agg","title":"agg","text":"<pre><code>agg(\n    *aggs: Expr | Iterable[Expr], **named_aggs: Expr\n) -&gt; LazyFrameT\n</code></pre> <p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>Expr | Iterable[Expr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>Expr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LazyFrameT</code> <p>A new LazyFrame.</p> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt; lf_native = pl.LazyFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.from_native(lf_native)\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.to_native(lf.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt;\n&gt;&gt;&gt; lf.group_by(\"a\", \"b\").agg(nw.sum(\"c\")).sort(\"a\", \"b\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame |\n|-------------------|\n|shape: (4, 3)      |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b   \u2506 c   \u2502|\n|\u2502 --- \u2506 --- \u2506 --- \u2502|\n|\u2502 str \u2506 i64 \u2506 i64 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 a   \u2506 1   \u2506 8   \u2502|\n|\u2502 b   \u2506 2   \u2506 4   \u2502|\n|\u2502 b   \u2506 3   \u2506 2   \u2502|\n|\u2502 c   \u2506 3   \u2506 1   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/","title":"<code>narwhals.LazyFrame</code>","text":"<p>Narwhals LazyFrame, backed by a native lazyframe.</p> Warning <p>This class is not meant to be instantiated directly - instead use <code>narwhals.from_native</code> with a native object that is a lazy dataframe from one of the supported backend (e.g. polars.LazyFrame, dask_expr._collection.DataFrame): <pre><code>narwhals.from_native(native_lazyframe)\n</code></pre></p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Get column names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The column names stored in a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).columns\n['a', 'b']\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.implementation","title":"implementation  <code>property</code>","text":"<pre><code>implementation: Implementation\n</code></pre> <p>Return implementation of native frame.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; lf_native = dd.from_dict({\"a\": [1, 2]}, npartitions=1)\n&gt;&gt;&gt; nw.from_native(lf_native).implementation\n&lt;Implementation.DASK: 'dask'&gt;\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A Narwhals Schema object that displays the mapping of column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).schema\nSchema({'a': Int32, 'b': Decimal})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect","title":"collect","text":"<pre><code>collect(\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Materialize this LazyFrame into a DataFrame.</p> <p>As each underlying lazyframe has different arguments to set when materializing the lazyframe into a dataframe, we allow to pass them as kwargs (see examples below for how to generalize the specification).</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>specifies which eager backend collect to. This will be the underlying backend for the resulting Narwhals DataFrame. If None, then the following default conversions will be applied</p> <ul> <li><code>polars.LazyFrame</code> -&gt; <code>polars.DataFrame</code></li> <li><code>dask.DataFrame</code> -&gt; <code>pandas.DataFrame</code></li> <li><code>duckdb.PyRelation</code> -&gt; <code>pyarrow.Table</code></li> <li><code>pyspark.DataFrame</code> -&gt; <code>pyarrow.Table</code></li> </ul> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>     or <code>POLARS</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code> or <code>\"polars\"</code></li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code> or <code>polars</code>.</li> </ul> <code>None</code> <code>kwargs</code> <code>Any</code> <p>backend specific kwargs to pass along. To know more please check the backend specific documentation</p> <ul> <li>polars.LazyFrame.collect</li> <li>dask.dataframe.DataFrame.compute</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; lf = nw.from_native(lf_native)\n&gt;&gt;&gt; lf\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     1 \u2502     2 \u2502 |\n|\u2502     3 \u2502     4 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; lf.collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int32        |\n|  b: int32        |\n|  ----            |\n|  a: [[1,3]]      |\n|  b: [[2,4]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect_schema","title":"collect_schema","text":"<pre><code>collect_schema() -&gt; Schema\n</code></pre> <p>Get an ordered mapping of column names to their data type.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A Narwhals Schema object that displays the mapping of column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).collect_schema()\nSchema({'a': Int32, 'b': Decimal})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop","title":"drop","text":"<pre><code>drop(\n    *columns: str | Iterable[str], strict: bool = True\n) -&gt; Self\n</code></pre> <p>Remove columns from the LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>Validate that all column names exist in the schema and throw an exception if a column name does not exist in the schema.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The LazyFrame with the specified columns removed.</p> Warning <p><code>strict</code> argument is ignored for <code>polars&lt;1.0.0</code>.</p> <p>Please consider upgrading to a newer version or pass to eager mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).drop(\"a\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   b   \u2502\n\u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502\n\u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls(subset: str | list[str] | None = None) -&gt; Self\n</code></pre> <p>Drop rows that contain null values.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) for which null values are considered. If set to None (default), use all columns.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The original object with the rows removed that contained the null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, NULL), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).drop_nulls()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     3 \u2502     4 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.explode","title":"explode","text":"<pre><code>explode(\n    columns: str | Sequence[str], *more_columns: str\n) -&gt; Self\n</code></pre> <p>Explode the dataframe to long format by exploding the given columns.</p> Notes <p>It is possible to explode multiple columns only if these columns have matching element counts.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str | Sequence[str]</code> <p>Column names. The underlying columns being exploded must be of the <code>List</code> data type.</p> required <code>*more_columns</code> <code>str</code> <p>Additional names of columns to explode, specified as positional arguments.</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>New LazyFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES ('x', [1, 2]), ('y', [3, 4]), ('z', [5, 6]) df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.explode(\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502   b   \u2502\n\u2502 varchar \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502     1 \u2502\n\u2502 x       \u2502     2 \u2502\n\u2502 y       \u2502     3 \u2502\n\u2502 y       \u2502     4 \u2502\n\u2502 z       \u2502     5 \u2502\n\u2502 z       \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.filter","title":"filter","text":"<pre><code>filter(\n    *predicates: IntoExpr | Iterable[IntoExpr] | list[bool],\n    **constraints: Any\n) -&gt; Self\n</code></pre> <p>Filter the rows in the LazyFrame based on a predicate expression.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr] | list[bool]</code> <p>Expression that evaluates to a boolean Series. Can also be a (single!) boolean list.</p> <code>()</code> <code>**constraints</code> <code>Any</code> <p>Column filters; use <code>name = value</code> to filter columns by the supplied value. Each constraint will behave the same as <code>nw.col(name).eq(value)</code>, and will be implicitly joined with the other filter conditions using &amp;.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The filtered LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql('''\n...     SELECT * FROM VALUES\n...         (1, 6, 'a'),\n...         (2, 7, 'b'),\n...         (3, 8, 'c')\n...     df(foo, bar, ham)\n... ''')\n</code></pre> <p>Filter on one condition</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(nw.col(\"foo\") &gt; 1).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502     7 \u2502 b       \u2502\n\u2502     3 \u2502     8 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions with implicit <code>&amp;</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     nw.col(\"foo\") &lt; 3, nw.col(\"ham\") == \"a\"\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     6 \u2502 a       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions with <code>|</code></p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(\n...     (nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\")\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     6 \u2502 a       \u2502\n\u2502     3 \u2502     8 \u2502 c       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter using <code>**kwargs</code> syntax</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).filter(foo=2, ham=\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  foo  \u2502  bar  \u2502   ham   \u2502\n\u2502 int32 \u2502 int32 \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     2 \u2502     7 \u2502 b       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth row in the DataFrame and return as a new DataFrame.</p> Warning <p><code>LazyFrame.gather_every</code> is deprecated and will be removed in a future version. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>The LazyFrame containing only the selected rows.</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.group_by","title":"group_by","text":"<pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: Literal[False] = ...\n) -&gt; LazyGroupBy[Self]\n</code></pre><pre><code>group_by(\n    *keys: str | Iterable[str],\n    drop_null_keys: Literal[True]\n) -&gt; LazyGroupBy[Self]\n</code></pre> <pre><code>group_by(\n    *keys: IntoExpr | Iterable[IntoExpr],\n    drop_null_keys: bool = False\n) -&gt; LazyGroupBy[Self]\n</code></pre> <p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>drop_null_keys</code> <code>bool</code> <p>if True, then groups where any key is null won't be included in the result.</p> <code>False</code> <p>Returns:</p> Type Description <code>LazyGroupBy[Self]</code> <p>Object which can be used to perform aggregations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'a'), (2, 'b'), (3, 'a') df(a, b)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.group_by(\"b\").agg(nw.col(\"a\").sum()).sort(\"b\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    b    \u2502   a    \u2502\n\u2502 varchar \u2502 int128 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a       \u2502      4 \u2502\n\u2502 b       \u2502      2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; df.group_by(nw.col(\"b\").str.len_chars()).agg(\n...     nw.col(\"a\").sum()\n... ).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   b   \u2502   a    \u2502\n\u2502 int64 \u2502 int128 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502      6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; Self\n</code></pre> <p>Get <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>Self</code> <p>A subset of the LazyFrame of shape (n, n_columns).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = dd.from_dict({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}, npartitions=1)\n&gt;&gt;&gt; nw.from_native(lf_native).head(2).collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  4      |\n|     1  2  5      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join","title":"join","text":"<pre><code>join(\n    other: Self,\n    on: str | list[str] | None = None,\n    how: JoinStrategy = \"inner\",\n    *,\n    left_on: str | list[str] | None = None,\n    right_on: str | list[str] | None = None,\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Add a join operation to the Logical Plan.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Lazy DataFrame to join with.</p> required <code>on</code> <code>str | list[str] | None</code> <p>Name(s) of the join columns in both DataFrames. If set, <code>left_on</code> and <code>right_on</code> should be None.</p> <code>None</code> <code>how</code> <code>JoinStrategy</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>left: Returns all rows from the left table, and the matched rows from the right table.</li> <li>full: Returns all rows in both dataframes, with the suffix appended to the right join keys.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Join column of the left DataFrame.</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Join column of the right DataFrame.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native1 = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'a'), (2, 'b') df(a, b)\"\n... )\n&gt;&gt;&gt; df_native2 = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 'x'), (3, 'y') df(a, c)\"\n... )\n&gt;&gt;&gt; df1 = nw.from_native(df_native1)\n&gt;&gt;&gt; df2 = nw.from_native(df_native2)\n&gt;&gt;&gt; df1.join(df2, on=\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|     Narwhals LazyFrame      |\n|-----------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502    b    \u2502    c    \u2502|\n|\u2502 int32 \u2502 varchar \u2502 varchar \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502 a       \u2502 x       \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join_asof","title":"join_asof","text":"<pre><code>join_asof(\n    other: Self,\n    *,\n    left_on: str | None = None,\n    right_on: str | None = None,\n    on: str | None = None,\n    by_left: str | list[str] | None = None,\n    by_right: str | list[str] | None = None,\n    by: str | list[str] | None = None,\n    strategy: AsofJoinStrategy = \"backward\",\n    suffix: str = \"_right\"\n) -&gt; Self\n</code></pre> <p>Perform an asof join.</p> <p>This is similar to a left-join except that we match on nearest key rather than equal keys.</p> <p>For Polars, both DataFrames must be sorted by the <code>on</code> key (within each <code>by</code> group if specified).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>left_on</code> <code>str | None</code> <p>Name(s) of the left join column(s).</p> <code>None</code> <code>right_on</code> <code>str | None</code> <p>Name(s) of the right join column(s).</p> <code>None</code> <code>on</code> <code>str | None</code> <p>Join column of both DataFrames. If set, left_on and right_on should be None.</p> <code>None</code> <code>by_left</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>by_right</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>by</code> <code>str | list[str] | None</code> <p>join on these columns before doing asof join</p> <code>None</code> <code>strategy</code> <code>AsofJoinStrategy</code> <p>Join strategy. The default is \"backward\".</p> <ul> <li>backward: selects the last row in the right DataFrame whose \"on\" key is less than or equal to the left's key.</li> <li>forward: selects the first row in the right DataFrame whose \"on\" key is greater than or equal to the left's key.</li> <li>nearest: search selects the last row in the right DataFrame whose value is nearest to the left's key.</li> </ul> <code>'backward'</code> <code>suffix</code> <code>str</code> <p>Suffix to append to columns with a duplicate name.</p> <code>'_right'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_gdp = {\n...     \"datetime\": [\n...         datetime(2016, 1, 1),\n...         datetime(2017, 1, 1),\n...         datetime(2018, 1, 1),\n...         datetime(2019, 1, 1),\n...         datetime(2020, 1, 1),\n...     ],\n...     \"gdp\": [4164, 4411, 4566, 4696, 4827],\n... }\n&gt;&gt;&gt; data_population = {\n...     \"datetime\": [\n...         datetime(2016, 3, 1),\n...         datetime(2018, 8, 1),\n...         datetime(2019, 1, 1),\n...     ],\n...     \"population\": [82.19, 82.66, 83.12],\n... }\n&gt;&gt;&gt; gdp_native = pl.DataFrame(data_gdp)\n&gt;&gt;&gt; population_native = pl.DataFrame(data_population)\n&gt;&gt;&gt; gdp = nw.from_native(gdp_native)\n&gt;&gt;&gt; population = nw.from_native(population_native)\n&gt;&gt;&gt; population.join_asof(gdp, on=\"datetime\", strategy=\"backward\").to_native()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 population \u2506 gdp  \u2502\n\u2502 ---                 \u2506 ---        \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 f64        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2016-03-01 00:00:00 \u2506 82.19      \u2506 4164 \u2502\n\u2502 2018-08-01 00:00:00 \u2506 82.66      \u2506 4566 \u2502\n\u2502 2019-01-01 00:00:00 \u2506 83.12      \u2506 4696 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.lazy","title":"lazy","text":"<pre><code>lazy() -&gt; Self\n</code></pre> <p>Restrict available API methods to lazy-only ones.</p> <p>This is a no-op, and exists only for compatibility with <code>DataFrame.lazy</code>.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A LazyFrame.</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[Concatenate[Self, PS], R],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; R\n</code></pre> <p>Pipe function call.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[Concatenate[Self, PS], R]</code> <p>Function to apply.</p> required <code>args</code> <code>args</code> <p>Positional arguments to pass to function.</p> <code>()</code> <code>kwargs</code> <code>kwargs</code> <p>Keyword arguments to pass to function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>R</code> <p>The original object with the function applied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).pipe(lambda x: x.select(\"a\")).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   a   \u2502\n\u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502\n\u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.rename","title":"rename","text":"<pre><code>rename(mapping: dict[str, str]) -&gt; Self\n</code></pre> <p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name, or a       function that takes the old name as input and returns the       new name.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The LazyFrame with the specified columns renamed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).rename({\"a\": \"c\"})\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals LazyFrame   |\n|------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   c   \u2502      b       \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502          4.5 \u2502|\n|\u2502     3 \u2502          2.0 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.select","title":"select","text":"<pre><code>select(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Select columns from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments. The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The LazyFrame containing only the selected columns.</p> Notes <p>If you'd like to select a column whose name isn't a string (for example, if you're working with pandas) then you should explicitly use <code>nw.col</code> instead of just passing the column name. For example, to select a column named <code>0</code> use <code>df.select(nw.col(0))</code>, not <code>df.select(0)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).select(\"a\", a_plus_1=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals LazyFrame |\n|--------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502 a_plus_1 \u2502|\n|\u2502 int32 \u2502  int32   \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502        2 \u2502|\n|\u2502     3 \u2502        4 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.sort","title":"sort","text":"<pre><code>sort(\n    by: str | Iterable[str],\n    *more_by: str,\n    descending: bool | Sequence[bool] = False,\n    nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort the LazyFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple columns, can be specified per column by passing a sequence of booleans.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last; can specify a single boolean applying to all columns or a sequence of booleans for per-column control.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The sorted LazyFrame.</p> Warning <p>Unlike Polars, it is not possible to specify a sequence of booleans for <code>nulls_last</code> in order to control per-column behaviour. Instead a single boolean is applied for all <code>by</code> columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES (1, 6.0, 'a'), (2, 5.0, 'c'), (NULL, 4.0, 'b') df(a, b, c)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.sort(\"a\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|        Narwhals LazyFrame        |\n|----------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502      b       \u2502    c    \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502 varchar \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502  NULL \u2502          4.0 \u2502 b       \u2502|\n|\u2502     1 \u2502          6.0 \u2502 a       \u2502|\n|\u2502     2 \u2502          5.0 \u2502 c       \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> Warning <p><code>LazyFrame.tail</code> is deprecated and will be removed in a future version. Note: this will remain available in <code>narwhals.stable.v1</code>. See stable api for more information.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>Self</code> <p>A subset of the LazyFrame of shape (n, n_columns).</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; FrameT\n</code></pre> <p>Convert Narwhals LazyFrame to native one.</p> <p>Returns:</p> Type Description <code>FrameT</code> <p>Object of class that user started with.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 2), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   a   \u2502   b   \u2502\n\u2502 int32 \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502     2 \u2502\n\u2502     3 \u2502     4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unique","title":"unique","text":"<pre><code>unique(\n    subset: str | list[str] | None = None,\n    *,\n    keep: LazyUniqueKeepStrategy = \"any\"\n) -&gt; Self\n</code></pre> <p>Drop duplicate rows from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.      If set to <code>None</code>, use all columns.</p> <code>None</code> <code>keep</code> <code>LazyUniqueKeepStrategy</code> <p>{'any', 'none'} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.</li> <li>'none': Don't keep duplicate rows.</li> </ul> <code>'any'</code> <p>Returns:</p> Type Description <code>Self</code> <p>The LazyFrame with unique rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 1), (3, 4) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).unique(\"a\").sort(\"a\", descending=True)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals LazyFrame|\n|------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 |\n|\u2502   a   \u2502   b   \u2502 |\n|\u2502 int32 \u2502 int32 \u2502 |\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 |\n|\u2502     3 \u2502     4 \u2502 |\n|\u2502     1 \u2502     1 \u2502 |\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unpivot","title":"unpivot","text":"<pre><code>unpivot(\n    on: str | list[str] | None = None,\n    *,\n    index: str | list[str] | None = None,\n    variable_name: str = \"variable\",\n    value_name: str = \"value\"\n) -&gt; Self\n</code></pre> <p>Unpivot a DataFrame from wide to long format.</p> <p>Optionally leaves identifiers set.</p> <p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (index) while all other columns, considered measured variables (on), are \"unpivoted\" to the row axis leaving just two non-identifier columns, 'variable' and 'value'.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str | list[str] | None</code> <p>Column(s) to use as values variables; if <code>on</code> is empty all columns that are not in <code>index</code> will be used.</p> <code>None</code> <code>index</code> <code>str | list[str] | None</code> <p>Column(s) to use as identifier variables.</p> <code>None</code> <code>variable_name</code> <code>str</code> <p>Name to give to the <code>variable</code> column. Defaults to \"variable\".</p> <code>'variable'</code> <code>value_name</code> <code>str</code> <p>Name to give to the <code>value</code> column. Defaults to \"value\".</p> <code>'value'</code> <p>Returns:</p> Type Description <code>Self</code> <p>The unpivoted LazyFrame.</p> Notes <p>If you're coming from pandas, this is similar to <code>pandas.DataFrame.melt</code>, but with <code>index</code> replacing <code>id_vars</code> and <code>on</code> replacing <code>value_vars</code>. In other frameworks, you might know this operation as <code>pivot_longer</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_native = duckdb.sql(\n...     \"SELECT * FROM VALUES ('x', 1, 2), ('y', 3, 4), ('z', 5, 6) df(a, b, c)\"\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n&gt;&gt;&gt; df.unpivot(on=[\"b\", \"c\"], index=\"a\").sort(\"a\", \"variable\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502 variable \u2502 value \u2502\n\u2502 varchar \u2502 varchar  \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502 b        \u2502     1 \u2502\n\u2502 x       \u2502 c        \u2502     2 \u2502\n\u2502 y       \u2502 b        \u2502     3 \u2502\n\u2502 y       \u2502 c        \u2502     4 \u2502\n\u2502 z       \u2502 b        \u2502     5 \u2502\n\u2502 z       \u2502 c        \u2502     6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_columns","title":"with_columns","text":"<pre><code>with_columns(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n    **named_exprs: IntoExpr\n) -&gt; Self\n</code></pre> <p>Add columns to this LazyFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>LazyFrame</code> <code>Self</code> <p>A new LazyFrame with the columns added.</p> Note <p>Creating a new LazyFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = duckdb.sql(\"SELECT * FROM VALUES (1, 4.5), (3, 2.) df(a, b)\")\n&gt;&gt;&gt; nw.from_native(lf_native).with_columns(c=nw.col(\"a\") + 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|       Narwhals LazyFrame       |\n|--------------------------------|\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502   a   \u2502      b       \u2502   c   \u2502|\n|\u2502 int32 \u2502 decimal(2,1) \u2502 int32 \u2502|\n|\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524|\n|\u2502     1 \u2502          4.5 \u2502     2 \u2502|\n|\u2502     3 \u2502          2.0 \u2502     4 \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_row_index","title":"with_row_index","text":"<pre><code>with_row_index(name: str = 'index') -&gt; Self\n</code></pre> <p>Insert column which enumerates rows.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the column as a string. The default is \"index\".</p> <code>'index'</code> <p>Returns:</p> Type Description <code>Self</code> <p>The original object with the column added.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_native = dd.from_dict({\"a\": [1, 2], \"b\": [4, 5]}, npartitions=1)\n&gt;&gt;&gt; nw.from_native(lf_native).with_row_index().collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|     index  a  b  |\n|  0      0  1  4  |\n|  1      1  2  5  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/","title":"Top-level functions","text":"<p>Here are the top-level functions available in Narwhals.</p>"},{"location":"api-reference/narwhals/#narwhals.all","title":"all","text":"<pre><code>all() -&gt; Expr\n</code></pre> <p>Instantiate an expression representing all columns.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [3.14, 0.123]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.all() * 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|      a      b    |\n|   0  2  6.280    |\n|   1  4  0.246    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.all_horizontal","title":"all_horizontal","text":"<pre><code>all_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Compute the bitwise AND horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_native = pa.table(data)\n&gt;&gt;&gt; nw.from_native(df_native).select(\"a\", \"b\", all=nw.all_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|           Narwhals DataFrame            |\n|-----------------------------------------|\n|pyarrow.Table                            |\n|a: bool                                  |\n|b: bool                                  |\n|all: bool                                |\n|----                                     |\n|a: [[false,false,true,true,false,null]]  |\n|b: [[false,true,true,null,null,null]]    |\n|all: [[false,false,true,null,false,null]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.any_horizontal","title":"any_horizontal","text":"<pre><code>any_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Compute the bitwise OR horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_native = pl.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).select(\"a\", \"b\", any=nw.any_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|shape: (6, 3)            |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a     \u2506 b     \u2506 any   \u2502|\n|\u2502 ---   \u2506 ---   \u2506 ---   \u2502|\n|\u2502 bool  \u2506 bool  \u2506 bool  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 false \u2506 false \u2506 false \u2502|\n|\u2502 false \u2506 true  \u2506 true  \u2502|\n|\u2502 true  \u2506 true  \u2506 true  \u2502|\n|\u2502 true  \u2506 null  \u2506 true  \u2502|\n|\u2502 false \u2506 null  \u2506 null  \u2502|\n|\u2502 null  \u2506 null  \u2506 null  \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.col","title":"col","text":"<pre><code>col(*names: str | Iterable[str]) -&gt; Expr\n</code></pre> <p>Creates an expression that references one or more columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to use.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4], \"c\": [\"x\", \"z\"]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.col(\"a\", \"b\") * nw.col(\"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 2)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510   |\n|  \u2502 a   \u2506 b   \u2502   |\n|  \u2502 --- \u2506 --- \u2502   |\n|  \u2502 i64 \u2506 i64 \u2502   |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561   |\n|  \u2502 3   \u2506 9   \u2502   |\n|  \u2502 8   \u2506 16  \u2502   |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat","title":"concat","text":"<pre><code>concat(\n    items: Iterable[FrameT],\n    *,\n    how: ConcatMethod = \"vertical\"\n) -&gt; FrameT\n</code></pre> <p>Concatenate multiple DataFrames, LazyFrames into a single entity.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Iterable[FrameT]</code> <p>DataFrames, LazyFrames to concatenate.</p> required <code>how</code> <code>ConcatMethod</code> <p>concatenating strategy</p> <ul> <li>vertical: Concatenate vertically. Column names must match.</li> <li>horizontal: Concatenate horizontally. If lengths don't match, then     missing rows are filled with null values. This is only supported     when all inputs are (eager) DataFrames.</li> <li>diagonal: Finds a union between the column schemas and fills missing column     values with null.</li> </ul> <code>'vertical'</code> <p>Returns:</p> Type Description <code>FrameT</code> <p>A new DataFrame or LazyFrame resulting from the concatenation.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>The items to concatenate should either all be eager, or all lazy</p> <p>Examples:</p> <p>Let's take an example of vertical concatenation:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n</code></pre> <p>Let's look at one case a for vertical concatenation (pandas backed):</p> <pre><code>&gt;&gt;&gt; df_pd_1 = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}))\n&gt;&gt;&gt; df_pd_2 = nw.from_native(pd.DataFrame({\"a\": [5, 2], \"b\": [1, 4]}))\n&gt;&gt;&gt; nw.concat([df_pd_1, df_pd_2], how=\"vertical\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a  b      |\n|     0  1  4      |\n|     1  2  5      |\n|     2  3  6      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Let's look at one case a for horizontal concatenation (polars backed):</p> <pre><code>&gt;&gt;&gt; df_pl_1 = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}))\n&gt;&gt;&gt; df_pl_2 = nw.from_native(pl.DataFrame({\"c\": [5, 2], \"d\": [1, 4]}))\n&gt;&gt;&gt; nw.concat([df_pl_1, df_pl_2], how=\"horizontal\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame     |\n|---------------------------|\n|shape: (3, 4)              |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b   \u2506 c    \u2506 d    \u2502|\n|\u2502 --- \u2506 --- \u2506 ---  \u2506 ---  \u2502|\n|\u2502 i64 \u2506 i64 \u2506 i64  \u2506 i64  \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 4   \u2506 5    \u2506 1    \u2502|\n|\u2502 2   \u2506 5   \u2506 2    \u2506 4    \u2502|\n|\u2502 3   \u2506 6   \u2506 null \u2506 null \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Let's look at one case a for diagonal concatenation (pyarrow backed):</p> <pre><code>&gt;&gt;&gt; df_pa_1 = nw.from_native(pa.table({\"a\": [1, 2], \"b\": [3.5, 4.5]}))\n&gt;&gt;&gt; df_pa_2 = nw.from_native(pa.table({\"a\": [3, 4], \"z\": [\"x\", \"y\"]}))\n&gt;&gt;&gt; nw.concat([df_pa_1, df_pa_2], how=\"diagonal\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals DataFrame    |\n|--------------------------|\n|pyarrow.Table             |\n|a: int64                  |\n|b: double                 |\n|z: string                 |\n|----                      |\n|a: [[1,2],[3,4]]          |\n|b: [[3.5,4.5],[null,null]]|\n|z: [[null,null],[\"x\",\"y\"]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat_str","title":"concat_str","text":"<pre><code>concat_str(\n    exprs: IntoExpr | Iterable[IntoExpr],\n    *more_exprs: IntoExpr,\n    separator: str = \"\",\n    ignore_nulls: bool = False\n) -&gt; Expr\n</code></pre> <p>Horizontally concatenate columns into a single string column.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Columns to concatenate into a single string column. Accepts expression input. Strings are parsed as column names, other non-expression inputs are parsed as literals. Non-<code>String</code> columns are cast to <code>String</code>.</p> required <code>*more_exprs</code> <code>IntoExpr</code> <p>Additional columns to concatenate into a single string column, specified as positional arguments.</p> <code>()</code> <code>separator</code> <code>str</code> <p>String that will be used to separate the values of each column.</p> <code>''</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore null values (default is <code>False</code>). If set to <code>False</code>, null values will be propagated and if the row contains any null values, the output is null.</p> <code>False</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3],\n...     \"b\": [\"dogs\", \"cats\", None],\n...     \"c\": [\"play\", \"swim\", \"walk\"],\n... }\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; (\n...     nw.from_native(df_native).select(\n...         nw.concat_str(\n...             [nw.col(\"a\") * 2, nw.col(\"b\"), nw.col(\"c\")], separator=\" \"\n...         ).alias(\"full_sentence\")\n...     )\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   full_sentence  |\n| 0   2 dogs play  |\n| 1   4 cats swim  |\n| 2          None  |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.exclude","title":"exclude","text":"<pre><code>exclude(*names: str | Iterable[str]) -&gt; Expr\n</code></pre> <p>Creates an expression that excludes columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to exclude.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4], \"c\": [\"x\", \"z\"]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.exclude(\"c\", \"a\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 b   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 i64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 3   \u2502         |\n|  \u2502 4   \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_arrow","title":"from_arrow","text":"<pre><code>from_arrow(\n    native_frame: IntoArrowTable,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from an object which supports the PyCapsule Interface.</p> <p>Parameters:</p> Name Type Description Default <code>native_frame</code> <code>IntoArrowTable</code> <p>Object which implements <code>__arrow_c_stream__</code>.</p> required <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A new DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [4.2, 5.1]})\n&gt;&gt;&gt; nw.from_arrow(df_native, backend=\"polars\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 2)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510   |\n|  \u2502 a   \u2506 b   \u2502   |\n|  \u2502 --- \u2506 --- \u2502   |\n|  \u2502 i64 \u2506 f64 \u2502   |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561   |\n|  \u2502 1   \u2506 4.2 \u2502   |\n|  \u2502 2   \u2506 5.1 \u2502   |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_dict","title":"from_dict","text":"<pre><code>from_dict(\n    data: Mapping[str, Any],\n    schema: Mapping[str, DType] | Schema | None = None,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None\n) -&gt; DataFrame[Any]\n</code></pre> <p>Instantiate DataFrame from dictionary.</p> <p>Indexes (if present, for pandas-like backends) are aligned following the left-hand-rule.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mapping[str, Any]</code> <p>Dictionary to create DataFrame from.</p> required <code>schema</code> <code>Mapping[str, DType] | Schema | None</code> <p>The DataFrame schema as Schema or dict of {name: type}. If not specified, the schema will be inferred by the native library.</p> <code>None</code> <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>specifies which eager backend instantiate to. Only necessary if inputs are not Narwhals Series.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.26.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A new DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"c\": [5, 2], \"d\": [1, 4]}\n&gt;&gt;&gt; nw.from_dict(data, backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        c  d      |\n|     0  5  1      |\n|     1  2  4      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_native","title":"from_native","text":"<pre><code>from_native(native_object: SeriesT, **kwds: Any) -&gt; SeriesT\n</code></pre><pre><code>from_native(\n    native_object: DataFrameT, **kwds: Any\n) -&gt; DataFrameT\n</code></pre><pre><code>from_native(\n    native_object: LazyFrameT, **kwds: Any\n) -&gt; LazyFrameT\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT | IntoSeriesT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; DataFrame[IntoDataFrameT] | Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: T,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; T\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: T,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; T\n</code></pre><pre><code>from_native(\n    native_object: (\n        IntoFrameT | IntoLazyFrameT | IntoSeriesT\n    ),\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; (\n    DataFrame[IntoFrameT]\n    | LazyFrame[IntoLazyFrameT]\n    | Series[IntoSeriesT]\n)\n</code></pre><pre><code>from_native(\n    native_object: IntoSeriesT,\n    *,\n    pass_through: Literal[True],\n    eager_only: Literal[False] = ...,\n    series_only: Literal[True],\n    allow_series: None = ...\n) -&gt; Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: IntoLazyFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; LazyFrame[IntoLazyFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoDataFrameT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[True],\n    series_only: Literal[False] = ...,\n    allow_series: None = ...\n) -&gt; DataFrame[IntoDataFrameT]\n</code></pre><pre><code>from_native(\n    native_object: IntoFrame | IntoSeries,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[False] = ...,\n    allow_series: Literal[True]\n) -&gt; DataFrame[Any] | LazyFrame[Any] | Series[Any]\n</code></pre><pre><code>from_native(\n    native_object: IntoSeriesT,\n    *,\n    pass_through: Literal[False] = ...,\n    eager_only: Literal[False] = ...,\n    series_only: Literal[True],\n    allow_series: None = ...\n) -&gt; Series[IntoSeriesT]\n</code></pre><pre><code>from_native(\n    native_object: Any,\n    *,\n    pass_through: bool,\n    eager_only: bool,\n    series_only: bool,\n    allow_series: bool | None\n) -&gt; Any\n</code></pre> <pre><code>from_native(\n    native_object: (\n        IntoLazyFrameT\n        | IntoFrameT\n        | IntoSeriesT\n        | IntoFrame\n        | IntoSeries\n        | T\n    ),\n    *,\n    strict: bool | None = None,\n    pass_through: bool | None = None,\n    eager_only: bool = False,\n    series_only: bool = False,\n    allow_series: bool | None = None,\n    **kwds: Any\n) -&gt; (\n    LazyFrame[IntoLazyFrameT]\n    | DataFrame[IntoFrameT]\n    | Series[IntoSeriesT]\n    | T\n)\n</code></pre> <p>Convert <code>native_object</code> to Narwhals Dataframe, Lazyframe, or Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_object</code> <code>IntoLazyFrameT | IntoFrameT | IntoSeriesT | IntoFrame | IntoSeries | T</code> <p>Raw object from user. Depending on the other arguments, input object can be</p> <ul> <li>a Dataframe / Lazyframe / Series supported by Narwhals (pandas, Polars, PyArrow, ...)</li> <li>an object which implements <code>__narwhals_dataframe__</code>, <code>__narwhals_lazyframe__</code>,   or <code>__narwhals_series__</code></li> </ul> required <code>strict</code> <code>bool | None</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <ul> <li><code>True</code> or <code>None</code> (default): raise an error</li> <li><code>False</code>: pass object through as-is</li> </ul> <p>Deprecated (v1.13.0)</p> <p>Please use <code>pass_through</code> instead. Note that <code>strict</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>pass_through</code> <code>bool | None</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <ul> <li><code>False</code> or <code>None</code> (default): raise an error</li> <li><code>True</code>: pass object through as-is</li> </ul> <code>None</code> <code>eager_only</code> <code>bool</code> <p>Whether to only allow eager objects</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be eager</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is eager</li> </ul> <code>False</code> <code>series_only</code> <code>bool</code> <p>Whether to only allow Series</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be a Series</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is a Series</li> </ul> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow Series (default is only Dataframe / Lazyframe)</p> <ul> <li><code>False</code> or <code>None</code> (default): don't convert to Narwhals if <code>native_object</code> is a Series</li> <li><code>True</code>: allow <code>native_object</code> to be a Series</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>LazyFrame[IntoLazyFrameT] | DataFrame[IntoFrameT] | Series[IntoSeriesT] | T</code> <p>DataFrame, LazyFrame, Series, or original object, depending on which combination of parameters was passed.</p>"},{"location":"api-reference/narwhals/#narwhals.from_numpy","title":"from_numpy","text":"<pre><code>from_numpy(\n    data: _2DArray,\n    schema: (\n        Mapping[str, DType] | Schema | Sequence[str] | None\n    ) = None,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None\n) -&gt; DataFrame[Any]\n</code></pre> <p>Construct a DataFrame from a NumPy ndarray.</p> Notes <p>Only row orientation is currently supported.</p> <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_2DArray</code> <p>Two-dimensional data represented as a NumPy ndarray.</p> required <code>schema</code> <code>Mapping[str, DType] | Schema | Sequence[str] | None</code> <p>The DataFrame schema as Schema, dict of {name: type}, or a sequence of str.</p> <code>None</code> <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A new DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; arr = np.array([[5, 2, 1], [1, 4, 3]])\n&gt;&gt;&gt; schema = {\"c\": nw.Int16(), \"d\": nw.Float32(), \"e\": nw.Int8()}\n&gt;&gt;&gt; nw.from_numpy(arr, schema=schema, backend=\"pyarrow\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  c: int16        |\n|  d: float        |\n|  e: int8         |\n|  ----            |\n|  c: [[5,1]]      |\n|  d: [[2,4]]      |\n|  e: [[1,3]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.generate_temporary_column_name","title":"generate_temporary_column_name","text":"<pre><code>generate_temporary_column_name(\n    n_bytes: int, columns: Sequence[str]\n) -&gt; str\n</code></pre> <p>Generates a unique column name that is not present in the given list of columns.</p> <p>It relies on python secrets token_hex function to return a string nbytes random bytes.</p> <p>Parameters:</p> Name Type Description Default <code>n_bytes</code> <code>int</code> <p>The number of bytes to generate for the token.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to check for uniqueness.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A unique token that is not present in the given list of columns.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a unique token cannot be generated after 100 attempts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; columns = [\"abc\", \"xyz\"]\n&gt;&gt;&gt; nw.generate_temporary_column_name(n_bytes=8, columns=columns) not in columns\nTrue\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.get_level","title":"get_level","text":"<pre><code>get_level(\n    obj: (\n        DataFrame[Any]\n        | LazyFrame[Any]\n        | Series[IntoSeriesT]\n    ),\n) -&gt; Literal[\"full\", \"lazy\", \"interchange\"]\n</code></pre> <p>Level of support Narwhals has for current object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>DataFrame[Any] | LazyFrame[Any] | Series[IntoSeriesT]</code> <p>Dataframe or Series.</p> required <p>Returns:</p> Type Description <code>Literal['full', 'lazy', 'interchange']</code> <p>This can be one of</p> <ul> <li>'full': full Narwhals API support</li> <li>'lazy': only lazy operations are supported. This excludes anything   which involves iterating over rows in Python.</li> <li>'interchange': only metadata operations are supported (<code>df.schema</code>)</li> </ul>"},{"location":"api-reference/narwhals/#narwhals.get_native_namespace","title":"get_native_namespace","text":"<pre><code>get_native_namespace(\n    *obj: DataFrame[Any]\n    | LazyFrame[Any]\n    | Series[Any]\n    | IntoFrame\n    | IntoSeries,\n) -&gt; Any\n</code></pre> <p>Get native namespace from object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>DataFrame[Any] | LazyFrame[Any] | Series[Any] | IntoFrame | IntoSeries</code> <p>Dataframe, Lazyframe, or Series. Multiple objects can be passed positionally, in which case they must all have the same native namespace (else an error is raised).</p> <code>()</code> <p>Returns:</p> Type Description <code>Any</code> <p>Native module.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'pandas'...&gt;\n&gt;&gt;&gt; df = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'polars'...&gt;\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.is_ordered_categorical","title":"is_ordered_categorical","text":"<pre><code>is_ordered_categorical(series: Series[Any]) -&gt; bool\n</code></pre> <p>Return whether indices of categories are semantically meaningful.</p> <p>This is a convenience function to accessing what would otherwise be the <code>is_ordered</code> property from the DataFrame Interchange Protocol, see https://data-apis.org/dataframe-protocol/latest/API.html.</p> <ul> <li>For Polars:</li> <li>Enums are always ordered.</li> <li>Categoricals are ordered if <code>dtype.ordering == \"physical\"</code>.</li> <li>For pandas-like APIs:</li> <li>Categoricals are ordered if <code>dtype.cat.ordered == True</code>.</li> <li>For PyArrow table:</li> <li>Categoricals are ordered if <code>dtype.type.ordered == True</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series[Any]</code> <p>Input Series.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the Series is an ordered categorical.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [\"x\", \"y\"]\n&gt;&gt;&gt; s_pd = pd.Series(data, dtype=pd.CategoricalDtype(ordered=True))\n&gt;&gt;&gt; s_pl = pl.Series(data, dtype=pl.Categorical(ordering=\"physical\"))\n</code></pre> <p>Let's define a library-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return nw.is_ordered_categorical(s)\n</code></pre> <p>Then, we can pass any supported library to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nTrue\n&gt;&gt;&gt; func(s_pl)\nTrue\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.len","title":"len","text":"<pre><code>len() -&gt; Expr\n</code></pre> <p>Return the number of rows.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.len())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (1, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 len \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 u32 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 2   \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.lit","title":"lit","text":"<pre><code>lit(\n    value: NonNestedLiteral,\n    dtype: DType | type[DType] | None = None,\n) -&gt; Expr\n</code></pre> <p>Return an expression representing a literal value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NonNestedLiteral</code> <p>The value to use as literal.</p> required <code>dtype</code> <code>DType | type[DType] | None</code> <p>The data type of the literal value. If not provided, the data type will be inferred by the native library.</p> <code>None</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(nw.lit(3))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|     a  literal   |\n|  0  1        3   |\n|  1  2        3   |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max","title":"max","text":"<pre><code>max(*columns: str) -&gt; Expr\n</code></pre> <p>Return the maximum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).max()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.max(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  2  10     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max_horizontal","title":"max_horizontal","text":"<pre><code>max_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Get the maximum value horizontally across columns.</p> Notes <p>We support <code>max_horizontal</code> over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 8, 3], \"b\": [4, 5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(h_max=nw.max_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|  Narwhals DataFrame  |\n|----------------------|\n|shape: (3, 3)         |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b    \u2506 h_max \u2502|\n|\u2502 --- \u2506 ---  \u2506 ---   \u2502|\n|\u2502 i64 \u2506 i64  \u2506 i64   \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 4    \u2506 4     \u2502|\n|\u2502 8   \u2506 5    \u2506 8     \u2502|\n|\u2502 3   \u2506 null \u2506 3     \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_align_index","title":"maybe_align_index","text":"<pre><code>maybe_align_index(\n    lhs: FrameOrSeriesT,\n    rhs: Series[Any] | DataFrame[Any] | LazyFrame[Any],\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Align <code>lhs</code> to the Index of <code>rhs</code>, if they're both pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>FrameOrSeriesT</code> <p>Dataframe or Series.</p> required <code>rhs</code> <code>Series[Any] | DataFrame[Any] | LazyFrame[Any]</code> <p>Dataframe or Series to align with.</p> required <p>Returns:</p> Type Description <code>FrameOrSeriesT</code> <p>Same type as input.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this only checks that <code>lhs</code> and <code>rhs</code> are the same length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]}, index=[3, 4])\n&gt;&gt;&gt; s_pd = pd.Series([6, 7], index=[4, 3])\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; s = nw.from_native(s_pd, series_only=True)\n&gt;&gt;&gt; nw.to_native(nw.maybe_align_index(df, s))\n   a\n4  2\n3  1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_convert_dtypes","title":"maybe_convert_dtypes","text":"<pre><code>maybe_convert_dtypes(\n    obj: FrameOrSeriesT, *args: bool, **kwargs: bool | str\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Convert columns or series to the best possible dtypes using dtypes supporting <code>pd.NA</code>, if df is pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>DataFrame or Series.</p> required <code>*args</code> <code>bool</code> <p>Additional arguments which gets passed through.</p> <code>()</code> <code>**kwargs</code> <code>bool | str</code> <p>Additional arguments which gets passed through.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FrameOrSeriesT</code> <p>Same type as input.</p> Notes <p>For non-pandas-like inputs, this is a no-op. Also, <code>args</code> and <code>kwargs</code> just get passed down to the underlying library as-is.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(\n...     nw.maybe_convert_dtypes(df)\n... ).dtypes\na             Int32\nb           boolean\ndtype: object\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_get_index","title":"maybe_get_index","text":"<pre><code>maybe_get_index(\n    obj: DataFrame[Any] | LazyFrame[Any] | Series[Any],\n) -&gt; Any | None\n</code></pre> <p>Get the index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>DataFrame[Any] | LazyFrame[Any] | Series[Any]</code> <p>Dataframe or Series.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>Same type as input.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.maybe_get_index(df)\nRangeIndex(start=0, stop=2, step=1)\n&gt;&gt;&gt; series_pd = pd.Series([1, 2])\n&gt;&gt;&gt; series = nw.from_native(series_pd, series_only=True)\n&gt;&gt;&gt; nw.maybe_get_index(series)\nRangeIndex(start=0, stop=2, step=1)\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_reset_index","title":"maybe_reset_index","text":"<pre><code>maybe_reset_index(obj: FrameOrSeriesT) -&gt; FrameOrSeriesT\n</code></pre> <p>Reset the index to the default integer index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>Dataframe or Series.</p> required <p>Returns:</p> Type Description <code>FrameOrSeriesT</code> <p>Same type as input.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already resets the index for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]}, index=([6, 7]))\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_reset_index(df))\n   a  b\n0  1  4\n1  2  5\n&gt;&gt;&gt; series_pd = pd.Series([1, 2])\n&gt;&gt;&gt; series = nw.from_native(series_pd, series_only=True)\n&gt;&gt;&gt; nw.maybe_get_index(series)\nRangeIndex(start=0, stop=2, step=1)\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_set_index","title":"maybe_set_index","text":"<pre><code>maybe_set_index(\n    obj: FrameOrSeriesT,\n    column_names: str | list[str] | None = None,\n    *,\n    index: (\n        Series[IntoSeriesT]\n        | list[Series[IntoSeriesT]]\n        | None\n    ) = None\n) -&gt; FrameOrSeriesT\n</code></pre> <p>Set the index of a DataFrame or a Series, if it's pandas-like.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>FrameOrSeriesT</code> <p>object for which maybe set the index (can be either a Narwhals <code>DataFrame</code> or <code>Series</code>).</p> required <code>column_names</code> <code>str | list[str] | None</code> <p>name or list of names of the columns to set as index. For dataframes, only one of <code>column_names</code> and <code>index</code> can be specified but not both. If <code>column_names</code> is passed and <code>df</code> is a Series, then a <code>ValueError</code> is raised.</p> <code>None</code> <code>index</code> <code>Series[IntoSeriesT] | list[Series[IntoSeriesT]] | None</code> <p>series or list of series to set as index.</p> <code>None</code> <p>Returns:</p> Type Description <code>FrameOrSeriesT</code> <p>Same type as input.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If one of the following conditions happens</p> <ul> <li>none of <code>column_names</code> and <code>index</code> are provided</li> <li>both <code>column_names</code> and <code>index</code> are provided</li> <li><code>column_names</code> is provided and <code>df</code> is a Series</li> </ul> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index.</p> <p>For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_set_index(df, \"b\"))\n   a\nb\n4  1\n5  2\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean","title":"mean","text":"<pre><code>mean(*columns: str) -&gt; Expr\n</code></pre> <p>Get the mean value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).mean()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 8, 3], \"b\": [3.14, 6.28, 42.1]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.mean(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|pyarrow.Table            |\n|a: double                |\n|b: double                |\n|----                     |\n|a: [[4]]                 |\n|b: [[17.173333333333336]]|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean_horizontal","title":"mean_horizontal","text":"<pre><code>mean_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Compute the mean of all values horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 8, 3], \"b\": [4, 5, None], \"c\": [\"x\", \"y\", \"z\"]}\n&gt;&gt;&gt; df_native = pa.table(data)\n</code></pre> <p>We define a dataframe-agnostic function that computes the horizontal mean of \"a\" and \"b\" columns:</p> <pre><code>&gt;&gt;&gt; nw.from_native(df_native).select(nw.mean_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| pyarrow.Table    |\n| a: double        |\n| ----             |\n| a: [[2.5,6.5,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.median","title":"median","text":"<pre><code>median(*columns: str) -&gt; Expr\n</code></pre> <p>Get the median value.</p> Notes <ul> <li>Syntactic sugar for <code>nw.col(columns).median()</code></li> <li>Results might slightly differ across backends due to differences in the     underlying algorithms used to compute the median.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [4, 5, 2]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.median(\"a\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (1, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2510         |\n|  \u2502 a   \u2502         |\n|  \u2502 --- \u2502         |\n|  \u2502 f64 \u2502         |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2561         |\n|  \u2502 4.0 \u2502         |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2518         |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min","title":"min","text":"<pre><code>min(*columns: str) -&gt; Expr\n</code></pre> <p>Return the minimum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).min()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.min(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: int64        |\n|  ----            |\n|  a: [[1]]        |\n|  b: [[5]]        |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min_horizontal","title":"min_horizontal","text":"<pre><code>min_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Get the minimum value horizontally across columns.</p> Notes <p>We support <code>min_horizontal</code> over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 8, 3], \"b\": [4, 5, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(h_min=nw.min_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n| pyarrow.Table    |\n| a: int64         |\n| b: int64         |\n| h_min: int64     |\n| ----             |\n| a: [[1,8,3]]     |\n| b: [[4,5,null]]  |\n| h_min: [[1,5,3]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.narwhalify","title":"narwhalify","text":"<pre><code>narwhalify(\n    func: Callable[..., Any] | None = None,\n    *,\n    strict: bool | None = None,\n    pass_through: bool | None = None,\n    eager_only: bool = False,\n    series_only: bool = False,\n    allow_series: bool | None = True\n) -&gt; Callable[..., Any]\n</code></pre> <p>Decorate function so it becomes dataframe-agnostic.</p> <p>This will try to convert any dataframe/series-like object into the Narwhals respective DataFrame/Series, while leaving the other parameters as they are. Similarly, if the output of the function is a Narwhals DataFrame or Series, it will be converted back to the original dataframe/series type, while if the output is another type it will be left as is. By setting <code>pass_through=False</code>, then every input and every output will be required to be a dataframe/series-like object.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to wrap in a <code>from_native</code>-<code>to_native</code> block.</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <p>Deprecated (v1.13.0)</p> <p>Please use <code>pass_through</code> instead. Note that <code>strict</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <ul> <li><code>True</code> or <code>None</code> (default): raise an error</li> <li><code>False</code>: pass object through as-is</li> </ul> <code>None</code> <code>pass_through</code> <code>bool | None</code> <p>Determine what happens if the object can't be converted to Narwhals</p> <ul> <li><code>False</code> or <code>None</code> (default): raise an error</li> <li><code>True</code>: pass object through as-is</li> </ul> <code>None</code> <code>eager_only</code> <code>bool</code> <p>Whether to only allow eager objects</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be eager</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is eager</li> </ul> <code>False</code> <code>series_only</code> <code>bool</code> <p>Whether to only allow Series</p> <ul> <li><code>False</code> (default): don't require <code>native_object</code> to be a Series</li> <li><code>True</code>: only convert to Narwhals if <code>native_object</code> is a Series</li> </ul> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow Series (default is only Dataframe / Lazyframe)</p> <ul> <li><code>False</code> or <code>None</code>: don't convert to Narwhals if <code>native_object</code> is a Series</li> <li><code>True</code> (default): allow <code>native_object</code> to be a Series</li> </ul> <code>True</code> <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>Decorated function.</p> <p>Examples:</p> <p>Instead of writing</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; def agnostic_group_by_sum(df):\n...     df = nw.from_native(df, pass_through=True)\n...     df = df.group_by(\"a\").agg(nw.col(\"b\").sum())\n...     return nw.to_native(df)\n</code></pre> <p>you can just write</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_group_by_sum(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum())\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.new_series","title":"new_series","text":"<pre><code>new_series(\n    name: str,\n    values: Any,\n    dtype: DType | type[DType] | None = None,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None\n) -&gt; Series[Any]\n</code></pre> <p>Instantiate Narwhals Series from iterable (e.g. list or array).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting Series.</p> required <code>values</code> <code>Any</code> <p>Values of make Series from.</p> required <code>dtype</code> <code>DType | type[DType] | None</code> <p>(Narwhals) dtype. If not provided, the native library may auto-infer it from <code>values</code>.</p> <code>None</code> <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>specifies which eager backend instantiate to.</p> <p><code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>A new Series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; values = [4, 1, 2, 3]\n&gt;&gt;&gt; nw.new_series(name=\"a\", values=values, dtype=nw.Int32, backend=pd)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals Series   |\n|---------------------|\n|0    4               |\n|1    1               |\n|2    2               |\n|3    3               |\n|Name: a, dtype: int32|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.nth","title":"nth","text":"<pre><code>nth(*indices: int | Sequence[int]) -&gt; Expr\n</code></pre> <p>Creates an expression that references one or more columns by their index(es).</p> Notes <p><code>nth</code> is not supported for Polars version&lt;1.0.0. Please use <code>narwhals.col</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>int | Sequence[int]</code> <p>One or more indices representing the columns to retrieve.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [3, 4], \"c\": [0.123, 3.14]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.nth(0, 2) * 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|c: double         |\n|----              |\n|a: [[2,4]]        |\n|c: [[0.246,6.28]] |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.read_csv","title":"read_csv","text":"<pre><code>read_csv(\n    source: str,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None,\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Read a CSV file into a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to a file.</p> required <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.27.2)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native CSV reader. For example, you could use <code>nw.read_csv('file.csv', backend='pandas', engine='pyarrow')</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; nw.read_csv(\"file.csv\", backend=\"pandas\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  1   4     |\n|     1  2   5     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.read_parquet","title":"read_parquet","text":"<pre><code>read_parquet(\n    source: str,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None,\n    **kwargs: Any\n) -&gt; DataFrame[Any]\n</code></pre> <p>Read into a DataFrame from a parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to a file.</p> required <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native parquet reader. For example, you could use <code>nw.read_parquet('file.parquet', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.read_parquet(\"file.parquet\", backend=\"pyarrow\")\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|pyarrow.Table     |\n|a: int64          |\n|c: double         |\n|----              |\n|a: [[1,2]]        |\n|c: [[0.2,0.1]]    |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.scan_csv","title":"scan_csv","text":"<pre><code>scan_csv(\n    source: str,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None,\n    **kwargs: Any\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Lazily read from a CSV file.</p> <p>For the libraries that do not support lazy dataframes, the function reads a csv file eagerly and then converts the resulting dataframe to a lazyframe.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to a file.</p> required <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code> or <code>CUDF</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code> or <code>\"cudf\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code> or <code>cudf</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native CSV reader. For example, you could use <code>nw.scan_csv('file.csv', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LazyFrame[Any]</code> <p>LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import duckdb\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.scan_csv(\"file.csv\", backend=\"duckdb\").to_native()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    a    \u2502   b   \u2502\n\u2502 varchar \u2502 int32 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 x       \u2502     1 \u2502\n\u2502 y       \u2502     2 \u2502\n\u2502 z       \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.scan_parquet","title":"scan_parquet","text":"<pre><code>scan_parquet(\n    source: str,\n    *,\n    backend: (\n        ModuleType | Implementation | str | None\n    ) = None,\n    native_namespace: ModuleType | None = None,\n    **kwargs: Any\n) -&gt; LazyFrame[Any]\n</code></pre> <p>Lazily read from a parquet file.</p> <p>For the libraries that do not support lazy dataframes, the function reads a parquet file eagerly and then converts the resulting dataframe to a lazyframe.</p> Note <p>Spark like backends require a session object to be passed in <code>kwargs</code>.</p> <p>For instance:</p> <pre><code>import narwhals as nw\nfrom sqlframe.duckdb import DuckDBSession\n\nnw.scan_parquet(source, backend=\"sqlframe\", session=DuckDBSession())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to a file.</p> required <code>backend</code> <code>ModuleType | Implementation | str | None</code> <p>The eager backend for DataFrame creation. <code>backend</code> can be specified in various ways</p> <ul> <li>As <code>Implementation.&lt;BACKEND&gt;</code> with <code>BACKEND</code> being <code>PANDAS</code>, <code>PYARROW</code>,     <code>POLARS</code>, <code>MODIN</code>, <code>CUDF</code>, <code>PYSPARK</code> or <code>SQLFRAME</code>.</li> <li>As a string: <code>\"pandas\"</code>, <code>\"pyarrow\"</code>, <code>\"polars\"</code>, <code>\"modin\"</code>, <code>\"cudf\"</code>,     <code>\"pyspark\"</code> or <code>\"sqlframe\"</code>.</li> <li>Directly as a module <code>pandas</code>, <code>pyarrow</code>, <code>polars</code>, <code>modin</code>, <code>cudf</code>,     <code>pyspark.sql</code> or <code>sqlframe</code>.</li> </ul> <code>None</code> <code>native_namespace</code> <code>ModuleType | None</code> <p>The native library to use for DataFrame creation.</p> <p>Deprecated (v1.31.0)</p> <p>Please use <code>backend</code> instead. Note that <code>native_namespace</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Extra keyword arguments which are passed to the native parquet reader. For example, you could use <code>nw.scan_parquet('file.parquet', backend=pd, engine='pyarrow')</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>LazyFrame[Any]</code> <p>LazyFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; from sqlframe.duckdb import DuckDBSession\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.scan_parquet(\"file.parquet\", backend=\"dask\").collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|        a   b     |\n|     0  1   4     |\n|     1  2   5     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; nw.scan_parquet(\n...     \"file.parquet\", backend=\"sqlframe\", session=DuckDBSession()\n... ).collect()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  pyarrow.Table   |\n|  a: int64        |\n|  b: int64        |\n|  ----            |\n|  a: [[1,2]]      |\n|  b: [[4,5]]      |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum","title":"sum","text":"<pre><code>sum(*columns: str) -&gt; Expr\n</code></pre> <p>Sum all values.</p> Note <p>Syntactic sugar for <code>nw.col(columns).sum()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pd.DataFrame({\"a\": [1, 2], \"b\": [-1.4, 6.2]})\n&gt;&gt;&gt; nw.from_native(df_native).select(nw.sum(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|       a    b     |\n|    0  3  4.8     |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum_horizontal","title":"sum_horizontal","text":"<pre><code>sum_horizontal(\n    *exprs: IntoExpr | Iterable[IntoExpr],\n) -&gt; Expr\n</code></pre> <p>Sum all values horizontally across columns.</p> Warning <p>Unlike Polars, we support horizontal sum over numeric columns only.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Returns:</p> Type Description <code>Expr</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, None]})\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(sum=nw.sum_horizontal(\"a\", \"b\"))\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|shape: (3, 3)       |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 b    \u2506 sum \u2502|\n|\u2502 --- \u2506 ---  \u2506 --- \u2502|\n|\u2502 i64 \u2506 i64  \u2506 i64 \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 5    \u2506 6   \u2502|\n|\u2502 2   \u2506 10   \u2506 12  \u2502|\n|\u2502 3   \u2506 null \u2506 3   \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.show_versions","title":"show_versions","text":"<pre><code>show_versions() -&gt; None\n</code></pre> <p>Print useful debugging information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from narwhals import show_versions\n&gt;&gt;&gt; show_versions()\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.to_native","title":"to_native","text":"<pre><code>to_native(\n    narwhals_object: DataFrame[IntoDataFrameT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoDataFrameT\n</code></pre><pre><code>to_native(\n    narwhals_object: LazyFrame[IntoFrameT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoFrameT\n</code></pre><pre><code>to_native(\n    narwhals_object: Series[IntoSeriesT],\n    *,\n    pass_through: Literal[False] = ...\n) -&gt; IntoSeriesT\n</code></pre><pre><code>to_native(\n    narwhals_object: Any, *, pass_through: bool\n) -&gt; Any\n</code></pre> <pre><code>to_native(\n    narwhals_object: (\n        DataFrame[IntoDataFrameT]\n        | LazyFrame[IntoFrameT]\n        | Series[IntoSeriesT]\n    ),\n    *,\n    strict: bool | None = None,\n    pass_through: bool | None = None\n) -&gt; IntoDataFrameT | IntoFrameT | IntoSeriesT | Any\n</code></pre> <p>Convert Narwhals object to native one.</p> <p>Parameters:</p> Name Type Description Default <code>narwhals_object</code> <code>DataFrame[IntoDataFrameT] | LazyFrame[IntoFrameT] | Series[IntoSeriesT]</code> <p>Narwhals object.</p> required <code>strict</code> <code>bool | None</code> <p>Determine what happens if <code>narwhals_object</code> isn't a Narwhals class</p> <ul> <li><code>True</code> (default): raise an error</li> <li><code>False</code>: pass object through as-is</li> </ul> <p>Deprecated (v1.13.0)</p> <p>Please use <code>pass_through</code> instead. Note that <code>strict</code> is still available (and won't emit a deprecation warning) if you use <code>narwhals.stable.v1</code>, see perfect backwards compatibility policy.</p> <code>None</code> <code>pass_through</code> <code>bool | None</code> <p>Determine what happens if <code>narwhals_object</code> isn't a Narwhals class</p> <ul> <li><code>False</code> (default): raise an error</li> <li><code>True</code>: pass object through as-is</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>IntoDataFrameT | IntoFrameT | IntoSeriesT | Any</code> <p>Object of class that user started with.</p>"},{"location":"api-reference/narwhals/#narwhals.to_py_scalar","title":"to_py_scalar","text":"<pre><code>to_py_scalar(scalar_like: Any) -&gt; Any\n</code></pre> <p>If a scalar is not Python native, converts it to Python native.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_like</code> <code>Any</code> <p>Scalar-like value.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Python scalar.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the object is not convertible to a scalar.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.to_py_scalar(df[\"a\"].item(0))\n1\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; df = nw.from_native(pa.table({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.to_py_scalar(df[\"a\"].item(0))\n1\n&gt;&gt;&gt; nw.to_py_scalar(1)\n1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.when","title":"when","text":"<pre><code>when(*predicates: IntoExpr | Iterable[IntoExpr]) -&gt; When\n</code></pre> <p>Start a <code>when-then-otherwise</code> expression.</p> <p>Expression similar to an <code>if-else</code> statement in Python. Always initiated by a <code>pl.when(&lt;condition&gt;).then(&lt;value if condition&gt;)</code>, and optionally followed by a <code>.otherwise(&lt;value if condition is false&gt;)</code> can be appended at the end. If not appended, and the condition is not <code>True</code>, <code>None</code> will be returned.</p> Info <p>Chaining multiple <code>.when(&lt;condition&gt;).then(&lt;value&gt;)</code> statements is currently not supported. See Narwhals#668.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Condition(s) that must be met in order to apply the subsequent statement. Accepts one or more boolean expressions, which are implicitly combined with <code>&amp;</code>. String input is parsed as a column name.</p> <code>()</code> <p>Returns:</p> Type Description <code>When</code> <p>A \"when\" object, which <code>.then</code> can be called on.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [5, 10, 15]}\n&gt;&gt;&gt; df_native = pd.DataFrame(data)\n&gt;&gt;&gt; nw.from_native(df_native).with_columns(\n...     nw.when(nw.col(\"a\") &lt; 3).then(5).otherwise(6).alias(\"a_when\")\n... )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|    a   b  a_when |\n| 0  1   5       5 |\n| 1  2  10       5 |\n| 2  3  15       6 |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/schema/","title":"<code>narwhals.Schema</code>","text":"<p>Ordered mapping of column names to their data type.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Mapping[str, DType] | Iterable[tuple[str, DType]] | None</code> <p>The schema definition given by column names and their associated instantiated Narwhals data type. Accepts a mapping or an iterable of tuples.</p> <code>None</code> <p>Examples:</p> <p>Define a schema by passing instantiated data types.</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"foo\": nw.Int8(), \"bar\": nw.String()})\n&gt;&gt;&gt; schema\nSchema({'foo': Int8, 'bar': String})\n</code></pre> <p>Access the data type associated with a specific column name.</p> <pre><code>&gt;&gt;&gt; schema[\"foo\"]\nInt8\n</code></pre> <p>Access various schema properties using the <code>names</code>, <code>dtypes</code>, and <code>len</code> methods.</p> <pre><code>&gt;&gt;&gt; schema.names()\n['foo', 'bar']\n&gt;&gt;&gt; schema.dtypes()\n[Int8, String]\n&gt;&gt;&gt; schema.len()\n2\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.names","title":"names","text":"<pre><code>names() -&gt; list[str]\n</code></pre> <p>Get the column names of the schema.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Column names.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.dtypes","title":"dtypes","text":"<pre><code>dtypes() -&gt; list[DType]\n</code></pre> <p>Get the data types of the schema.</p> <p>Returns:</p> Type Description <code>list[DType]</code> <p>Data types of schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.len","title":"len","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of columns in the schema.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of columns.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Schema\n</code></pre> <p>Convert Schema to a pyarrow Schema.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A pyarrow Schema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_arrow()\na: int64\nb: timestamp[ns]\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas(\n    dtype_backend: (\n        DTypeBackend | Iterable[DTypeBackend]\n    ) = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert Schema to an ordered mapping of column names to their pandas data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype_backend</code> <code>DTypeBackend | Iterable[DTypeBackend]</code> <p>Backend(s) used for the native types. When providing more than one, the length of the iterable must be equal to the length of the schema.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>An ordered mapping of column names to their pandas data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_pandas()\n{'a': 'int64', 'b': 'datetime64[ns]'}\n</code></pre> <pre><code>&gt;&gt;&gt; schema.to_pandas(\"pyarrow\")\n{'a': 'Int64[pyarrow]', 'b': 'timestamp[ns][pyarrow]'}\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.Schema\n</code></pre> <p>Convert Schema to a polars Schema.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>A polars Schema or plain dict (prior to polars 1.0).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"a\": nw.Int64(), \"b\": nw.Datetime(\"ns\")})\n&gt;&gt;&gt; schema.to_polars()\nSchema({'a': Int64, 'b': Datetime(time_unit='ns', time_zone=None)})\n</code></pre>"},{"location":"api-reference/selectors/","title":"<code>narwhals.selectors</code>","text":"<p>The following selectors are all supported. In addition, just like in Polars, the following set operations are supported:</p> <ul> <li>set intersection: <code>&amp;</code></li> <li>set union: <code>|</code></li> <li>set difference: <code>-</code></li> <li>complement: <code>~</code></li> </ul>"},{"location":"api-reference/selectors/#narwhals.selectors.boolean","title":"boolean","text":"<pre><code>boolean() -&gt; Selector\n</code></pre> <p>Select boolean columns.</p> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select boolean dtypes:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.boolean())\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|  shape: (2, 1)   |\n|  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       |\n|  \u2502 c     \u2502       |\n|  \u2502 ---   \u2502       |\n|  \u2502 bool  \u2502       |\n|  \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561       |\n|  \u2502 false \u2502       |\n|  \u2502 true  \u2502       |\n|  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.by_dtype","title":"by_dtype","text":"<pre><code>by_dtype(\n    *dtypes: DType\n    | type[DType]\n    | Iterable[DType | type[DType]],\n) -&gt; Selector\n</code></pre> <p>Select columns based on their dtype.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>DType | type[DType] | Iterable[DType | type[DType]]</code> <p>one or data types to select</p> <code>()</code> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select int64 and float64  dtypes and multiply each value by 2:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.by_dtype(nw.Int64, nw.Float64) * 2).to_native()\npyarrow.Table\na: int64\nc: double\n----\na: [[2,4]]\nc: [[8.2,4.6]]\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.categorical","title":"categorical","text":"<pre><code>categorical() -&gt; Selector\n</code></pre> <p>Select categorical columns.</p> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n</code></pre> <p>Let's convert column \"b\" to categorical, and then select categorical dtypes:</p> <pre><code>&gt;&gt;&gt; df = nw.from_native(df_native).with_columns(\n...     b=nw.col(\"b\").cast(nw.Categorical())\n... )\n&gt;&gt;&gt; df.select(ncs.categorical()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.datetime","title":"datetime","text":"<pre><code>datetime(\n    time_unit: TimeUnit | Iterable[TimeUnit] | None = None,\n    time_zone: (\n        str\n        | timezone\n        | Iterable[str | timezone | None]\n        | None\n    ) = (\"*\", None),\n) -&gt; Selector\n</code></pre> <p>Select all datetime columns, optionally filtering by time unit/zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit | Iterable[TimeUnit] | None</code> <p>One (or more) of the allowed timeunit precision strings, \"ms\", \"us\", \"ns\" and \"s\". Omit to select columns with any valid timeunit.</p> <code>None</code> <code>time_zone</code> <code>str | timezone | Iterable[str | timezone | None] | None</code> <p>Specify which timezone(s) to select</p> <ul> <li>One or more timezone strings, as defined in zoneinfo (to see valid options     run <code>import zoneinfo; zoneinfo.available_timezones()</code> for a full list).</li> <li>Set <code>None</code> to select Datetime columns that do not have a timezone.</li> <li>Set <code>\"*\"</code> to select Datetime columns that have any timezone.</li> </ul> <code>('*', None)</code> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt;\n&gt;&gt;&gt; utc_tz = timezone.utc\n&gt;&gt;&gt; data = {\n...     \"tstamp_utc\": [\n...         datetime(2023, 4, 10, 12, 14, 16, 999000, tzinfo=utc_tz),\n...         datetime(2025, 8, 25, 14, 18, 22, 666000, tzinfo=utc_tz),\n...     ],\n...     \"tstamp\": [\n...         datetime(2000, 11, 20, 18, 12, 16, 600000),\n...         datetime(2020, 10, 30, 10, 20, 25, 123000),\n...     ],\n...     \"numeric\": [3.14, 6.28],\n... }\n&gt;&gt;&gt; df_native = pa.table(data)\n&gt;&gt;&gt; df_nw = nw.from_native(df_native)\n&gt;&gt;&gt; df_nw.select(ncs.datetime()).to_native()\npyarrow.Table\ntstamp_utc: timestamp[us, tz=UTC]\ntstamp: timestamp[us]\n----\ntstamp_utc: [[2023-04-10 12:14:16.999000Z,2025-08-25 14:18:22.666000Z]]\ntstamp: [[2000-11-20 18:12:16.600000,2020-10-30 10:20:25.123000]]\n</code></pre> <p>Select only datetime columns that have any time_zone specification:</p> <pre><code>&gt;&gt;&gt; df_nw.select(ncs.datetime(time_zone=\"*\")).to_native()\npyarrow.Table\ntstamp_utc: timestamp[us, tz=UTC]\n----\ntstamp_utc: [[2023-04-10 12:14:16.999000Z,2025-08-25 14:18:22.666000Z]]\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.matches","title":"matches","text":"<pre><code>matches(pattern: str) -&gt; Selector\n</code></pre> <p>Select all columns that match the given regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pd.DataFrame(\n...     {\"bar\": [123, 456], \"baz\": [2.0, 5.5], \"zap\": [0, 1]}\n... )\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select column names containing an 'a', preceded by a character that is not 'z':</p> <pre><code>&gt;&gt;&gt; df.select(ncs.matches(\"[^z]a\")).to_native()\n   bar  baz\n0  123  2.0\n1  456  5.5\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.numeric","title":"numeric","text":"<pre><code>numeric() -&gt; Selector\n</code></pre> <p>Select numeric columns.</p> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select numeric dtypes and multiply each value by 2:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.numeric() * 2).to_native()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.string","title":"string","text":"<pre><code>string() -&gt; Selector\n</code></pre> <p>Select string columns.</p> <p>Returns:</p> Type Description <code>Selector</code> <p>A new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; df_native = pl.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]})\n&gt;&gt;&gt; df = nw.from_native(df_native)\n</code></pre> <p>Let's select string dtypes:</p> <pre><code>&gt;&gt;&gt; df.select(ncs.string()).to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/","title":"<code>narwhals.Series</code>","text":"<p>Narwhals Series, backed by a native series.</p> Warning <p>This class is not meant to be instantiated directly - instead:</p> <ul> <li> <p>If the native object is a series from one of the supported backend (e.g.     pandas.Series, polars.Series, pyarrow.ChunkedArray), you can use     <code>narwhals.from_native</code>:     <pre><code>narwhals.from_native(native_series, allow_series=True)\nnarwhals.from_native(native_series, series_only=True)\n</code></pre></p> </li> <li> <p>If the object is a generic sequence (e.g. a list or a tuple of values), you can     create a series via <code>narwhals.new_series</code>:     <pre><code>narwhals.new_series(\n    name=name,\n    values=values,\n    backend=narwhals.get_native_namespace(another_object),\n)\n</code></pre></p> </li> </ul>"},{"location":"api-reference/series/#narwhals.series.Series.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: DType\n</code></pre> <p>Get the data type of the Series.</p> <p>Returns:</p> Type Description <code>DType</code> <p>The data type of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).dtype\nInt64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.implementation","title":"implementation  <code>property</code>","text":"<pre><code>implementation: Implementation\n</code></pre> <p>Return implementation of native Series.</p> <p>This can be useful when you need to use special-casing for features outside of Narwhals' scope - for example, when dealing with pandas' Period Dtype.</p> <p>Returns:</p> Type Description <code>Implementation</code> <p>Implementation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n</code></pre> <pre><code>&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s.implementation\n&lt;Implementation.PANDAS: 'pandas'&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; s.implementation.is_pandas()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; s.implementation.is_pandas_like()\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; s.implementation.is_polars()\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the Series.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"foo\", [1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).name\n'foo'\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int]\n</code></pre> <p>Get the shape of the Series.</p> <p>Returns:</p> Type Description <code>tuple[int]</code> <p>A tuple containing the length of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).shape\n(3,)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(\n    requested_schema: object | None = None,\n) -&gt; object\n</code></pre> <p>Export a Series via the Arrow PyCapsule Interface.</p> <p>Narwhals doesn't implement anything itself here:</p> <ul> <li>if the underlying series implements the interface, it'll return that</li> <li>else, it'll call <code>to_arrow</code> and then defer to PyArrow's implementation</li> </ul> <p>See PyCapsule Interface for more.</p>"},{"location":"api-reference/series/#narwhals.series.Series.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx: SingleIndexSelector) -&gt; Any\n</code></pre><pre><code>__getitem__(idx: MultiIndexSelector) -&gt; Self\n</code></pre> <pre><code>__getitem__(\n    idx: SingleIndexSelector | MultiIndexSelector,\n) -&gt; Any | Self\n</code></pre> <p>Retrieve elements from the object using integer indexing or slicing.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>SingleIndexSelector | MultiIndexSelector</code> <p>The index, slice, or sequence of indices to retrieve.</p> <ul> <li>If <code>idx</code> is an integer, a single element is returned.</li> <li>If <code>idx</code> is a slice, a sequence of integers, or another Series     (with integer values) a subset of the Series is returned.</li> </ul> required <p>Returns:</p> Type Description <code>Any | Self</code> <p>A single element if <code>idx</code> is an integer, else a subset of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True)[0]\n1\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(s_native, series_only=True)[\n...     :2\n... ].to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    2\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Any]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.abs","title":"abs","text":"<pre><code>abs() -&gt; Self\n</code></pre> <p>Calculate the absolute value of each element.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the absolute values of the original elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, -4, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).abs().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    4,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.alias","title":"alias","text":"<pre><code>alias(name: str) -&gt; Self\n</code></pre> <p>Rename the Series.</p> Notes <p>This method is very cheap, but does not guarantee that data will be copied. For example:</p> <pre><code>s1: nw.Series\ns2 = s1.alias(\"foo\")\narr = s2.to_numpy()\narr[0] = 999\n</code></pre> <p>may (depending on the backend, and on the version) result in <code>s1</code>'s data being modified. We recommend:</p> <pre><code>- if you need to alias an object and don't need the original\n  one around any more, just use `alias` without worrying about it.\n- if you were expecting `alias` to copy data, then explicitly call\n  `.clone` before calling `alias`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the updated name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"foo\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).alias(\"bar\").to_native()\n0    1\n1    2\n2    3\nName: bar, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.all","title":"all","text":"<pre><code>all() -&gt; bool\n</code></pre> <p>Return whether all values in the Series are True.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if all values in the Series are True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[False, True, False]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).all()\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.any","title":"any","text":"<pre><code>any() -&gt; bool\n</code></pre> <p>Return whether any of the values in the Series are True.</p> Notes <p>Only works on Series of data type Boolean.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if any values in the Series are True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([False, True, False])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).any()\nnp.True_\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_max","title":"arg_max","text":"<pre><code>arg_max() -&gt; int\n</code></pre> <p>Returns the index of the maximum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).arg_max()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_min","title":"arg_min","text":"<pre><code>arg_min() -&gt; int\n</code></pre> <p>Returns the index of the minimum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).arg_min()\n0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_true","title":"arg_true","text":"<pre><code>arg_true() -&gt; Self\n</code></pre> <p>Find elements where boolean Series is True.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the indices of elements that are True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, None, None, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_null().arg_true().to_native()\nshape: (2,)\nSeries: '' [u32]\n[\n   1\n   2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cast","title":"cast","text":"<pre><code>cast(dtype: DType | type[DType]) -&gt; Self\n</code></pre> <p>Cast between data types.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DType | type[DType]</code> <p>Data type that the object will be cast into.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the specified data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[True, False, True]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cast(nw.Int64).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    0,\n    1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.clip","title":"clip","text":"<pre><code>clip(\n    lower_bound: (\n        Self | NumericLiteral | TemporalLiteral | None\n    ) = None,\n    upper_bound: (\n        Self | NumericLiteral | TemporalLiteral | None\n    ) = None,\n) -&gt; Self\n</code></pre> <p>Clip values in the Series.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Self | NumericLiteral | TemporalLiteral | None</code> <p>Lower bound value.</p> <code>None</code> <code>upper_bound</code> <code>Self | NumericLiteral | TemporalLiteral | None</code> <p>Upper bound value.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with values clipped to the specified bounds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([-1, 1, -3, 3, -5, 5])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).clip(-1, 3).to_native()\n0   -1\n1    1\n2   -1\n3    3\n4   -1\n5    3\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Returns the number of non-null elements in the Series.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of non-null elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).count()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_count","title":"cum_count","text":"<pre><code>cum_count(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative count of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the cumulative count of non-null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([\"x\", \"k\", None, \"d\"])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_count(\n...     reverse=True\n... ).to_native()\nshape: (4,)\nSeries: '' [u32]\n[\n    3\n    2\n    1\n    1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_max","title":"cum_max","text":"<pre><code>cum_max(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative max of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the cumulative max of non-null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 3, None, 2]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).cum_max().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    3,\n    null,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_min","title":"cum_min","text":"<pre><code>cum_min(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative min of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the cumulative min of non-null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([3, 1, None, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_min().to_native()\n0    3.0\n1    1.0\n2    NaN\n3    1.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_prod","title":"cum_prod","text":"<pre><code>cum_prod(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Return the cumulative product of the non-null values in the series.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the cumulative product of non-null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 3, None, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).cum_prod().to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   3\n   null\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_sum","title":"cum_sum","text":"<pre><code>cum_sum(*, reverse: bool = False) -&gt; Self\n</code></pre> <p>Calculate the cumulative sum.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>reverse the operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the cumulative sum of non-null values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).cum_sum().to_native()\n0    2\n1    6\n2    9\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.diff","title":"diff","text":"<pre><code>diff() -&gt; Self\n</code></pre> <p>Calculate the difference with the previous element, for each element.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the difference between each element and its predecessor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[2, 4, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).diff().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    null,\n    2,\n    -1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.drop_nulls","title":"drop_nulls","text":"<pre><code>drop_nulls() -&gt; Self\n</code></pre> <p>Drop null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with null values removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, None, 3, 5])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).drop_nulls().to_native()\n0    2.0\n1    4.0\n3    3.0\n4    5.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.ewm_mean","title":"ewm_mean","text":"<pre><code>ewm_mean(\n    *,\n    com: float | None = None,\n    span: float | None = None,\n    half_life: float | None = None,\n    alpha: float | None = None,\n    adjust: bool = True,\n    min_samples: int = 1,\n    ignore_nulls: bool = False\n) -&gt; Self\n</code></pre> <p>Compute exponentially-weighted moving average.</p> <p>Parameters:</p> Name Type Description Default <code>com</code> <code>float | None</code> <p>Specify decay in terms of center of mass, \\(\\gamma\\), with  \\(\\alpha = \\frac{1}{1+\\gamma}\\forall\\gamma\\geq0\\)</p> <code>None</code> <code>span</code> <code>float | None</code> <p>Specify decay in terms of span, \\(\\theta\\), with  \\(\\alpha = \\frac{2}{\\theta + 1} \\forall \\theta \\geq 1\\)</p> <code>None</code> <code>half_life</code> <code>float | None</code> <p>Specify decay in terms of half-life, \\(\\tau\\), with  \\(\\alpha = 1 - \\exp \\left\\{ \\frac{ -\\ln(2) }{ \\tau } \\right\\} \\forall \\tau &gt; 0\\)</p> <code>None</code> <code>alpha</code> <code>float | None</code> <p>Specify smoothing factor alpha directly, \\(0 &lt; \\alpha \\leq 1\\).</p> <code>None</code> <code>adjust</code> <code>bool</code> <p>Divide by decaying adjustment factor in beginning periods to account for imbalance in relative weightings</p> <ul> <li>When <code>adjust=True</code> (the default) the EW function is calculated   using weights \\(w_i = (1 - \\alpha)^i\\)</li> <li>When <code>adjust=False</code> the EW function is calculated recursively by   $$   y_0=x_0   $$   $$   y_t = (1 - \\alpha)y_{t - 1} + \\alpha x_t   $$</li> </ul> <code>True</code> <code>min_samples</code> <code>int</code> <p>Minimum number of observations in window required to have a value (otherwise result is null).</p> <code>1</code> <code>ignore_nulls</code> <code>bool</code> <p>Ignore missing values when calculating weights.</p> <ul> <li>When <code>ignore_nulls=False</code> (default), weights are based on absolute   positions.   For example, the weights of \\(x_0\\) and \\(x_2\\) used in   calculating the final weighted average of \\([x_0, None, x_2]\\) are   \\((1-\\alpha)^2\\) and \\(1\\) if <code>adjust=True</code>, and   \\((1-\\alpha)^2\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> <li>When <code>ignore_nulls=True</code>, weights are based   on relative positions. For example, the weights of   \\(x_0\\) and \\(x_2\\) used in calculating the final weighted   average of \\([x_0, None, x_2]\\) are   \\(1-\\alpha\\) and \\(1\\) if <code>adjust=True</code>,   and \\(1-\\alpha\\) and \\(\\alpha\\) if <code>adjust=False</code>.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>Series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series(name=\"a\", data=[1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).ewm_mean(\n...     com=1, ignore_nulls=False\n... ).to_native()\n0    1.000000\n1    1.666667\n2    2.428571\nName: a, dtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.fill_null","title":"fill_null","text":"<pre><code>fill_null(\n    value: Self | NonNestedLiteral = None,\n    strategy: FillNullStrategy | None = None,\n    limit: int | None = None,\n) -&gt; Self\n</code></pre> <p>Fill null values using the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Self | NonNestedLiteral</code> <p>Value used to fill null values.</p> <code>None</code> <code>strategy</code> <code>FillNullStrategy | None</code> <p>Strategy used to fill null values.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Number of consecutive null values to fill when using the 'forward' or 'backward' strategy.</p> <code>None</code> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with null values filled according to the specified value or strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, None])\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).fill_null(5).to_native()\n0    1.0\n1    2.0\n2    5.0\ndtype: float64\n</code></pre> <p>Or using a strategy:</p> <pre><code>&gt;&gt;&gt; nw.from_native(s_native, series_only=True).fill_null(\n...     strategy=\"forward\", limit=1\n... ).to_native()\n0    1.0\n1    2.0\n2    2.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.filter","title":"filter","text":"<pre><code>filter(predicate: Any) -&gt; Self\n</code></pre> <p>Filter elements in the Series based on a condition.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with elements that satisfy the condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([4, 10, 15, 34, 50])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 10).to_native()\n2    15\n3    34\n4    50\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.gather_every","title":"gather_every","text":"<pre><code>gather_every(n: int, offset: int = 0) -&gt; Self\n</code></pre> <p>Take every nth value in the Series and return as new Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with every nth value starting from the offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 4]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).gather_every(\n...     n=2, offset=1\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    4\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; Self\n</code></pre> <p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series containing the first n rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series(list(range(10)))\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).head(3).to_native()\n0    0\n1    1\n2    2\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.hist","title":"hist","text":"<pre><code>hist(\n    bins: list[float | int] | None = None,\n    *,\n    bin_count: int | None = None,\n    include_breakpoint: bool = True\n) -&gt; DataFrame[Any]\n</code></pre> <p>Bin values into buckets and count their occurrences.</p> Warning <p>This functionality is considered unstable. It may be changed at any point without it being considered a breaking change.</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>list[float | int] | None</code> <p>A monotonically increasing sequence of values.</p> <code>None</code> <code>bin_count</code> <code>int | None</code> <p>If no bins provided, this will be used to determine the distance of the bins.</p> <code>None</code> <code>include_breakpoint</code> <code>bool</code> <p>Include a column that shows the intervals as categories.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A new DataFrame containing the counts of values that occur within each passed bin.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 3, 8, 8, 2, 1, 3], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).hist(bin_count=4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals DataFrame |\n|--------------------|\n|   breakpoint  count|\n|0        2.75      3|\n|1        4.50      2|\n|2        6.25      0|\n|3        8.00      2|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_between","title":"is_between","text":"<pre><code>is_between(\n    lower_bound: Any | Self,\n    upper_bound: Any | Self,\n    closed: ClosedInterval = \"both\",\n) -&gt; Self\n</code></pre> <p>Get a boolean mask of the values that are between the given lower/upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any | Self</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any | Self</code> <p>Upper bound value.</p> required <code>closed</code> <code>ClosedInterval</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> Notes <p>If the value of the <code>lower_bound</code> is greater than that of the <code>upper_bound</code>, then the values will be False, as no value can satisfy the condition.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A boolean Series indicating which values are between the given bounds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 4, 5]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.is_between(2, 4, \"right\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true,\n    true,\n    false\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_duplicated","title":"is_duplicated","text":"<pre><code>is_duplicated() -&gt; Self\n</code></pre> <p>Get a mask of all duplicated rows in the Series.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with boolean values indicating duplicated rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3, 1]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_duplicated().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    true,\n    false,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the series is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if the series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_empty()\nFalse\n&gt;&gt;&gt; s_nw.filter(s_nw &gt; 10).is_empty()\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_finite","title":"is_finite","text":"<pre><code>is_finite() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are finite.</p> Warning <p>Different backend handle null values differently. <code>is_finite</code> will return False for NaN and Null's in the Dask and pandas non-nullable backend, while for Polars, PyArrow and pandas nullable backends null values are kept as such.</p> <p>Returns:</p> Type Description <code>Self</code> <p>Expression of <code>Boolean</code> data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[float(\"nan\"), float(\"inf\"), 2.0, None]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_finite().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true,\n    null\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_first_distinct","title":"is_first_distinct","text":"<pre><code>is_first_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with boolean values indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_first_distinct().to_native()\nshape: (5,)\nSeries: '' [bool]\n[\n    true\n    false\n    true\n    true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_in","title":"is_in","text":"<pre><code>is_in(other: Any) -&gt; Self\n</code></pre> <p>Check if the elements of this Series are in the other sequence.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>Sequence of primitive type.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with boolean values indicating if the elements are in the other sequence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.is_in([3, 2, 8]).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    true,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_last_distinct","title":"is_last_distinct","text":"<pre><code>is_last_distinct() -&gt; Self\n</code></pre> <p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with boolean values indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_last_distinct().to_native()\n0    False\n1     True\n2    False\n3     True\n4     True\ndtype: bool\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_nan","title":"is_nan","text":"<pre><code>is_nan() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are NaN.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A boolean Series indicating which values are NaN.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([0.0, None, 2.0], dtype=\"Float64\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_nan().to_native()\n0    False\n1     &lt;NA&gt;\n2    False\ndtype: boolean\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; Self\n</code></pre> <p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A boolean Series indicating which values are null.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).is_null().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    false,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_sorted","title":"is_sorted","text":"<pre><code>is_sorted(*, descending: bool = False) -&gt; bool\n</code></pre> <p>Check if the Series is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Check if the Series is sorted in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating if the Series is sorted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[3, 2, 1]])\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_sorted(descending=False)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.is_sorted(descending=True)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_unique","title":"is_unique","text":"<pre><code>is_unique() -&gt; Self\n</code></pre> <p>Get a mask of all unique rows in the Series.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with boolean values indicating unique rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).is_unique().to_native()\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.item","title":"item","text":"<pre><code>item(index: int | None = None) -&gt; Any\n</code></pre> <p>Return the Series as a scalar, or return the element at the given index.</p> <p>If no index is provided, this is equivalent to <code>s[0]</code>, with a check that the shape is (1,). With an index, this is equivalent to <code>s[index]</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The scalar value of the Series or the element at the given index.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; nw.from_native(pl.Series(\"a\", [1]), series_only=True).item()\n1\n</code></pre> <pre><code>&gt;&gt;&gt; nw.from_native(pl.Series(\"a\", [9, 8, 7]), series_only=True).item(-1)\n7\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.len","title":"len","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Return the number of elements in the Series.</p> <p>Null values count towards the total.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).len()\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.log","title":"log","text":"<pre><code>log(base: float = math.e) -&gt; Self\n</code></pre> <p>Compute the logarithm to a given base.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>float</code> <p>Given base, defaults to <code>e</code></p> <code>e</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new expression log values data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 4], name=\"a\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.log(base=2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|    Narwhals Series    |\n|-----------------------|\n|0    0.0               |\n|1    1.0               |\n|2    2.0               |\n|Name: a, dtype: float64|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.max","title":"max","text":"<pre><code>max() -&gt; Any\n</code></pre> <p>Get the maximum value in this Series.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The maximum value in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).max()\nnp.int64(3)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mean","title":"mean","text":"<pre><code>mean() -&gt; float\n</code></pre> <p>Reduce this Series to the mean value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The average of all elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.2, 4.2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).mean()\nnp.float64(2.7)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.median","title":"median","text":"<pre><code>median() -&gt; float\n</code></pre> <p>Reduce this Series to the median value.</p> Notes <p>Results might slightly differ across backends due to differences in the underlying algorithms used to compute the median.</p> <p>Returns:</p> Type Description <code>float</code> <p>The median value of all elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[5, 3, 8]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).median()\n5.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.min","title":"min","text":"<pre><code>min() -&gt; Any\n</code></pre> <p>Get the minimal value in this Series.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The minimum value in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).min()\n1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mode","title":"mode","text":"<pre><code>mode() -&gt; Self\n</code></pre> <p>Compute the most occurring value(s).</p> <p>Can return multiple values.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series containing the mode(s) (values that appear most frequently).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).mode().sort().to_native()\n0    1\n1    2\ndtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.n_unique","title":"n_unique","text":"<pre><code>n_unique() -&gt; int\n</code></pre> <p>Count the number of unique values.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of unique values in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).n_unique()\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.null_count","title":"null_count","text":"<pre><code>null_count() -&gt; int\n</code></pre> <p>Count the number of null values.</p> Notes <p>pandas handles null values differently from Polars and PyArrow. See null_handling for reference.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of null values in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, None, None]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).null_count()\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.pipe","title":"pipe","text":"<pre><code>pipe(\n    function: Callable[[Any], Self],\n    *args: Any,\n    **kwargs: Any\n) -&gt; Self\n</code></pre> <p>Pipe function call.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the results of the piped function applied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.pipe(lambda x: x + 2).to_native()\nshape: (3,)\nSeries: '' [i64]\n[\n    3\n    4\n    5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.quantile","title":"quantile","text":"<pre><code>quantile(\n    quantile: float,\n    interpolation: RollingInterpolationMethod,\n) -&gt; float\n</code></pre> <p>Get quantile value of the series.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>float</code> <p>Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <code>RollingInterpolationMethod</code> <p>Interpolation method.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The quantile value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(list(range(50)))\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; [\n...     s_nw.quantile(quantile=q, interpolation=\"nearest\")\n...     for q in (0.1, 0.25, 0.5, 0.75, 0.9)\n... ]\n[5.0, 12.0, 25.0, 37.0, 44.0]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rank","title":"rank","text":"<pre><code>rank(\n    method: RankMethod = \"average\",\n    *,\n    descending: bool = False\n) -&gt; Self\n</code></pre> <p>Assign ranks to data, dealing with ties appropriately.</p> Notes <p>The resulting dtype may differ between backends.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RankMethod</code> <p>The method used to assign ranks to tied elements. The following methods are available (default is 'average')</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul> <code>'average'</code> <code>descending</code> <code>bool</code> <p>Rank in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new series with rank data as values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[3, 6, 1, 1, 6]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rank(\n...     method=\"dense\"\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    3,\n    1,\n    1,\n    3\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rename","title":"rename","text":"<pre><code>rename(name: str) -&gt; Self\n</code></pre> <p>Rename the Series.</p> <p>Alias for <code>Series.alias()</code>.</p> Notes <p>This method is very cheap, but does not guarantee that data will be copied. For example:</p> <pre><code>s1: nw.Series\ns2 = s1.rename(\"foo\")\narr = s2.to_numpy()\narr[0] = 999\n</code></pre> <p>may (depending on the backend, and on the version) result in <code>s1</code>'s data being modified. We recommend:</p> <pre><code>- if you need to rename an object and don't need the original\n  one around any more, just use `rename` without worrying about it.\n- if you were expecting `rename` to copy data, then explicitly call\n  `.clone` before calling `rename`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the updated name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"foo\", [1, 2, 3])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.rename(\"bar\").to_native()\nshape: (3,)\nSeries: 'bar' [i64]\n[\n   1\n   2\n   3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.replace_strict","title":"replace_strict","text":"<pre><code>replace_strict(\n    old: Sequence[Any] | Mapping[Any, Any],\n    new: Sequence[Any] | None = None,\n    *,\n    return_dtype: DType | type[DType] | None = None\n) -&gt; Self\n</code></pre> <p>Replace all values by different values.</p> <p>This function must replace all non-null input values (else it raises an error).</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>Sequence[Any] | Mapping[Any, Any]</code> <p>Sequence of values to replace. It also accepts a mapping of values to their replacement as syntactic sugar for <code>replace_all(old=list(mapping.keys()), new=list(mapping.values()))</code>.</p> required <code>new</code> <code>Sequence[Any] | None</code> <p>Sequence of values to replace by. Length must match the length of <code>old</code>.</p> <code>None</code> <code>return_dtype</code> <code>DType | type[DType] | None</code> <p>The data type of the resulting expression. If set to <code>None</code> (default), the data type is determined automatically based on the other inputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with values replaced according to the mapping.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([3, 0, 1, 2], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).replace_strict(\n...     [0, 1, 2, 3], [\"zero\", \"one\", \"two\", \"three\"], return_dtype=nw.String\n... ).to_native()\n0    three\n1     zero\n2      one\n3      two\nName: a, dtype: object\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_mean","title":"rolling_mean","text":"<pre><code>rolling_mean(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling mean (moving mean) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their mean.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1.0, 2.0, 3.0, 4.0]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_mean(\n...     window_size=2\n... ).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    null,\n    1.5,\n    2.5,\n    3.5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_std","title":"rolling_std","text":"<pre><code>rolling_std(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling standard deviation (moving standard deviation) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their standard deviation.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.0, 3.0, 1.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_std(\n...     window_size=2, min_samples=1\n... ).to_native()\n0         NaN\n1    1.414214\n2    1.414214\n3    2.121320\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_sum","title":"rolling_sum","text":"<pre><code>rolling_sum(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False\n) -&gt; Self\n</code></pre> <p>Apply a rolling sum (moving sum) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their sum.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code></p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1.0, 2.0, 3.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_sum(\n...     window_size=2\n... ).to_native()\n0    NaN\n1    3.0\n2    5.0\n3    7.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.rolling_var","title":"rolling_var","text":"<pre><code>rolling_var(\n    window_size: int,\n    *,\n    min_samples: int | None = None,\n    center: bool = False,\n    ddof: int = 1\n) -&gt; Self\n</code></pre> <p>Apply a rolling variance (moving variance) over the values.</p> <p>A window of length <code>window_size</code> will traverse the values. The resulting values will be aggregated to their variance.</p> <p>The window at a given row will include the row itself and the <code>window_size - 1</code> elements before it.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>The length of the window in number of elements. It must be a strictly positive integer.</p> required <code>min_samples</code> <code>int | None</code> <p>The number of values in the window that should be non-null before computing a result. If set to <code>None</code> (default), it will be set equal to <code>window_size</code>. If provided, it must be a strictly positive integer, and less than or equal to <code>window_size</code>.</p> <code>None</code> <code>center</code> <code>bool</code> <p>Set the labels at the center of the window.</p> <code>False</code> <code>ddof</code> <code>int</code> <p>Delta Degrees of Freedom; the divisor for a length N window is N - ddof.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1.0, 3.0, 1.0, 4.0])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).rolling_var(\n...     window_size=2, min_samples=1\n... ).to_native()\nshape: (4,)\nSeries: '' [f64]\n[\n   null\n   2.0\n   2.0\n   4.5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.round","title":"round","text":"<pre><code>round(decimals: int = 0) -&gt; Self\n</code></pre> <p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with rounded values.</p> Notes <p>For values exactly halfway between rounded decimal values pandas behaves differently than Polars and Arrow.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars and Arrow round away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1.12345, 2.56789, 3.901234])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.round(1).to_native()\nshape: (3,)\nSeries: '' [f64]\n[\n   1.1\n   2.6\n   3.9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sample","title":"sample","text":"<pre><code>sample(\n    n: int | None = None,\n    *,\n    fraction: float | None = None,\n    with_replacement: bool = False,\n    seed: int | None = None\n) -&gt; Self\n</code></pre> <p>Sample randomly from this Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If set to None (default), a random seed is generated for each sample operation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series containing randomly sampled values from the original Series.</p> Notes <p>The <code>sample</code> method returns a Series with a specified number of randomly selected items chosen from this Series. The results are not consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3, 4])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.sample(\n...     fraction=1.0, with_replacement=True\n... ).to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.scatter","title":"scatter","text":"<pre><code>scatter(indices: int | Sequence[int], values: Any) -&gt; Self\n</code></pre> <p>Set value(s) at given position(s).</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>int | Sequence[int]</code> <p>Position(s) to set items at.</p> required <code>values</code> <code>Any</code> <p>Values to set.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with values set at given positions.</p> Note <p>This method always returns a new Series, without modifying the original one. Using this function in a for-loop is an anti-pattern, we recommend building up your positions and values beforehand and doing an update in one go.</p> <p>For example, instead of</p> <pre><code>for i in [1, 3, 2]:\n    value = some_function(i)\n    s = s.scatter(i, value)\n</code></pre> <p>prefer</p> <pre><code>positions = [1, 3, 2]\nvalues = [some_function(x) for x in positions]\ns = s.scatter(positions, values)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; df_native = pa.table({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_nw = nw.from_native(df_native)\n&gt;&gt;&gt; df_nw.with_columns(df_nw[\"a\"].scatter([0, 1], [999, 888])).to_native()\npyarrow.Table\na: int64\nb: int64\n----\na: [[999,888,3]]\nb: [[4,5,6]]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shift","title":"shift","text":"<pre><code>shift(n: int) -&gt; Self\n</code></pre> <p>Shift values by <code>n</code> positions.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of indices to shift forward. If a negative value is passed, values are shifted in the opposite direction instead.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with values shifted by n positions.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([2, 4, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).shift(1).to_native()\n0    NaN\n1    2.0\n2    4.0\ndtype: float64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sort","title":"sort","text":"<pre><code>sort(\n    *, descending: bool = False, nulls_last: bool = False\n) -&gt; Self\n</code></pre> <p>Sort this Series. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last instead of first.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new sorted Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([5, None, 1, 2])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.sort(descending=True).to_native()\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   5\n   2\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.skew","title":"skew","text":"<pre><code>skew() -&gt; float | None\n</code></pre> <p>Calculate the sample skewness of the Series.</p> <p>Returns:</p> Type Description <code>float | None</code> <p>The sample skewness of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 1, 2, 10, 100])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).skew()\n1.4724267269058975\n</code></pre> Notes <p>The skewness is a measure of the asymmetry of the probability distribution. A perfectly symmetric distribution has a skewness of 0.</p>"},{"location":"api-reference/series/#narwhals.series.Series.std","title":"std","text":"<pre><code>std(*, ddof: int = 1) -&gt; float\n</code></pre> <p>Get the standard deviation of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,      where N represents the number of elements.</p> <code>1</code> <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation of all elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).std()\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sum","title":"sum","text":"<pre><code>sum() -&gt; float\n</code></pre> <p>Reduce this Series to the sum value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The sum of all elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).sum()\n6\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; Self\n</code></pre> <p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>10</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with the last n rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([list(range(10))])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.tail(3).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    7,\n    8,\n    9\n  ]\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_arrow","title":"to_arrow","text":"<pre><code>to_arrow() -&gt; pa.Array[Any]\n</code></pre> <p>Convert to arrow.</p> <p>Returns:</p> Type Description <code>Array[Any]</code> <p>A PyArrow Array containing the data from the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2, 3, 4])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).to_arrow()\n&lt;pyarrow.lib.Int64Array object at ...&gt;\n[\n    1,\n    2,\n    3,\n    4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_dummies","title":"to_dummies","text":"<pre><code>to_dummies(\n    *, separator: str = \"_\", drop_first: bool = False\n) -&gt; DataFrame[Any]\n</code></pre> <p>Get dummy/indicator variables.</p> <p>Parameters:</p> Name Type Description Default <code>separator</code> <code>str</code> <p>Separator/delimiter used when generating column names.</p> <code>'_'</code> <code>drop_first</code> <code>bool</code> <p>Remove the first category from the variable being encoded.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A new DataFrame containing the dummy/indicator variables.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"a\")\n&gt;&gt;&gt; s_nw = nw.from_native(s_native, series_only=True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.to_dummies(drop_first=False).to_native()\n   a_1  a_2  a_3\n0    1    0    0\n1    0    1    0\n2    0    0    1\n</code></pre> <pre><code>&gt;&gt;&gt; s_nw.to_dummies(drop_first=True).to_native()\n   a_2  a_3\n0    0    0\n1    1    0\n2    0    1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_frame","title":"to_frame","text":"<pre><code>to_frame() -&gt; DataFrame[Any]\n</code></pre> <p>Convert to dataframe.</p> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A DataFrame containing this Series as a single column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"a\", [1, 2])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_frame().to_native()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[Any]\n</code></pre> <p>Convert to list.</p> Notes <p>This function converts to Python scalars. It's typically more efficient to keep your data in the format native to your original dataframe, so we recommend only calling this when you absolutely need to.</p> <p>Returns:</p> Type Description <code>list[Any]</code> <p>A list of Python objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_list()\n[1, 2, 3]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; _1DArray\n</code></pre> <p>Convert to numpy.</p> <p>Returns:</p> Type Description <code>_1DArray</code> <p>NumPy ndarray representation of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 2, 3], name=\"a\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_numpy()\narray([1, 2, 3]...)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_pandas","title":"to_pandas","text":"<pre><code>to_pandas() -&gt; pd.Series[Any]\n</code></pre> <p>Convert to pandas Series.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>A pandas Series containing the data from this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series(\"a\", [1, 2, 3])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).to_pandas()\n0    1\n1    2\n2    3\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_polars","title":"to_polars","text":"<pre><code>to_polars() -&gt; pl.Series\n</code></pre> <p>Convert to polars Series.</p> <p>Returns:</p> Type Description <code>Series</code> <p>A polars Series containing the data from this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(\n...     s_native, series_only=True\n... ).to_polars()\nshape: (3,)\nSeries: '' [i64]\n[\n    1\n    2\n    3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_native","title":"to_native","text":"<pre><code>to_native() -&gt; IntoSeriesT\n</code></pre> <p>Convert Narwhals series to native series.</p> <p>Returns:</p> Type Description <code>IntoSeriesT</code> <p>Series of class that user started with.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([1, 2])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n  1\n  2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.unique","title":"unique","text":"<pre><code>unique(*, maintain_order: bool = False) -&gt; Self\n</code></pre> <p>Returns unique values of the series.</p> <p>Parameters:</p> Name Type Description Default <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original series. This may be more expensive to compute. Settings this to <code>True</code> blocks the possibility to run on the streaming engine for Polars.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with duplicate values removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pl.Series([2, 4, 4, 6])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.unique(\n...     maintain_order=True\n... ).to_native()\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   4\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.value_counts","title":"value_counts","text":"<pre><code>value_counts(\n    *,\n    sort: bool = False,\n    parallel: bool = False,\n    name: str | None = None,\n    normalize: bool = False\n) -&gt; DataFrame[Any]\n</code></pre> <p>Count the occurrences of unique values.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>bool</code> <p>Sort the output by count in descending order. If set to False (default), the order of the output is random.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Execute the computation in parallel. Used for Polars only.</p> <code>False</code> <code>name</code> <code>str | None</code> <p>Give the resulting count column a specific name; if <code>normalize</code> is True defaults to \"proportion\", otherwise defaults to \"count\".</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If true gives relative frequencies of the unique values</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>A DataFrame with two columns</p> <ul> <li>The original values as first column</li> <li>Either count or proportion as second column, depending on normalize parameter.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pd.Series([1, 1, 2, 3, 2], name=\"s\")\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).value_counts(\n...     sort=True\n... ).to_native()\n   s  count\n0  1      2\n1  2      2\n2  3      1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.var","title":"var","text":"<pre><code>var(*, ddof: int = 1) -&gt; float\n</code></pre> <p>Get the variance of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\"Delta Degrees of Freedom\": the divisor used in the calculation is N - ddof,      where N represents the number of elements.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt;\n&gt;&gt;&gt; s_native = pa.chunked_array([[1, 2, 3]])\n&gt;&gt;&gt; nw.from_native(s_native, series_only=True).var()\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.zip_with","title":"zip_with","text":"<pre><code>zip_with(mask: Self, other: Self) -&gt; Self\n</code></pre> <p>Take values from self or other based on the given mask.</p> <p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>Self</code> <p>Boolean Series</p> required <code>other</code> <code>Self</code> <p>Series of same type.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new Series with values selected from self or other based on the mask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data_native = pa.chunked_array([[1, 2, 3, 4, 5]])\n&gt;&gt;&gt; other_native = pa.chunked_array([[5, 4, 3, 2, 1]])\n&gt;&gt;&gt; mask_native = pa.chunked_array([[True, False, True, False, True]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; data_nw = nw.from_native(data_native, series_only=True)\n&gt;&gt;&gt; other_nw = nw.from_native(other_native, series_only=True)\n&gt;&gt;&gt; mask_nw = nw.from_native(mask_native, series_only=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; data_nw.zip_with(mask_nw, other_nw).to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    4,\n    3,\n    2,\n    5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_cat/","title":"<code>narwhals.Series.cat</code>","text":""},{"location":"api-reference/series_cat/#narwhals.series.SeriesCatNamespace.get_categories","title":"get_categories","text":"<pre><code>get_categories() -&gt; SeriesT\n</code></pre> <p>Get unique categories from column.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the unique categories.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", \"mango\"], dtype=\"category\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.cat.get_categories().to_native()\n0    apple\n1    mango\ndtype: object\n</code></pre>"},{"location":"api-reference/series_dt/","title":"<code>narwhals.Series.dt</code>","text":""},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.convert_time_zone","title":"convert_time_zone","text":"<pre><code>convert_time_zone(time_zone: str) -&gt; SeriesT\n</code></pre> <p>Convert time zone.</p> <p>If converting from a time-zone-naive column, then conversion happens as if converting from UTC.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str</code> <p>Target time zone.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with the specified time zone.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2024, 1, 1, tzinfo=timezone.utc),\n...         datetime(2024, 1, 2, tzinfo=timezone.utc),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.convert_time_zone(\"Asia/Kathmandu\").to_native()\n0   2024-01-01 05:45:00+05:45\n1   2024-01-02 05:45:00+05:45\ndtype: datetime64[ns, Asia/Kathmandu]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.date","title":"date","text":"<pre><code>date() -&gt; SeriesT\n</code></pre> <p>Get the date in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with the date portion of the datetime values.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If pandas default backend is being used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2012, 1, 7, 10, 20), datetime(2023, 3, 10, 11, 32)]\n... ).convert_dtypes(dtype_backend=\"pyarrow\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.date().to_native()\n0    2012-01-07\n1    2023-03-10\ndtype: date32[day][pyarrow]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.day","title":"day","text":"<pre><code>day() -&gt; SeriesT\n</code></pre> <p>Extracts the day in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the day component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2022, 1, 1), datetime(2022, 1, 5)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.day().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    5\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.hour","title":"hour","text":"<pre><code>hour() -&gt; SeriesT\n</code></pre> <p>Extracts the hour in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the hour component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.hour().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    5,\n    9\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.microsecond","title":"microsecond","text":"<pre><code>microsecond() -&gt; SeriesT\n</code></pre> <p>Extracts the microseconds in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the microsecond component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.microsecond().alias(\"datetime\").to_native()\n0    400000\n1         0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.millisecond","title":"millisecond","text":"<pre><code>millisecond() -&gt; SeriesT\n</code></pre> <p>Extracts the milliseconds in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the millisecond component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.millisecond().alias(\"datetime\").to_native()\n0    400\n1      0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.minute","title":"minute","text":"<pre><code>minute() -&gt; SeriesT\n</code></pre> <p>Extracts the minute in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the minute component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.minute().to_native()\n0     3\n1    12\ndtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.month","title":"month","text":"<pre><code>month() -&gt; SeriesT\n</code></pre> <p>Gets the month in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the month component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([datetime(2012, 1, 7), datetime(2023, 3, 10)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.month().to_native()\nshape: (2,)\nSeries: '' [i8]\n[\n        1\n        3\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.nanosecond","title":"nanosecond","text":"<pre><code>nanosecond() -&gt; SeriesT\n</code></pre> <p>Extract the nanoseconds in a date series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the nanosecond component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [\n...         datetime(2022, 1, 1, 5, 3, 7, 400000),\n...         datetime(2022, 1, 1, 5, 3, 7, 0),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.nanosecond().alias(\"datetime\").to_native()\n0    400000000\n1            0\nName: datetime, dtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.ordinal_day","title":"ordinal_day","text":"<pre><code>ordinal_day() -&gt; SeriesT\n</code></pre> <p>Get ordinal day.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the ordinal day (day of year) for each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2020, 1, 1), datetime(2020, 8, 3)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.ordinal_day().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    1,\n    216\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.replace_time_zone","title":"replace_time_zone","text":"<pre><code>replace_time_zone(time_zone: str | None) -&gt; SeriesT\n</code></pre> <p>Replace time zone.</p> <p>Parameters:</p> Name Type Description Default <code>time_zone</code> <code>str | None</code> <p>Target time zone.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with the specified time zone.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         datetime(2024, 1, 1, tzinfo=timezone.utc),\n...         datetime(2024, 1, 2, tzinfo=timezone.utc),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.replace_time_zone(\n...     \"Asia/Kathmandu\"\n... ).to_native()\nshape: (2,)\nSeries: '' [datetime[\u03bcs, Asia/Kathmandu]]\n[\n        2024-01-01 00:00:00 +0545\n        2024-01-02 00:00:00 +0545\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.second","title":"second","text":"<pre><code>second() -&gt; SeriesT\n</code></pre> <p>Extracts the seconds in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the second component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [datetime(2022, 1, 1, 5, 3, 10), datetime(2022, 1, 5, 9, 12, 4)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.second().to_native()\n0    10\n1     4\ndtype: int32\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.timestamp","title":"timestamp","text":"<pre><code>timestamp(time_unit: TimeUnit) -&gt; SeriesT\n</code></pre> <p>Return a timestamp in the given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>TimeUnit</code> <p>One of - 'ns': nanosecond. - 'us': microsecond. - 'ms': millisecond.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with timestamps in the specified time unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series(\n...     [date(2001, 1, 1), None, date(2001, 1, 3)], dtype=\"datetime64[ns]\"\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.timestamp(\"ms\").to_native()\n0    9.783072e+11\n1             NaN\n2    9.784800e+11\ndtype: float64\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_microseconds","title":"total_microseconds","text":"<pre><code>total_microseconds() -&gt; SeriesT\n</code></pre> <p>Get total microseconds.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the total number of microseconds for each timedelta value.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         timedelta(microseconds=10),\n...         timedelta(milliseconds=1, microseconds=200),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_microseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        1200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_milliseconds","title":"total_milliseconds","text":"<pre><code>total_milliseconds() -&gt; SeriesT\n</code></pre> <p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the total number of milliseconds for each timedelta value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\n...         timedelta(milliseconds=10),\n...         timedelta(milliseconds=20, microseconds=40),\n...     ]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_milliseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_minutes","title":"total_minutes","text":"<pre><code>total_minutes() -&gt; SeriesT\n</code></pre> <p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the total number of minutes for each timedelta value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_minutes().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_nanoseconds","title":"total_nanoseconds","text":"<pre><code>total_nanoseconds() -&gt; SeriesT\n</code></pre> <p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the total number of nanoseconds for each timedelta value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n... ).str.to_datetime(time_unit=\"ns\")\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.diff().dt.total_nanoseconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        null\n        1\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_seconds","title":"total_seconds","text":"<pre><code>total_seconds() -&gt; SeriesT\n</code></pre> <p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the total number of seconds for each timedelta value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.total_seconds().to_native()\nshape: (2,)\nSeries: '' [i64]\n[\n        600\n        1240\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.to_string","title":"to_string","text":"<pre><code>to_string(format: str) -&gt; SeriesT\n</code></pre> <p>Convert a Date/Time/Datetime series into a String series with the given format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format string for converting the datetime to string.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with the datetime values formatted as strings according to the specified format.</p> Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments.</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>Though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2020, 3, 1), datetime(2020, 4, 1)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.to_string(\"%Y/%m/%d\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"2020/03/01\",\n    \"2020/04/01\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.truncate","title":"truncate","text":"<pre><code>truncate(every: str) -&gt; SeriesT\n</code></pre> <p>Divide the date/datetime range into buckets.</p> <p>Parameters:</p> Name Type Description Default <code>every</code> <code>str</code> <p>Length of bucket. Must be of form <code>&lt;multiple&gt;&lt;unit&gt;</code>, where <code>multiple</code> is a positive integer and <code>unit</code> is one of</p> <ul> <li>'ns': nanosecond.</li> <li>'us': microsecond.</li> <li>'ms': millisecond.</li> <li>'s': second.</li> <li>'m': minute.</li> <li>'h': hour.</li> <li>'d': day.</li> <li>'mo': month.</li> <li>'q': quarter.</li> <li>'y': year.</li> </ul> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>Series of data type <code>Date</code> or <code>Datetime</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([datetime(2021, 3, 1, 12, 34)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.truncate(\"1h\").to_native()\n0   2021-03-01 12:00:00\ndtype: datetime64[ns]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.weekday","title":"weekday","text":"<pre><code>weekday() -&gt; SeriesT\n</code></pre> <p>Extract the week day in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the week day for each datetime value.</p> <code>SeriesT</code> <p>Returns the ISO weekday number where monday = 1 and sunday = 7</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array(\n...     [[datetime(2020, 1, 1), datetime(2020, 8, 3)]]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.weekday().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    3,\n    1\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.year","title":"year","text":"<pre><code>year() -&gt; SeriesT\n</code></pre> <p>Get the year in a datetime series.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the year component of each datetime value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([datetime(2012, 1, 7), datetime(2023, 3, 10)])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.dt.year().to_native()\nshape: (2,)\nSeries: '' [i32]\n[\n        2012\n        2023\n]\n</code></pre>"},{"location":"api-reference/series_list/","title":"<code>narwhals.Series.list</code>","text":""},{"location":"api-reference/series_list/#narwhals.series.SeriesListNamespace.len","title":"len","text":"<pre><code>len() -&gt; SeriesT\n</code></pre> <p>Return the number of elements in each list.</p> <p>Null values count towards the total.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[[1, 2], [3, 4, None], None, []]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.list.len().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    2,\n    3,\n    null,\n    0\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/","title":"<code>narwhals.Series.str</code>","text":""},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.contains","title":"contains","text":"<pre><code>contains(pattern: str, *, literal: bool = False) -&gt; SeriesT\n</code></pre> <p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with boolean values indicating if each string contains the pattern.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"cat\", \"dog\", \"rabbit and parrot\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.contains(\"cat|parrot\").to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    true,\n    false,\n    true\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.ends_with","title":"ends_with","text":"<pre><code>ends_with(suffix: str) -&gt; SeriesT\n</code></pre> <p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with boolean values indicating if each string ends with the suffix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.ends_with(\"ngo\").to_native()\n0    False\n1     True\n2     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.head","title":"head","text":"<pre><code>head(n: int = 5) -&gt; SeriesT\n</code></pre> <p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the first n characters of each string.</p> Notes <ol> <li>When the <code>n</code> input is negative, <code>head</code> returns characters up to the n-th from the end of the string. For example, if <code>n = -3</code>, then all characters except the last three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"taata\", \"taatatata\", \"zukkyun\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.head().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"taata\",\n    \"taata\",\n    \"zukky\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.len_chars","title":"len_chars","text":"<pre><code>len_chars() -&gt; SeriesT\n</code></pre> <p>Return the length of each string as the number of characters.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the length of each string in characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"foo\", \"345\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.len_chars().to_native()\nshape: (3,)\nSeries: '' [u32]\n[\n        3\n        3\n        null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.replace","title":"replace","text":"<pre><code>replace(\n    pattern: str,\n    value: str,\n    *,\n    literal: bool = False,\n    n: int = 1\n) -&gt; SeriesT\n</code></pre> <p>Replace first matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <code>n</code> <code>int</code> <p>Number of matches to replace.</p> <code>1</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with the regex/literal pattern replaced with the specified value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"123abc\", \"abc abc123\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.replace(\"abc\", \"\").to_native()\n0        123\n1     abc123\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.replace_all","title":"replace_all","text":"<pre><code>replace_all(\n    pattern: str, value: str, *, literal: bool = False\n) -&gt; SeriesT\n</code></pre> <p>Replace all matching regex/literal substring with a new string value.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A valid regular expression pattern.</p> required <code>value</code> <code>str</code> <p>String that will replace the matched substring.</p> required <code>literal</code> <code>bool</code> <p>Treat <code>pattern</code> as a literal string.</p> <code>False</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with all occurrences of pattern replaced with the specified value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"123abc\", \"abc abc123\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.replace_all(\"abc\", \"\").to_native()\n0     123\n1     123\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.slice","title":"slice","text":"<pre><code>slice(offset: int, length: int | None = None) -&gt; SeriesT\n</code></pre> <p>Create subslices of the string values of a Series.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing subslices of each string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"pear\", None, \"papaya\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.slice(4, 3).to_native()\n0\n1    None\n2      ya\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.split","title":"split","text":"<pre><code>split(by: str) -&gt; SeriesT\n</code></pre> <p>Split the string values of a Series by a substring.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Substring to split by.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing lists of strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"foo bar\", \"foo_bar\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.split(\"_\").to_native()\nshape: (2,)\nSeries: '' [list[str]]\n[\n        [\"foo bar\"]\n        [\"foo\", \"bar\"]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.starts_with","title":"starts_with","text":"<pre><code>starts_with(prefix: str) -&gt; SeriesT\n</code></pre> <p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with boolean values indicating if each string starts with the prefix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", \"mango\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.starts_with(\"app\").to_native()\n0     True\n1    False\n2     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.strip_chars","title":"strip_chars","text":"<pre><code>strip_chars(characters: str | None = None) -&gt; SeriesT\n</code></pre> <p>Remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>characters</code> <code>str | None</code> <p>The set of characters to be removed. All combinations of this set of characters will be stripped from the start and end of the string. If set to None (default), all leading and trailing whitespace is removed instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with leading and trailing characters removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"apple\", \"\\nmango\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.strip_chars().to_native()\nshape: (2,)\nSeries: '' [str]\n[\n        \"apple\"\n        \"mango\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.tail","title":"tail","text":"<pre><code>tail(n: int = 5) -&gt; SeriesT\n</code></pre> <p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series containing the last n characters of each string.</p> Notes <ol> <li>When the <code>n</code> input is negative, <code>tail</code> returns characters starting from the n-th from the beginning of the string. For example, if <code>n = -3</code>, then all characters except the first three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pa.chunked_array([[\"taata\", \"taatatata\", \"zukkyun\"]])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.tail().to_native()\n&lt;pyarrow.lib.ChunkedArray object at ...&gt;\n[\n  [\n    \"taata\",\n    \"atata\",\n    \"kkyun\"\n  ]\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime(format: str | None = None) -&gt; SeriesT\n</code></pre> <p>Parse Series with strings to a Series with Datetime dtype.</p> Notes <ul> <li>pandas defaults to nanosecond time unit, Polars to microsecond.   Prior to pandas 2.0, nanoseconds were the only time unit supported   in pandas, with no ability to set any other one. The ability to   set the time unit in pandas, if the version permits, will arrive.</li> <li>timezone-aware strings are all converted to and parsed as UTC.</li> </ul> Warning <p>As different backends auto-infer format in different ways, if <code>format=None</code> there is no guarantee that the result will be equal.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> <p>Format to use for conversion. If set to None (default), the format is inferred from the data.</p> <code>None</code> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with datetime dtype.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series([\"2020-01-01\", \"2020-01-02\"])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_datetime(\n...     format=\"%Y-%m-%d\"\n... ).to_native()\nshape: (2,)\nSeries: '' [datetime[\u03bcs]]\n[\n        2020-01-01 00:00:00\n        2020-01-02 00:00:00\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_lowercase","title":"to_lowercase","text":"<pre><code>to_lowercase() -&gt; SeriesT\n</code></pre> <p>Transform string to lowercase variant.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with values converted to lowercase.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"APPLE\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_lowercase().to_native()\n0    apple\n1     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.to_uppercase","title":"to_uppercase","text":"<pre><code>to_uppercase() -&gt; SeriesT\n</code></pre> <p>Transform string to uppercase variant.</p> <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series with values converted to uppercase.</p> Notes <p>The PyArrow backend will convert '\u00df' to '\u1e9e' instead of 'SS'. For more info see: https://github.com/apache/arrow/issues/34599 There may be other unicode-edge-case-related variations across implementations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pd.Series([\"apple\", None])\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.str.to_uppercase().to_native()\n0    APPLE\n1     None\ndtype: object\n</code></pre>"},{"location":"api-reference/series_struct/","title":"<code>narwhals.Series.struct</code>","text":""},{"location":"api-reference/series_struct/#narwhals.series.SeriesStructNamespace.field","title":"field","text":"<pre><code>field(name: str) -&gt; SeriesT\n</code></pre> <p>Retrieve a Struct field as a new expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the struct field to retrieve.</p> required <p>Returns:</p> Type Description <code>SeriesT</code> <p>A new Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_native = pl.Series(\n...     [{\"id\": \"0\", \"name\": \"john\"}, {\"id\": \"1\", \"name\": \"jane\"}]\n... )\n&gt;&gt;&gt; s = nw.from_native(s_native, series_only=True)\n&gt;&gt;&gt; s.struct.field(\"name\").to_list()\n['john', 'jane']\n</code></pre>"},{"location":"api-reference/typing/","title":"<code>narwhals.typing</code>","text":"<p>Narwhals comes fully statically typed. In addition to <code>nw.DataFrame</code>, <code>nw.Expr</code>, <code>nw.Series</code>, <code>nw.LazyFrame</code>, we also provide the following type hints:</p>"},{"location":"api-reference/typing/#narwhals.typing.DataFrameT","title":"DataFrameT  <code>module-attribute</code>","text":"<pre><code>DataFrameT = TypeVar('DataFrameT', bound='DataFrame[Any]')\n</code></pre> <p>TypeVar bound to Narwhals DataFrame.</p> <p>Use this if your function can accept a Narwhals DataFrame and returns a Narwhals DataFrame backed by the same backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import DataFrameT\n&gt;&gt;&gt; @nw.narwhalify\n&gt;&gt;&gt; def func(df: DataFrameT) -&gt; DataFrameT:\n...     return df.with_columns(c=df[\"a\"] + 1)\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.Frame","title":"Frame  <code>module-attribute</code>","text":"<pre><code>Frame: TypeAlias = Union[\"DataFrame[Any]\", \"LazyFrame[Any]\"]\n</code></pre> <p>Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function can work with either and your function doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import Frame\n&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_columns(df: Frame) -&gt; list[str]:\n...     return df.columns\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.FrameT","title":"FrameT  <code>module-attribute</code>","text":"<pre><code>FrameT = TypeVar('FrameT', DataFrame[Any], LazyFrame[Any])\n</code></pre> <p>TypeVar bound to Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function accepts either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object of the same kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import FrameT\n&gt;&gt;&gt; @nw.narwhalify\n... def agnostic_func(df: FrameT) -&gt; FrameT:\n...     return df.with_columns(c=nw.col(\"a\") + 1)\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoDataFrame","title":"IntoDataFrame  <code>module-attribute</code>","text":"<pre><code>IntoDataFrame: TypeAlias = Union[\n    \"NativeFrame\", \"DataFrameLike\"\n]\n</code></pre> <p>Anything which can be converted to a Narwhals DataFrame.</p> <p>Use this if your function accepts a narwhalifiable object but doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoDataFrame\n&gt;&gt;&gt; def agnostic_shape(df_native: IntoDataFrame) -&gt; tuple[int, int]:\n...     df = nw.from_native(df_native, eager_only=True)\n...     return df.shape\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoDataFrameT","title":"IntoDataFrameT  <code>module-attribute</code>","text":"<pre><code>IntoDataFrameT = TypeVar(\n    \"IntoDataFrameT\", bound=\"IntoDataFrame\"\n)\n</code></pre> <p>TypeVar bound to object convertible to Narwhals DataFrame.</p> <p>Use this if your function accepts an object which can be converted to <code>nw.DataFrame</code> and returns an object of the same class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoDataFrameT\n&gt;&gt;&gt; def agnostic_func(df_native: IntoDataFrameT) -&gt; IntoDataFrameT:\n...     df = nw.from_native(df_native, eager_only=True)\n...     return df.with_columns(c=df[\"a\"] + 1).to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoExpr","title":"IntoExpr  <code>module-attribute</code>","text":"<pre><code>IntoExpr: TypeAlias = Union['Expr', str, 'Series[Any]']\n</code></pre> <p>Anything which can be converted to an expression.</p> <p>Use this to mean \"either a Narwhals expression, or something which can be converted into one\". For example, <code>exprs</code> in <code>DataFrame.select</code> is typed to accept <code>IntoExpr</code>, as it can either accept a <code>nw.Expr</code> (e.g. <code>df.select(nw.col('a'))</code>) or a string which will be interpreted as a <code>nw.Expr</code>, e.g. <code>df.select('a')</code>.</p>"},{"location":"api-reference/typing/#narwhals.typing.IntoFrame","title":"IntoFrame  <code>module-attribute</code>","text":"<pre><code>IntoFrame: TypeAlias = Union[\n    \"IntoDataFrame\", \"IntoLazyFrame\"\n]\n</code></pre> <p>Anything which can be converted to a Narwhals DataFrame or LazyFrame.</p> <p>Use this if your function can accept an object which can be converted to either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and it doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrame\n&gt;&gt;&gt; def agnostic_columns(df_native: IntoFrame) -&gt; list[str]:\n...     df = nw.from_native(df_native)\n...     return df.collect_schema().names()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoFrameT","title":"IntoFrameT  <code>module-attribute</code>","text":"<pre><code>IntoFrameT = TypeVar('IntoFrameT', bound='IntoFrame')\n</code></pre> <p>TypeVar bound to object convertible to Narwhals DataFrame or Narwhals LazyFrame.</p> <p>Use this if your function accepts an object which is convertible to <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object of the same type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoFrameT\n&gt;&gt;&gt; def agnostic_func(df_native: IntoFrameT) -&gt; IntoFrameT:\n...     df = nw.from_native(df_native)\n...     return df.with_columns(c=nw.col(\"a\") + 1).to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoSeries","title":"IntoSeries  <code>module-attribute</code>","text":"<pre><code>IntoSeries: TypeAlias = 'NativeSeries'\n</code></pre> <p>Anything which can be converted to a Narwhals Series.</p> <p>Use this if your function can accept an object which can be converted to <code>nw.Series</code> and it doesn't care about its backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Any\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoSeries\n&gt;&gt;&gt; def agnostic_to_list(s_native: IntoSeries) -&gt; list[Any]:\n...     s = nw.from_native(s_native)\n...     return s.to_list()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.IntoSeriesT","title":"IntoSeriesT  <code>module-attribute</code>","text":"<pre><code>IntoSeriesT = TypeVar('IntoSeriesT', bound='IntoSeries')\n</code></pre> <p>TypeVar bound to object convertible to Narwhals Series.</p> <p>Use this if your function accepts an object which can be converted to <code>nw.Series</code> and returns an object of the same class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from narwhals.typing import IntoSeriesT\n&gt;&gt;&gt; def agnostic_abs(s_native: IntoSeriesT) -&gt; IntoSeriesT:\n...     s = nw.from_native(s_native, series_only=True)\n...     return s.abs().to_native()\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.SizeUnit","title":"SizeUnit  <code>module-attribute</code>","text":"<pre><code>SizeUnit: TypeAlias = Literal[\n    \"b\",\n    \"kb\",\n    \"mb\",\n    \"gb\",\n    \"tb\",\n    \"bytes\",\n    \"kilobytes\",\n    \"megabytes\",\n    \"gigabytes\",\n    \"terabytes\",\n]\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.TimeUnit","title":"TimeUnit  <code>module-attribute</code>","text":"<pre><code>TimeUnit: TypeAlias = Literal['ns', 'us', 'ms', 's']\n</code></pre>"},{"location":"api-reference/typing/#narwhals.typing.AsofJoinStrategy","title":"AsofJoinStrategy  <code>module-attribute</code>","text":"<pre><code>AsofJoinStrategy: TypeAlias = Literal[\n    \"backward\", \"forward\", \"nearest\"\n]\n</code></pre> <p>Join strategy.</p> <ul> <li>\"backward\": Selects the last row in the right DataFrame whose <code>on</code> key     is less than or equal to the left's key.</li> <li>\"forward\": Selects the first row in the right DataFrame whose <code>on</code> key     is greater than or equal to the left's key.</li> <li>\"nearest\": Search selects the last row in the right DataFrame whose value     is nearest to the left's key.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.ClosedInterval","title":"ClosedInterval  <code>module-attribute</code>","text":"<pre><code>ClosedInterval: TypeAlias = Literal[\n    \"left\", \"right\", \"none\", \"both\"\n]\n</code></pre> <p>Define which sides of the interval are closed (inclusive).</p>"},{"location":"api-reference/typing/#narwhals.typing.ConcatMethod","title":"ConcatMethod  <code>module-attribute</code>","text":"<pre><code>ConcatMethod: TypeAlias = Literal[\n    \"horizontal\", \"vertical\", \"diagonal\"\n]\n</code></pre> <p>Concatenating strategy.</p> <ul> <li>\"vertical\": Concatenate vertically. Column names must match.</li> <li>\"horizontal\": Concatenate horizontally. If lengths don't match, then     missing rows are filled with null values.</li> <li>\"diagonal\": Finds a union between the column schemas and fills missing     column values with null.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.FillNullStrategy","title":"FillNullStrategy  <code>module-attribute</code>","text":"<pre><code>FillNullStrategy: TypeAlias = Literal[\"forward\", \"backward\"]\n</code></pre> <p>Strategy used to fill null values.</p>"},{"location":"api-reference/typing/#narwhals.typing.JoinStrategy","title":"JoinStrategy  <code>module-attribute</code>","text":"<pre><code>JoinStrategy: TypeAlias = Literal[\n    \"inner\", \"left\", \"full\", \"cross\", \"semi\", \"anti\"\n]\n</code></pre> <p>Join strategy.</p> <ul> <li>\"inner\": Returns rows that have matching values in both tables.</li> <li>\"left\": Returns all rows from the left table, and the matched rows from     the right table.</li> <li>\"full\": Returns all rows in both dataframes, with the <code>suffix</code> appended to     the right join keys.</li> <li>\"cross\": Returns the Cartesian product of rows from both tables.</li> <li>\"semi\": Filter rows that have a match in the right table.</li> <li>\"anti\": Filter rows that do not have a match in the right table.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.PivotAgg","title":"PivotAgg  <code>module-attribute</code>","text":"<pre><code>PivotAgg: TypeAlias = Literal[\n    \"min\",\n    \"max\",\n    \"first\",\n    \"last\",\n    \"sum\",\n    \"mean\",\n    \"median\",\n    \"len\",\n]\n</code></pre> <p>A predefined aggregate function string.</p>"},{"location":"api-reference/typing/#narwhals.typing.RankMethod","title":"RankMethod  <code>module-attribute</code>","text":"<pre><code>RankMethod: TypeAlias = Literal[\n    \"average\", \"min\", \"max\", \"dense\", \"ordinal\"\n]\n</code></pre> <p>The method used to assign ranks to tied elements.</p> <ul> <li>\"average\": The average of the ranks that would have been assigned to     all the tied values is assigned to each value.</li> <li>\"min\": The minimum of the ranks that would have been assigned to all     the tied values is assigned to each value. (This is also referred to     as \"competition\" ranking.)</li> <li>\"max\": The maximum of the ranks that would have been assigned to all     the tied values is assigned to each value.</li> <li>\"dense\": Like \"min\", but the rank of the next highest element is     assigned the rank immediately after those assigned to the tied elements.</li> <li>\"ordinal\": All values are given a distinct rank, corresponding to the     order that the values occur in the Series.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.RollingInterpolationMethod","title":"RollingInterpolationMethod  <code>module-attribute</code>","text":"<pre><code>RollingInterpolationMethod: TypeAlias = Literal[\n    \"nearest\", \"higher\", \"lower\", \"midpoint\", \"linear\"\n]\n</code></pre> <p>Interpolation method.</p>"},{"location":"api-reference/typing/#narwhals.typing.UniqueKeepStrategy","title":"UniqueKeepStrategy  <code>module-attribute</code>","text":"<pre><code>UniqueKeepStrategy: TypeAlias = Literal[\n    \"any\", \"first\", \"last\", \"none\"\n]\n</code></pre> <p>Which of the duplicate rows to keep.</p> <ul> <li>\"any\": Does not give any guarantee of which row is kept.     This allows more optimizations.</li> <li>\"none\": Don't keep duplicate rows.</li> <li>\"first\": Keep first unique row.</li> <li>\"last\": Keep last unique row.</li> </ul>"},{"location":"api-reference/typing/#narwhals.typing.LazyUniqueKeepStrategy","title":"LazyUniqueKeepStrategy  <code>module-attribute</code>","text":"<pre><code>LazyUniqueKeepStrategy: TypeAlias = Literal['any', 'none']\n</code></pre> <p>Which of the duplicate rows to keep.</p> <ul> <li>\"any\": Does not give any guarantee of which row is kept.</li> <li>\"none\": Don't keep duplicate rows.</li> </ul>"},{"location":"api-reference/typing/#nwnarwhalify-or-nwfrom_native","title":"<code>nw.narwhalify</code>, or <code>nw.from_native</code>?","text":"<p>Although some people find the former more readable, the latter is better at preserving type hints.</p> <p>Here's an example: <pre><code>import polars as pl\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT, DataFrameT\n\ndf = pl.DataFrame({\"a\": [1, 2, 3]})\n\n\ndef func(df_native: IntoDataFrameT) -&gt; IntoDataFrameT:\n    df = nw.from_native(df_native, eager_only=True)\n    return df.select(b=nw.col(\"a\")).to_native()\n\n\nreveal_type(func(df))\n\n\n@nw.narwhalify(strict=True)\ndef func_2(df: DataFrameT) -&gt; DataFrameT:\n    return df.select(b=nw.col(\"a\"))\n\n\nreveal_type(func_2(df))\n</code></pre></p> <p>Running <code>mypy</code> on it gives: <pre><code>$ mypy t.py \nt.py:13: note: Revealed type is \"polars.dataframe.frame.DataFrame\"\nt.py:21: note: Revealed type is \"Any\"\nSuccess: no issues found in 1 source file\n</code></pre></p> <p>In the first case, mypy can infer that <code>df</code> is a <code>polars.DataFrame</code>. In the second case, it can't.</p> <p>If you want to make the most out of type hints and preserve them as much as possible, we recommend <code>nw.from_native</code> and <code>nw.to_native</code>. Type hints will still be respected inside the function body if you type the arguments.</p>"},{"location":"basics/complete_example/","title":"Complete example","text":"<p>We're going to write a dataframe-agnostic \"Standard Scaler\". This class will have <code>fit</code> and <code>transform</code> methods (like <code>scikit-learn</code> transformers), and will work agnostically for pandas and Polars.</p> <p>We'll need to write two methods:</p> <ul> <li><code>fit</code>: find the mean and standard deviation for each column from a given training set;</li> <li><code>transform</code>: scale a given dataset with the mean and standard deviations calculated   during <code>fit</code>.</li> </ul>"},{"location":"basics/complete_example/#fit-method","title":"Fit method","text":"<p>Unlike the <code>transform</code> method, which we'll write below, <code>fit</code> cannot stay lazy, as we need to compute concrete values for the means and standard deviations.</p> <p>To be able to get <code>Series</code> out of our <code>DataFrame</code>, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code>. This is because Polars doesn't have a concept of lazy <code>Series</code>, and so Narwhals doesn't either.</p> <p>We can specify that in the <code>@nw.narwhalify</code> decorator by setting <code>eager_only=True</code>, and the argument will be propagated to <code>nw.from_native</code>.</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\n\n\nclass StandardScaler:\n    def fit(self, df: IntoDataFrameT) -&gt; Self:\n        df_nw = nw.from_native(df, eager_only=True)\n        self._means = {col: df_nw[col].mean() for col in df_nw.columns}\n        self._std_devs = {col: df_nw[col].std() for col in df_nw.columns}\n        self._columns = df_nw.columns\n        return self\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: DataFrameT) -&gt; Self:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n        self._columns = df.columns\n        return self\n</code></pre>"},{"location":"basics/complete_example/#transform-method","title":"Transform method","text":"<p>We're going to take in a dataframe, and return a dataframe of the same type:</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\nclass StandardScaler:\n    ...\n\n    def transform(self, df: IntoFrameT) -&gt; IntoFrameT:\n        df_nw = nw.from_native(df)\n        return df_nw.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        ).to_native()\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import FrameT\n\n\nclass StandardScaler:\n    ...\n\n    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        )\n</code></pre> <p>Note that all the calculations here can stay lazy if the underlying library permits it, so we don't pass in any extra keyword-arguments such as <code>eager_only</code>, we just use the default <code>eager_only=False</code>.</p>"},{"location":"basics/complete_example/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is our dataframe-agnostic standard scaler:</p> from/to_native@narwhalify <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\nfrom narwhals.typing import IntoFrameT\n\n\nclass StandardScaler:\n    def fit(self, df: IntoDataFrameT) -&gt; Self:\n        df_nw = nw.from_native(df, eager_only=True)\n        self._means = {col: df_nw[col].mean() for col in df_nw.columns}\n        self._std_devs = {col: df_nw[col].std() for col in df_nw.columns}\n        self._columns = df_nw.columns\n        return self\n\n    def transform(self, df: IntoFrameT) -&gt; IntoFrameT:\n        df_nw = nw.from_native(df)\n        return df_nw.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        ).to_native()\n</code></pre> <pre><code>from typing import Self\nimport narwhals as nw\nfrom narwhals.typing import DataFrameT\nfrom narwhals.typing import FrameT\n\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: DataFrameT) -&gt; Self:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n        self._columns = df.columns\n        return self\n\n    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in self._columns\n        )\n</code></pre> <p>Next, let's try running it. Notice how, as <code>transform</code> doesn't use any eager-only features, so we can pass a Polars LazyFrame to it and have it stay lazy!</p> pandasPolars <pre><code>import pandas as pd\n\ndf_train = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\ndf_test = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test))\n</code></pre> <pre><code>     a         b\n0 -1.0 -0.872872\n1  0.0 -0.218218\n2  1.0  1.091089\n</code></pre> <pre><code>import polars as pl\n\ndf_train = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\ndf_test = pl.LazyFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b         \u2502\n\u2502 ---  \u2506 ---       \u2502\n\u2502 f64  \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1.0 \u2506 -0.872872 \u2502\n\u2502 0.0  \u2506 -0.218218 \u2502\n\u2502 1.0  \u2506 1.091089  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/","title":"DataFrame","text":"<p>To write a dataframe-agnostic function, the steps you'll want to follow are:</p> <ol> <li> <p>Initialise a Narwhals DataFrame or LazyFrame by passing your dataframe to <code>nw.from_native</code>.     All the calculations stay lazy if we start with a lazy dataframe - Narwhals will never automatically trigger computation without you asking it to.</p> <p>Note: if you need eager execution, make sure to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p> </li> <li> <p>Express your logic using the subset of the Polars API supported by Narwhals.</p> </li> <li>If you need to return a dataframe to the user in its original library, call <code>nw.to_native</code>.</li> </ol> <p>Steps 1 and 3 are so common that we provide a utility <code>@nw.narwhalify</code> decorator, which allows you to only explicitly write step 2.</p> <p>Let's explore this with some simple examples.</p>"},{"location":"basics/dataframe/#example-1-descriptive-statistics","title":"Example 1: descriptive statistics","text":"<p>Just like in Polars, we can pass expressions to <code>DataFrame.select</code> or <code>LazyFrame.select</code>.</p> <p>Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .select(\n            a_sum=nw.col(\"a\").sum(),\n            a_mean=nw.col(\"a\").mean(),\n            a_std=nw.col(\"a\").std(),\n        )\n        .to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.select(\n        a_sum=nw.col(\"a\").sum(),\n        a_mean=nw.col(\"a\").mean(),\n        a_std=nw.col(\"a\").std(),\n    )\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>   a_sum    a_mean    a_std\n0      4  1.333333  0.57735\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na_sum: int64\na_mean: double\na_std: double\n----\na_sum: [[4]]\na_mean: [[1.3333333333333333]]\na_std: [[0.5773502691896257]]\n</code></pre>"},{"location":"basics/dataframe/#example-2-group-by-and-mean","title":"Example 2: group-by and mean","text":"<p>Just like in Polars, we can pass expressions to <code>GroupBy.agg</code>. Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df).group_by(\"a\").agg(nw.col(\"b\").mean()).sort(\"a\").to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.group_by(\"a\").agg(nw.col(\"b\").mean()).sort(\"a\")\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a    b\n0  1  4.5\n1  2  6.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: double\n----\na: [[1,2]]\nb: [[4.5,6]]\n</code></pre>"},{"location":"basics/dataframe/#example-3-horizontal-sum","title":"Example 3: horizontal sum","text":"<p>Expressions can be free-standing functions which accept other expressions as inputs. For example, we can compute a horizontal sum using <code>nw.sum_horizontal</code>.</p> <p>Make a Python file with the following content:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef func(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .with_columns(a_plus_b=nw.sum_horizontal(\"a\", \"b\"))\n        .to_native()\n    )\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(a_plus_b=nw.sum_horizontal(\"a\", \"b\"))\n</code></pre> <p>Let's try it out:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a  b  a_plus_b\n0  1  4         5\n1  1  5         6\n2  2  6         8\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2], \"b\": [4, 5, 6]})\nprint(func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\na_plus_b: int64\n----\na: [[1,1,2]]\nb: [[4,5,6]]\na_plus_b: [[5,6,8]]\n</code></pre>"},{"location":"basics/dataframe/#example-4-multiple-inputs","title":"Example 4: multiple inputs","text":"<p><code>nw.narwhalify</code> can be used to decorate functions that take multiple inputs as well and return a non dataframe/series-like object.</p> <p>For example, let's compute how many rows are left in a dataframe after filtering it based on a series.</p> <p>Make a Python file with the following content:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\n@nw.narwhalify(eager_only=True)\ndef func(df: DataFrameT, s: nw.Series, col_name: str) -&gt; int:\n    return df.filter(nw.col(col_name).is_in(s)).shape[0]\n</code></pre> <p>We require <code>eager_only=True</code> here because lazyframe doesn't support <code>.shape</code>.</p> <p>Let's try it out:</p> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\ns = pd.Series([1, 3])\nprint(func(df, s.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\ns = pl.Series([1, 3])\nprint(func(df, s.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [1, 1, 2, 2, 3], \"b\": [4, 5, 6, 7, 8]})\na = pa.array([1, 3])\nprint(func(table, a.to_numpy(), \"a\"))\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"basics/dataframe_conversion/","title":"Conversion between libraries","text":"<p>Some library maintainers must apply complex dataframe operations, using methods and functions that may not (yet) be implemented in Narwhals. In such cases, Narwhals can still be highly beneficial, by allowing easy dataframe conversion.</p>"},{"location":"basics/dataframe_conversion/#dataframe-x-in-pandas-out","title":"Dataframe X in, pandas out","text":"<p>Imagine that you maintain a library with a function that operates on pandas dataframes to produce automated reports. You want to allow users to supply a dataframe in any format to that function (pandas, Polars, DuckDB, cuDF, Modin, etc.) without adding all those dependencies to your own project and without special-casing each input library's variation of <code>to_pandas</code> / <code>toPandas</code> / <code>to_pandas_df</code> / <code>df</code> ...</p> <p>One solution is to use Narwhals as a thin Dataframe ingestion layer, to convert user-supplied dataframe to the format that your library uses internally. Since Narwhals is zero-dependency, this is a much more lightweight solution than including all the dataframe libraries as dependencies, and easier to write than special casing each input library's <code>to_pandas</code> method (if it even exists!).</p> <p>To illustrate, we create dataframes in various formats:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoDataFrame\nfrom typing import Any\n\nimport duckdb\nimport polars as pl\nimport pandas as pd\n\ndf_polars = pl.DataFrame(\n    {\n        \"A\": [1, 2, 3, 4, 5],\n        \"fruits\": [\"banana\", \"banana\", \"apple\", \"apple\", \"banana\"],\n        \"B\": [5, 4, 3, 2, 1],\n        \"cars\": [\"beetle\", \"audi\", \"beetle\", \"beetle\", \"beetle\"],\n    }\n)\ndf_pandas = df_polars.to_pandas()\ndf_duckdb = duckdb.sql(\"SELECT * FROM df_polars\")\n</code></pre> <p>Now, we define a function that can ingest any dataframe type supported by Narwhals, and convert it to a pandas DataFrame for internal use:</p> <pre><code>def df_to_pandas(df: IntoDataFrame) -&gt; pd.DataFrame:\n    return nw.from_native(df).to_pandas()\n\n\nprint(df_to_pandas(df_polars))\n</code></pre> <pre><code>   A  fruits  B    cars\n0  1  banana  5  beetle\n1  2  banana  4    audi\n2  3   apple  3  beetle\n3  4   apple  2  beetle\n4  5  banana  1  beetle\n</code></pre>"},{"location":"basics/dataframe_conversion/#dataframe-x-in-polars-out","title":"Dataframe X in, Polars out","text":""},{"location":"basics/dataframe_conversion/#via-pycapsule-interface","title":"Via PyCapsule Interface","text":"<p>Similarly, if your library uses Polars internally, you can convert any user-supplied dataframe which implements <code>__arrow_c_stream__</code>:</p> <pre><code>def df_to_polars(df_native: Any) -&gt; pl.DataFrame:\n    if hasattr(df_native, \"__arrow_c_stream__\"):\n        return nw.from_arrow(df_native, backend=pl).to_native()\n    msg = (\n        f\"Expected object which implements '__arrow_c_stream__' got: {type(df_native)}\"\n    )\n    raise TypeError(msg)\n\n\nprint(df_to_polars(df_duckdb))  # You can only execute this line of code once.\n</code></pre> <pre><code>shape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2506 fruits \u2506 B   \u2506 cars   \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 str    \u2506 i64 \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 banana \u2506 5   \u2506 beetle \u2502\n\u2502 2   \u2506 banana \u2506 4   \u2506 audi   \u2502\n\u2502 3   \u2506 apple  \u2506 3   \u2506 beetle \u2502\n\u2502 4   \u2506 apple  \u2506 2   \u2506 beetle \u2502\n\u2502 5   \u2506 banana \u2506 1   \u2506 beetle \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>It works to pass Polars to <code>backend</code> here because Polars supports the PyCapsule Interface for import.</p> <p>Note that the PyCapsule Interface makes no guarantee that you can call it repeatedly, so the approach above only works if you only expect to perform the conversion a single time on each input object.</p>"},{"location":"basics/dataframe_conversion/#via-pyarrow","title":"Via PyArrow","text":"<p>If you need to ingest the same dataframe multiple times, then you may want to go via PyArrow instead. This may be less efficient than the PyCapsule approach above (and always requires PyArrow!), but is more forgiving:</p> <pre><code>def df_to_polars(df_native: IntoDataFrame) -&gt; pl.DataFrame:\n    df = nw.from_native(df_native).lazy().collect()\n    return pl.DataFrame(nw.from_native(df, eager_only=True).to_arrow())\n\n\ndf_duckdb = duckdb.sql(\"SELECT * FROM df_polars\")\nprint(df_to_polars(df_duckdb))  # We can execute this...\nprint(df_to_polars(df_duckdb))  # ...as many times as we like!\n</code></pre> <pre><code>shape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2506 fruits \u2506 B   \u2506 cars   \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 str    \u2506 i64 \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 banana \u2506 5   \u2506 beetle \u2502\n\u2502 2   \u2506 banana \u2506 4   \u2506 audi   \u2502\n\u2502 3   \u2506 apple  \u2506 3   \u2506 beetle \u2502\n\u2502 4   \u2506 apple  \u2506 2   \u2506 beetle \u2502\n\u2502 5   \u2506 banana \u2506 1   \u2506 beetle \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2506 fruits \u2506 B   \u2506 cars   \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 ---    \u2502\n\u2502 i64 \u2506 str    \u2506 i64 \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 banana \u2506 5   \u2506 beetle \u2502\n\u2502 2   \u2506 banana \u2506 4   \u2506 audi   \u2502\n\u2502 3   \u2506 apple  \u2506 3   \u2506 beetle \u2502\n\u2502 4   \u2506 apple  \u2506 2   \u2506 beetle \u2502\n\u2502 5   \u2506 banana \u2506 1   \u2506 beetle \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/series/","title":"Series","text":"<p>In dataframe, you learned how to write a dataframe-agnostic function.</p> <p>We only used DataFrame methods there - but what if we need to operate on its columns? There are two ways to do this:</p> <ul> <li>Series, e.g. <code>df.with_columns(df['a']*2)</code>.</li> <li>expressions, e.g. <code>df.with_columns(nw.col('a')*2)</code>.</li> </ul> <p>Expressions are by far the preferred way:</p> <ul> <li>They're inherently lazy and allow for optimisations.</li> <li>They the most idiomatic and portable solution.</li> <li>Series is only available for eager backends.</li> </ul> <p>Nonetheless, you might need to write dataframe-agnostic code which accepts user-provided Series. In that case, you'll need to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p>"},{"location":"basics/series/#example-1-filter-based-on-a-columns-values","title":"Example 1: filter based on a column's values","text":"<p>This can stay lazy, so we just use expressions:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).filter(nw.col(\"a\") &gt; 0).to_native()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.filter(nw.col(\"a\") &gt; 0)\n</code></pre> <p>and call it either on a eager or lazy dataframe:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n1  1  5\n2  3 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\n----\na: [[1,3]]\nb: [[5,-3]]\n</code></pre>"},{"location":"basics/series/#example-2-multiply-a-columns-values-by-a-constant","title":"Example 2: multiply a column's values by a constant","text":"<p>Let's write a dataframe-agnostic function which multiplies the values in column <code>'a'</code> by 2. This can also stay lazy, and can use expressions:</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns(nw.col(\"a\") * 2).to_native()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col(\"a\") * 2)\n</code></pre> <p>and call it either on a eager or lazy dataframe:</p> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0 -2  3\n1  2  5\n2  6 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\n----\na: [[-2,2,6]]\nb: [[3,5,-3]]\n</code></pre> <p>Note that column <code>'a'</code> was overwritten. If we had wanted to add a new column called <code>'c'</code> containing column <code>'a'</code>'s values multiplied by 2, we could have used <code>Expr.alias</code>:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns((nw.col(\"a\") * 2).alias(\"c\"))\n</code></pre> pandasPolars (eager)Polars (lazy)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  c\n0 -1  3 -2\n1  1  5  2\n2  3 -3  6\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>pyarrow.Table\na: int64\nb: int64\nc: int64\n----\na: [[-1,1,3]]\nb: [[3,5,-3]]\nc: [[-2,2,6]]\n</code></pre>"},{"location":"basics/series/#example-3-finding-the-mean-of-a-column-as-a-scalar","title":"Example 3: finding the mean of a column as a scalar","text":"<p>Now, we want to find the mean of column <code>'a'</code>, and we need it as a Python scalar. This means that computation cannot stay lazy - it must execute! Therefore, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code> (or <code>nw.narwhalify</code>), and then, instead of using expressions, we'll extract a <code>Series</code>.</p> from/to_native@narwhalify <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\n\n\ndef my_func(df: IntoDataFrameT) -&gt; float | None:\n    return nw.from_native(df, eager_only=True)[\"a\"].mean()\n</code></pre> <pre><code>import narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n\n@nw.narwhalify(eager_only=True)\ndef my_func(df: DataFrameT) -&gt; float | None:\n    return df[\"a\"].mean()\n</code></pre> <p>Now we can call it on a eager dataframe only:</p> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table({\"a\": [-1, 1, 3], \"b\": [3, 5, -3]})\nprint(my_func(table))\n</code></pre> <pre><code>1.0\n</code></pre> <p>Note that, even though the output of our function is not a dataframe nor a series, we can still use <code>narwhalify</code>.</p>"},{"location":"concepts/boolean/","title":"Boolean columns","text":"<p>Generally speaking, Narwhals operations preserve null values. For example, if you do <code>nw.col('a')*2</code>, then:</p> <ul> <li>Values which were non-null get multiplied by 2.</li> <li>Null values stay null.</li> </ul> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1.4, None, 4.2]}\n\n\ndef multiplication(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns((nw.col(\"a\") * 2).alias(\"a*2\")).to_native()\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(multiplication(df))\n</code></pre> <pre><code>     a  a*2\n0  1.4  2.8\n1  NaN  NaN\n2  4.2  8.4\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(multiplication(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a*2  \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.4  \u2506 2.8  \u2502\n\u2502 null \u2506 null \u2502\n\u2502 4.2  \u2506 8.4  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table(data)\nprint(multiplication(table))\n</code></pre> <pre><code>pyarrow.Table\na: double\na*2: double\n----\na: [[1.4,null,4.2]]\na*2: [[2.8,null,8.4]]\n</code></pre> <p>What do we do, however, when the result column is boolean? For example, <code>nw.col('a') &gt; 0</code>? Unfortunately, this is backend-dependent:</p> <ul> <li>for all backends except pandas, null values are preserved</li> <li>for pandas, this depends on the dtype backend:<ul> <li>for PyArrow dtypes and pandas nullable dtypes, null values are preserved</li> <li>for the classic NumPy dtypes, null values are typically filled in with <code>False</code>.</li> </ul> </li> </ul> <p>pandas is generally moving towards nullable dtypes, and they may become the default in the future, so we hope that the classical NumPy dtypes not supporting null values will just be a temporary legacy pandas issue which will eventually go away anyway.</p> <pre><code>from narwhals.typing import FrameT\n\n\ndef comparison(df: FrameT) -&gt; FrameT:\n    return nw.from_native(df).with_columns((nw.col(\"a\") &gt; 2).alias(\"a&gt;2\")).to_native()\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(comparison(df))\n</code></pre> <pre><code>     a    a&gt;2\n0  1.4  False\n1  NaN  False\n2  4.2   True\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(comparison(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a&gt;2   \u2502\n\u2502 ---  \u2506 ---   \u2502\n\u2502 f64  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.4  \u2506 false \u2502\n\u2502 null \u2506 null  \u2502\n\u2502 4.2  \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ntable = pa.table(data)\nprint(comparison(table))\n</code></pre> <pre><code>pyarrow.Table\na: double\na&gt;2: bool\n----\na: [[1.4,null,4.2]]\na&gt;2: [[false,null,true]]\n</code></pre>"},{"location":"concepts/column_names/","title":"Column names","text":"<p>Polars and PyArrow only allow for string column names. What about pandas?</p> <pre><code>import pandas as pd\n\ndf = pd.concat([pd.Series([1, 2], name=0), pd.Series([1, 3], name=0)], axis=1)\nprint(df)\n</code></pre> <pre><code>   0  0\n0  1  1\n1  2  3\n</code></pre> <p>Oh...not only does it let us create a dataframe with a column named <code>0</code> - it lets us create one with two such columns!</p> <p>What does Narwhals do about this?</p> <ul> <li>In general, non-string column names are supported. In some places where this might   create ambiguity (such as <code>DataFrame.__getitem__</code> or <code>DataFrame.select</code>) we may be strict and only   allow passing in column names if they're strings.</li> <li>If you have a use-case that's   failing for non-string column names, please report it to https://github.com/narwhals-dev/narwhals/issues   and we'll see if we can support it.</li> <li>Duplicate column names are \ud83d\udeab banned \ud83d\udeab.</li> </ul>"},{"location":"concepts/improve_group_by_operation/","title":"Avoiding the <code>UserWarning</code> error while using Pandas <code>group_by</code>","text":""},{"location":"concepts/improve_group_by_operation/#introduction","title":"Introduction","text":"<p>If you have ever experienced the</p> <p>UserWarning: Found complex group-by expression, which can't be expressed efficiently with the pandas API. If you can, please rewrite your query such that group-by aggregations are simple (e.g. mean, std, min, max, ...)</p> <p>message while using the narwhals <code>group_by()</code> method, this is for you. If you haven't, this is also for you as you might experience it and you need to know how to avoid it.</p> <p>Take the following two codes as an example.</p> Approach 1Approach 2 <pre><code>import narwhals as nw\nimport pandas as pd\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1, 2, 3, 4, 5], \"b\": [5, 4, 3, 2, 1], \"c\": [10, 20, 30, 40, 50]}\n\ndf_pd = pd.DataFrame(data)\n\n\ndef approach_1(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    df = df.group_by(\"a\").agg(d=(nw.col(\"b\") + nw.col(\"c\")).sum())\n    return df.to_native()\n\n\nprint(approach_1(df_pd))\n</code></pre> <pre><code>   a   d\n0  1  15\n1  2  24\n2  3  33\n3  4  42\n4  5  51\n</code></pre> <pre><code>import narwhals as nw\nimport pandas as pd\n\ndata = {\"a\": [1, 2, 3, 4, 5], \"b\": [5, 4, 3, 2, 1], \"c\": [10, 20, 30, 40, 50]}\n\ndf_pd = pd.DataFrame(data)\n\n\ndef approach_2(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    df = df.with_columns(d=nw.col(\"b\") + nw.col(\"c\")).group_by(\"a\").agg(nw.sum(\"d\"))\n    return df.to_native()\n\n\nprint(approach_2(df_pd))\n</code></pre> <pre><code>   a   d\n0  1  15\n1  2  24\n2  3  33\n3  4  42\n4  5  51\n</code></pre> <p>Both approaches shown above return the exact same result, but Approach 1 is inefficient and returns the warning message we showed at the top.</p> <p>What makes the first approach inefficient and the second approach efficient? It comes down to what the pandas API lets us express.</p>"},{"location":"concepts/improve_group_by_operation/#approach-1","title":"Approach 1","text":"<p>The literal pandas translation is:</p> <pre><code>df.groupby(\"a\").apply(\n    lambda df: pd.Series([(df[\"b\"] + df[\"c\"]).sum()], index=[\"d\"]), include_groups=False\n)\n</code></pre> <p>pandas experts immediately recognise the issue: it uses <code>apply</code>. Any time you use <code>apply</code> in pandas, that's a performance footgun - best to avoid it and use vectorised operations instead. Let's take a look at how \"approach 2\" gets translated to pandas to see the difference.</p>"},{"location":"concepts/improve_group_by_operation/#approach-2","title":"Approach 2","text":"<p>The literal pandas translation is:</p> <pre><code>df.assign(d=lambda df: df[\"b\"] + df[\"c\"]).groupby(\"a\").agg({\"d\": \"sum\"})\n</code></pre> <p>Because we're using pandas' own API, as opposed to <code>apply</code> and a custom <code>lambda</code> function, then this is going to be much more efficient! That's why it's preferred.</p>"},{"location":"concepts/improve_group_by_operation/#tips-for-avoiding-the-userwarning","title":"Tips for Avoiding the <code>UserWarning</code>","text":"<ol> <li>Decompose complex operations: break down complex transformations into simpler steps.    In this case, keep the <code>.agg</code> method simple.    Compute new columns first, then use these columns in aggregation or other operations.</li> <li>Avoid redundant computations: if an operation (like addition) is used multiple times,    compute it once and store the result in a new column.</li> </ol> <p>Happy grouping! \ud83e\udee1</p>"},{"location":"concepts/null_handling/","title":"Null/NaN handling","text":"<p>pandas doesn't distinguish between Null and NaN values as Polars and PyArrow do.</p> <p>Depending on the data type of the underlying data structure, <code>np.nan</code>, <code>pd.NaT</code>, <code>None</code> and <code>pd.NA</code> all encode missing data in pandas.</p> <p>Polars and PyArrow, instead, treat <code>NaN</code> as a valid floating point value which is rare to encounter and more often produced as the result of a computation than explicitly set during data initialization; they treat <code>null</code> as the missing data indicator, regardless of the data type.</p> <p>In Narwhals, then, <code>is_null</code> behaves differently across backends (and so do <code>drop_nulls</code>, <code>fill_null</code> and <code>null_count</code>):</p> <pre><code>import narwhals as nw\nimport numpy as np\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [1.4, float(\"nan\"), np.nan, 4.2, None]}\n\n\ndef check_null_behavior(df: IntoFrameT) -&gt; IntoFrameT:\n    return nw.from_native(df).with_columns(a_is_null=nw.col(\"a\").is_null()).to_native()\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>     a  a_is_null\n0  1.4      False\n1  NaN       True\n2  NaN       True\n3  4.2      False\n4  NaN       True\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a_is_null \u2502\n\u2502 ---  \u2506 ---       \u2502\n\u2502 f64  \u2506 bool      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.4  \u2506 false     \u2502\n\u2502 NaN  \u2506 false     \u2502\n\u2502 NaN  \u2506 false     \u2502\n\u2502 4.2  \u2506 false     \u2502\n\u2502 null \u2506 true      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ndf = pa.table(data)\nprint(check_null_behavior(df))\n</code></pre> <pre><code>pyarrow.Table\na: double\na_is_null: bool\n----\na: [[1.4,nan,nan,4.2,null]]\na_is_null: [[false,false,false,false,true]]\n</code></pre> <p>Conversely, <code>is_nan</code> is consistent across backends. This consistency comes from Narwhals exploiting its native implementations in Polars and PyArrow, while ensuring that pandas only identifies the floating-point NaN values and not those encoding the missing value indicator.</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\ndata = {\"a\": [0.0, None, 2.0]}\n\n\ndef check_nan_behavior(df: IntoFrameT) -&gt; IntoFrameT:\n    return (\n        nw.from_native(df)\n        .with_columns(\n            a_div_a=(nw.col(\"a\") / nw.col(\"a\")),\n            a_div_a_is_nan=(nw.col(\"a\") / nw.col(\"a\")).is_nan(),\n        )\n        .to_native()\n    )\n</code></pre> pandasPolars (eager)PyArrow <pre><code>import pandas as pd\n\ndf = pd.DataFrame(data).astype({\"a\": \"Float64\"})\nprint(check_nan_behavior(df))\n</code></pre> <pre><code>      a  a_div_a  a_div_a_is_nan\n0   0.0      NaN            True\n1  &lt;NA&gt;     &lt;NA&gt;            &lt;NA&gt;\n2   2.0      1.0           False\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame(data)\nprint(check_nan_behavior(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 a_div_a \u2506 a_div_a_is_nan \u2502\n\u2502 ---  \u2506 ---     \u2506 ---            \u2502\n\u2502 f64  \u2506 f64     \u2506 bool           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0.0  \u2506 NaN     \u2506 true           \u2502\n\u2502 null \u2506 null    \u2506 null           \u2502\n\u2502 2.0  \u2506 1.0     \u2506 false          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import pyarrow as pa\n\ndf = pa.table(data)\nprint(check_nan_behavior(df))\n</code></pre> <pre><code>pyarrow.Table\na: double\na_div_a: double\na_div_a_is_nan: bool\n----\na: [[0,null,2]]\na_div_a: [[nan,null,1]]\na_div_a_is_nan: [[true,null,false]]\n</code></pre>"},{"location":"concepts/order_dependence/","title":"Order-dependence","text":"<p>Narwhals has four main public classes:</p> <ul> <li><code>Expr</code>: this is what gets created when you write <code>nw.col('a')</code>.</li> <li><code>DataFrame</code>: in-memory, eager dataframe with a well-defined row order which   is preserved across <code>with_columns</code> and <code>select</code> operations.</li> <li><code>LazyFrame</code>: a dataframe which makes no assumptions about row-ordering. This   allows it to be backed by SQL engines.</li> <li><code>Series</code>: 1-dimensional in-memory structure with a defined row order. This is   what you get if you extract a single column from a <code>DataFrame</code>.</li> </ul> <p>Row order is important to think about when performing operations which rely on it, such as:</p> <ul> <li><code>diff</code>, <code>shift</code>.</li> <li><code>cum_sum</code>, <code>cum_min</code>, ...</li> <li><code>rolling_sum</code>, <code>rolling_min</code>, ...</li> <li><code>is_first_distinct</code>, <code>is_last_distinct</code>.</li> </ul> <p>When row-order is defined, as is the case for <code>DataFrame</code>, these operations pose no issue.</p> <pre><code>import narwhals as nw\nimport pandas as pd\n\ndata = {\"a\": [1, 3, 4], \"i\": [0, 1, 2]}\ndf = nw.from_native(pd.DataFrame(data))\nprint(df.with_columns(a_cum_sum=nw.col(\"a\").cum_sum()))\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|Narwhals DataFrame|\n|------------------|\n|   a  i  a_cum_sum|\n|0  1  0          1|\n|1  3  1          4|\n|2  4  2          8|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When row order is undefined however, then these operations do not have a defined result. To make them well-defined, you need to follow them with <code>over</code> in which you specify <code>order_by</code>. For example:</p> <ul> <li><code>nw.col('a').cum_sum()</code> can only be executed by a <code>DataFrame</code>.</li> <li><code>nw.col('a').cum_sum().over(order_by=\"i\")</code> can only be executed by either a <code>DataFrame</code>   or a <code>LazyFrame</code>.</li> </ul> <pre><code>import polars as pl\n\nlf = nw.from_native(pl.LazyFrame(data))\nresult = lf.with_columns(a_cum_sum=nw.col(\"a\").cum_sum().over(order_by=\"i\"))\nprint(result.collect())\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n|   Narwhals DataFrame    |\n|-------------------------|\n|shape: (3, 3)            |\n|\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510|\n|\u2502 a   \u2506 i   \u2506 a_cum_sum \u2502|\n|\u2502 --- \u2506 --- \u2506 ---       \u2502|\n|\u2502 i64 \u2506 i64 \u2506 i64       \u2502|\n|\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561|\n|\u2502 1   \u2506 0   \u2506 1         \u2502|\n|\u2502 3   \u2506 1   \u2506 4         \u2502|\n|\u2502 4   \u2506 2   \u2506 8         \u2502|\n|\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518|\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>When writing an order-dependent function, if you want it to be executable by <code>LazyFrame</code> (and not just <code>DataFrame</code>), make sure that all order-dependent expressions are followed by <code>over</code> with <code>order_by</code> specified. If you forget to, don't worry, Narwhals will give you a loud and clear error message.</p>"},{"location":"concepts/pandas_index/","title":"What about the pandas Index?","text":"<p>There are two types of pandas users:</p> <ul> <li>The ones who make full use of the Index's power.</li> <li>The <code>.reset_index(drop=True)</code> ones, who would rather not think about the Index.</li> </ul> <p>Narwhals aims to accommodate both!</p> <ul> <li>If you'd rather not think about the Index, then don't   worry: it's not part of the Narwhals public API, and you'll never have to worry about   resetting the index or about pandas doing funky index alignment for you.</li> <li>If you want your library to cater to Index powerusers who would be very angry if you reset   their beautiful Index on their behalf, then don't worry: Narwhals makes certain promises   with regards to the Index.</li> </ul> <p>Let's learn about what Narwhals promises.</p>"},{"location":"concepts/pandas_index/#1-narwhals-will-preserve-your-index-for-common-dataframe-operations","title":"1. Narwhals will preserve your index for common dataframe operations","text":"<pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\n\ndef my_func(df: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df)\n    df = df.with_columns(a_plus_one=nw.col(\"a\") + 1)\n    return nw.to_native(df)\n</code></pre> <p>Let's start with a dataframe with an Index with values <code>[7, 8, 9]</code>.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\"a\": [2, 1, 3], \"b\": [3, 5, -3]}, index=[7, 8, 9])\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  a_plus_one\n7  2  3           3\n8  1  5           2\n9  3 -3           4\n</code></pre> <p>Note how the result still has the original index - Narwhals did not modify it. Narwhals will preserve your original index for most common dataframe operations. However, Narwhals will not preserve the original index for <code>DataFrame.group_by</code>, because there, overlapping index and column names raise errors.</p>"},{"location":"concepts/pandas_index/#2-index-alignment-follows-the-left-hand-rule","title":"2. Index alignment follows the left-hand-rule","text":"<p>pandas automatically aligns indices for users. For example:</p> <pre><code>import pandas as pd\n\ndf_pd = pd.DataFrame({\"a\": [2, 1, 3], \"b\": [4, 5, 6]})\ns_pd = df_pd[\"a\"].sort_values()\ndf_pd[\"a_sorted\"] = s_pd\n</code></pre> <p>Reading the code, you might expect that <code>'a_sorted'</code> will contain the values <code>[1, 2, 3]</code>.</p> <p>However, here's what actually happens:</p> <pre><code>print(df_pd)\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         2\n1  1  5         1\n2  3  6         3\n</code></pre> <p>In other words, pandas' index alignment undid the <code>sort_values</code> operation!</p> <p>Narwhals, on the other hand, preserves the index of the left-hand-side argument. Everything else will be inserted positionally, just like Polars would do:</p> <pre><code>import narwhals as nw\n\ndf = nw.from_native(df_pd)\ns = nw.from_native(s_pd, allow_series=True)\ndf = df.with_columns(a_sorted=s.sort())\nprint(nw.to_native(df))\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         1\n1  1  5         2\n2  3  6         3\n</code></pre> <p>If you keep these two rules in mind, then Narwhals will both help you avoid Index-related surprises whilst letting you preserve the Index for the subset of your users who consciously make great use of it.</p>"}]}